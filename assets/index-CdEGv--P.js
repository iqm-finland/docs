(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))i(a);new MutationObserver(a=>{for(const o of a)if(o.type==="childList")for(const s of o.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&i(s)}).observe(document,{childList:!0,subtree:!0});function n(a){const o={};return a.integrity&&(o.integrity=a.integrity),a.referrerPolicy&&(o.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?o.credentials="include":a.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(a){if(a.ep)return;a.ep=!0;const o=n(a);fetch(a.href,o)}})();var ml={exports:{}},ha={},fl={exports:{}},R={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ai=Symbol.for("react.element"),Qc=Symbol.for("react.portal"),Lc=Symbol.for("react.fragment"),Nc=Symbol.for("react.strict_mode"),Gc=Symbol.for("react.profiler"),Dc=Symbol.for("react.provider"),zc=Symbol.for("react.context"),Wc=Symbol.for("react.forward_ref"),Uc=Symbol.for("react.suspense"),Xc=Symbol.for("react.memo"),Vc=Symbol.for("react.lazy"),Js=Symbol.iterator;function jc(e){return e===null||typeof e!="object"?null:(e=Js&&e[Js]||e["@@iterator"],typeof e=="function"?e:null)}var gl={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},yl=Object.assign,vl={};function gn(e,t,n){this.props=e,this.context=t,this.refs=vl,this.updater=n||gl}gn.prototype.isReactComponent={};gn.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};gn.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function bl(){}bl.prototype=gn.prototype;function as(e,t,n){this.props=e,this.context=t,this.refs=vl,this.updater=n||gl}var os=as.prototype=new bl;os.constructor=as;yl(os,gn.prototype);os.isPureReactComponent=!0;var er=Array.isArray,_l=Object.prototype.hasOwnProperty,ss={current:null},wl={key:!0,ref:!0,__self:!0,__source:!0};function ql(e,t,n){var i,a={},o=null,s=null;if(t!=null)for(i in t.ref!==void 0&&(s=t.ref),t.key!==void 0&&(o=""+t.key),t)_l.call(t,i)&&!wl.hasOwnProperty(i)&&(a[i]=t[i]);var r=arguments.length-2;if(r===1)a.children=n;else if(1<r){for(var l=Array(r),u=0;u<r;u++)l[u]=arguments[u+2];a.children=l}if(e&&e.defaultProps)for(i in r=e.defaultProps,r)a[i]===void 0&&(a[i]=r[i]);return{$$typeof:ai,type:e,key:o,ref:s,props:a,_owner:ss.current}}function Zc(e,t){return{$$typeof:ai,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function rs(e){return typeof e=="object"&&e!==null&&e.$$typeof===ai}function Hc(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var tr=/\/+/g;function Pa(e,t){return typeof e=="object"&&e!==null&&e.key!=null?Hc(""+e.key):t.toString(36)}function Mi(e,t,n,i,a){var o=typeof e;(o==="undefined"||o==="boolean")&&(e=null);var s=!1;if(e===null)s=!0;else switch(o){case"string":case"number":s=!0;break;case"object":switch(e.$$typeof){case ai:case Qc:s=!0}}if(s)return s=e,a=a(s),e=i===""?"."+Pa(s,0):i,er(a)?(n="",e!=null&&(n=e.replace(tr,"$&/")+"/"),Mi(a,t,n,"",function(u){return u})):a!=null&&(rs(a)&&(a=Zc(a,n+(!a.key||s&&s.key===a.key?"":(""+a.key).replace(tr,"$&/")+"/")+e)),t.push(a)),1;if(s=0,i=i===""?".":i+":",er(e))for(var r=0;r<e.length;r++){o=e[r];var l=i+Pa(o,r);s+=Mi(o,t,n,l,a)}else if(l=jc(e),typeof l=="function")for(e=l.call(e),r=0;!(o=e.next()).done;)o=o.value,l=i+Pa(o,r++),s+=Mi(o,t,n,l,a);else if(o==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return s}function di(e,t,n){if(e==null)return e;var i=[],a=0;return Mi(e,i,"","",function(o){return t.call(n,o,a++)}),i}function $c(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var ue={current:null},Ai={transition:null},Yc={ReactCurrentDispatcher:ue,ReactCurrentBatchConfig:Ai,ReactCurrentOwner:ss};function Cl(){throw Error("act(...) is not supported in production builds of React.")}R.Children={map:di,forEach:function(e,t,n){di(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return di(e,function(){t++}),t},toArray:function(e){return di(e,function(t){return t})||[]},only:function(e){if(!rs(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};R.Component=gn;R.Fragment=Lc;R.Profiler=Gc;R.PureComponent=as;R.StrictMode=Nc;R.Suspense=Uc;R.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Yc;R.act=Cl;R.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var i=yl({},e.props),a=e.key,o=e.ref,s=e._owner;if(t!=null){if(t.ref!==void 0&&(o=t.ref,s=ss.current),t.key!==void 0&&(a=""+t.key),e.type&&e.type.defaultProps)var r=e.type.defaultProps;for(l in t)_l.call(t,l)&&!wl.hasOwnProperty(l)&&(i[l]=t[l]===void 0&&r!==void 0?r[l]:t[l])}var l=arguments.length-2;if(l===1)i.children=n;else if(1<l){r=Array(l);for(var u=0;u<l;u++)r[u]=arguments[u+2];i.children=r}return{$$typeof:ai,type:e.type,key:a,ref:o,props:i,_owner:s}};R.createContext=function(e){return e={$$typeof:zc,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:Dc,_context:e},e.Consumer=e};R.createElement=ql;R.createFactory=function(e){var t=ql.bind(null,e);return t.type=e,t};R.createRef=function(){return{current:null}};R.forwardRef=function(e){return{$$typeof:Wc,render:e}};R.isValidElement=rs;R.lazy=function(e){return{$$typeof:Vc,_payload:{_status:-1,_result:e},_init:$c}};R.memo=function(e,t){return{$$typeof:Xc,type:e,compare:t===void 0?null:t}};R.startTransition=function(e){var t=Ai.transition;Ai.transition={};try{e()}finally{Ai.transition=t}};R.unstable_act=Cl;R.useCallback=function(e,t){return ue.current.useCallback(e,t)};R.useContext=function(e){return ue.current.useContext(e)};R.useDebugValue=function(){};R.useDeferredValue=function(e){return ue.current.useDeferredValue(e)};R.useEffect=function(e,t){return ue.current.useEffect(e,t)};R.useId=function(){return ue.current.useId()};R.useImperativeHandle=function(e,t,n){return ue.current.useImperativeHandle(e,t,n)};R.useInsertionEffect=function(e,t){return ue.current.useInsertionEffect(e,t)};R.useLayoutEffect=function(e,t){return ue.current.useLayoutEffect(e,t)};R.useMemo=function(e,t){return ue.current.useMemo(e,t)};R.useReducer=function(e,t,n){return ue.current.useReducer(e,t,n)};R.useRef=function(e){return ue.current.useRef(e)};R.useState=function(e){return ue.current.useState(e)};R.useSyncExternalStore=function(e,t,n){return ue.current.useSyncExternalStore(e,t,n)};R.useTransition=function(){return ue.current.useTransition()};R.version="18.3.1";fl.exports=R;var ve=fl.exports;/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Kc=ve,Jc=Symbol.for("react.element"),ed=Symbol.for("react.fragment"),td=Object.prototype.hasOwnProperty,nd=Kc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,id={key:!0,ref:!0,__self:!0,__source:!0};function xl(e,t,n){var i,a={},o=null,s=null;n!==void 0&&(o=""+n),t.key!==void 0&&(o=""+t.key),t.ref!==void 0&&(s=t.ref);for(i in t)td.call(t,i)&&!id.hasOwnProperty(i)&&(a[i]=t[i]);if(e&&e.defaultProps)for(i in t=e.defaultProps,t)a[i]===void 0&&(a[i]=t[i]);return{$$typeof:Jc,type:e,key:o,ref:s,props:a,_owner:nd.current}}ha.Fragment=ed;ha.jsx=xl;ha.jsxs=xl;ml.exports=ha;var k=ml.exports,Sl={exports:{}},Ce={},Il={exports:{}},kl={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(x,M){var P=x.length;x.push(M);e:for(;0<P;){var X=P-1>>>1,$=x[X];if(0<a($,M))x[X]=M,x[P]=$,P=X;else break e}}function n(x){return x.length===0?null:x[0]}function i(x){if(x.length===0)return null;var M=x[0],P=x.pop();if(P!==M){x[0]=P;e:for(var X=0,$=x.length,ui=$>>>1;X<ui;){var Ct=2*(X+1)-1,Aa=x[Ct],xt=Ct+1,ci=x[xt];if(0>a(Aa,P))xt<$&&0>a(ci,Aa)?(x[X]=ci,x[xt]=P,X=xt):(x[X]=Aa,x[Ct]=P,X=Ct);else if(xt<$&&0>a(ci,P))x[X]=ci,x[xt]=P,X=xt;else break e}}return M}function a(x,M){var P=x.sortIndex-M.sortIndex;return P!==0?P:x.id-M.id}if(typeof performance=="object"&&typeof performance.now=="function"){var o=performance;e.unstable_now=function(){return o.now()}}else{var s=Date,r=s.now();e.unstable_now=function(){return s.now()-r}}var l=[],u=[],f=1,m=null,p=3,g=!1,v=!1,_=!1,B=typeof setTimeout=="function"?setTimeout:null,d=typeof clearTimeout=="function"?clearTimeout:null,c=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function h(x){for(var M=n(u);M!==null;){if(M.callback===null)i(u);else if(M.startTime<=x)i(u),M.sortIndex=M.expirationTime,t(l,M);else break;M=n(u)}}function y(x){if(_=!1,h(x),!v)if(n(l)!==null)v=!0,zt(q);else{var M=n(u);M!==null&&Ma(y,M.startTime-x)}}function q(x,M){v=!1,_&&(_=!1,d(S),S=-1),g=!0;var P=p;try{for(h(M),m=n(l);m!==null&&(!(m.expirationTime>M)||x&&!se());){var X=m.callback;if(typeof X=="function"){m.callback=null,p=m.priorityLevel;var $=X(m.expirationTime<=M);M=e.unstable_now(),typeof $=="function"?m.callback=$:m===n(l)&&i(l),h(M)}else i(l);m=n(l)}if(m!==null)var ui=!0;else{var Ct=n(u);Ct!==null&&Ma(y,Ct.startTime-M),ui=!1}return ui}finally{m=null,p=P,g=!1}}var I=!1,w=null,S=-1,E=5,A=-1;function se(){return!(e.unstable_now()-A<E)}function Se(){if(w!==null){var x=e.unstable_now();A=x;var M=!0;try{M=w(!0,x)}finally{M?Gt():(I=!1,w=null)}}else I=!1}var Gt;if(typeof c=="function")Gt=function(){c(Se)};else if(typeof MessageChannel<"u"){var de=new MessageChannel,Dt=de.port2;de.port1.onmessage=Se,Gt=function(){Dt.postMessage(null)}}else Gt=function(){B(Se,0)};function zt(x){w=x,I||(I=!0,Gt())}function Ma(x,M){S=B(function(){x(e.unstable_now())},M)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(x){x.callback=null},e.unstable_continueExecution=function(){v||g||(v=!0,zt(q))},e.unstable_forceFrameRate=function(x){0>x||125<x?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):E=0<x?Math.floor(1e3/x):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return n(l)},e.unstable_next=function(x){switch(p){case 1:case 2:case 3:var M=3;break;default:M=p}var P=p;p=M;try{return x()}finally{p=P}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(x,M){switch(x){case 1:case 2:case 3:case 4:case 5:break;default:x=3}var P=p;p=x;try{return M()}finally{p=P}},e.unstable_scheduleCallback=function(x,M,P){var X=e.unstable_now();switch(typeof P=="object"&&P!==null?(P=P.delay,P=typeof P=="number"&&0<P?X+P:X):P=X,x){case 1:var $=-1;break;case 2:$=250;break;case 5:$=1073741823;break;case 4:$=1e4;break;default:$=5e3}return $=P+$,x={id:f++,callback:M,priorityLevel:x,startTime:P,expirationTime:$,sortIndex:-1},P>X?(x.sortIndex=P,t(u,x),n(l)===null&&x===n(u)&&(_?(d(S),S=-1):_=!0,Ma(y,P-X))):(x.sortIndex=$,t(l,x),v||g||(v=!0,zt(q))),x},e.unstable_shouldYield=se,e.unstable_wrapCallback=function(x){var M=p;return function(){var P=p;p=M;try{return x.apply(this,arguments)}finally{p=P}}}})(kl);Il.exports=kl;var ad=Il.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var od=ve,qe=ad;function b(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var Tl=new Set,Dn={};function Lt(e,t){un(e,t),un(e+"Capture",t)}function un(e,t){for(Dn[e]=t,e=0;e<t.length;e++)Tl.add(t[e])}var $e=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),oo=Object.prototype.hasOwnProperty,sd=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,nr={},ir={};function rd(e){return oo.call(ir,e)?!0:oo.call(nr,e)?!1:sd.test(e)?ir[e]=!0:(nr[e]=!0,!1)}function ld(e,t,n,i){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return i?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function ud(e,t,n,i){if(t===null||typeof t>"u"||ld(e,t,n,i))return!0;if(i)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function ce(e,t,n,i,a,o,s){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=i,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=o,this.removeEmptyString=s}var te={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){te[e]=new ce(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];te[t]=new ce(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){te[e]=new ce(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){te[e]=new ce(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){te[e]=new ce(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){te[e]=new ce(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){te[e]=new ce(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){te[e]=new ce(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){te[e]=new ce(e,5,!1,e.toLowerCase(),null,!1,!1)});var ls=/[\-:]([a-z])/g;function us(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(ls,us);te[t]=new ce(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(ls,us);te[t]=new ce(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(ls,us);te[t]=new ce(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){te[e]=new ce(e,1,!1,e.toLowerCase(),null,!1,!1)});te.xlinkHref=new ce("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){te[e]=new ce(e,1,!1,e.toLowerCase(),null,!0,!0)});function cs(e,t,n,i){var a=te.hasOwnProperty(t)?te[t]:null;(a!==null?a.type!==0:i||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(ud(t,n,a,i)&&(n=null),i||a===null?rd(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=n===null?a.type===3?!1:"":n:(t=a.attributeName,i=a.attributeNamespace,n===null?e.removeAttribute(t):(a=a.type,n=a===3||a===4&&n===!0?"":""+n,i?e.setAttributeNS(i,t,n):e.setAttribute(t,n))))}var tt=od.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,pi=Symbol.for("react.element"),Ut=Symbol.for("react.portal"),Xt=Symbol.for("react.fragment"),ds=Symbol.for("react.strict_mode"),so=Symbol.for("react.profiler"),Ml=Symbol.for("react.provider"),Al=Symbol.for("react.context"),ps=Symbol.for("react.forward_ref"),ro=Symbol.for("react.suspense"),lo=Symbol.for("react.suspense_list"),hs=Symbol.for("react.memo"),it=Symbol.for("react.lazy"),Pl=Symbol.for("react.offscreen"),ar=Symbol.iterator;function _n(e){return e===null||typeof e!="object"?null:(e=ar&&e[ar]||e["@@iterator"],typeof e=="function"?e:null)}var W=Object.assign,Ra;function Tn(e){if(Ra===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Ra=t&&t[1]||""}return`
`+Ra+e}var Ba=!1;function Oa(e,t){if(!e||Ba)return"";Ba=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var i=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){i=u}e.call(t.prototype)}else{try{throw Error()}catch(u){i=u}e()}}catch(u){if(u&&i&&typeof u.stack=="string"){for(var a=u.stack.split(`
`),o=i.stack.split(`
`),s=a.length-1,r=o.length-1;1<=s&&0<=r&&a[s]!==o[r];)r--;for(;1<=s&&0<=r;s--,r--)if(a[s]!==o[r]){if(s!==1||r!==1)do if(s--,r--,0>r||a[s]!==o[r]){var l=`
`+a[s].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}while(1<=s&&0<=r);break}}}finally{Ba=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?Tn(e):""}function cd(e){switch(e.tag){case 5:return Tn(e.type);case 16:return Tn("Lazy");case 13:return Tn("Suspense");case 19:return Tn("SuspenseList");case 0:case 2:case 15:return e=Oa(e.type,!1),e;case 11:return e=Oa(e.type.render,!1),e;case 1:return e=Oa(e.type,!0),e;default:return""}}function uo(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case Xt:return"Fragment";case Ut:return"Portal";case so:return"Profiler";case ds:return"StrictMode";case ro:return"Suspense";case lo:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case Al:return(e.displayName||"Context")+".Consumer";case Ml:return(e._context.displayName||"Context")+".Provider";case ps:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case hs:return t=e.displayName||null,t!==null?t:uo(e.type)||"Memo";case it:t=e._payload,e=e._init;try{return uo(e(t))}catch{}}return null}function dd(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return uo(t);case 8:return t===ds?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function yt(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function Rl(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function pd(e){var t=Rl(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),i=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var a=n.get,o=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(s){i=""+s,o.call(this,s)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return i},setValue:function(s){i=""+s},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function hi(e){e._valueTracker||(e._valueTracker=pd(e))}function Bl(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),i="";return e&&(i=Rl(e)?e.checked?"true":"false":e.value),e=i,e!==n?(t.setValue(e),!0):!1}function Di(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function co(e,t){var n=t.checked;return W({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function or(e,t){var n=t.defaultValue==null?"":t.defaultValue,i=t.checked!=null?t.checked:t.defaultChecked;n=yt(t.value!=null?t.value:n),e._wrapperState={initialChecked:i,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function Ol(e,t){t=t.checked,t!=null&&cs(e,"checked",t,!1)}function po(e,t){Ol(e,t);var n=yt(t.value),i=t.type;if(n!=null)i==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(i==="submit"||i==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?ho(e,t.type,n):t.hasOwnProperty("defaultValue")&&ho(e,t.type,yt(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function sr(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var i=t.type;if(!(i!=="submit"&&i!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function ho(e,t,n){(t!=="number"||Di(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var Mn=Array.isArray;function nn(e,t,n,i){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&i&&(e[n].defaultSelected=!0)}else{for(n=""+yt(n),t=null,a=0;a<e.length;a++){if(e[a].value===n){e[a].selected=!0,i&&(e[a].defaultSelected=!0);return}t!==null||e[a].disabled||(t=e[a])}t!==null&&(t.selected=!0)}}function mo(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(b(91));return W({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function rr(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(b(92));if(Mn(n)){if(1<n.length)throw Error(b(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:yt(n)}}function El(e,t){var n=yt(t.value),i=yt(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),i!=null&&(e.defaultValue=""+i)}function lr(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function Fl(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function fo(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?Fl(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var mi,Ql=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,i,a){MSApp.execUnsafeLocalFunction(function(){return e(t,n,i,a)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(mi=mi||document.createElement("div"),mi.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=mi.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function zn(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var Rn={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},hd=["Webkit","ms","Moz","O"];Object.keys(Rn).forEach(function(e){hd.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),Rn[t]=Rn[e]})});function Ll(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||Rn.hasOwnProperty(e)&&Rn[e]?(""+t).trim():t+"px"}function Nl(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var i=n.indexOf("--")===0,a=Ll(n,t[n],i);n==="float"&&(n="cssFloat"),i?e.setProperty(n,a):e[n]=a}}var md=W({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function go(e,t){if(t){if(md[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(b(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(b(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(b(61))}if(t.style!=null&&typeof t.style!="object")throw Error(b(62))}}function yo(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var vo=null;function ms(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var bo=null,an=null,on=null;function ur(e){if(e=ri(e)){if(typeof bo!="function")throw Error(b(280));var t=e.stateNode;t&&(t=va(t),bo(e.stateNode,e.type,t))}}function Gl(e){an?on?on.push(e):on=[e]:an=e}function Dl(){if(an){var e=an,t=on;if(on=an=null,ur(e),t)for(e=0;e<t.length;e++)ur(t[e])}}function zl(e,t){return e(t)}function Wl(){}var Ea=!1;function Ul(e,t,n){if(Ea)return e(t,n);Ea=!0;try{return zl(e,t,n)}finally{Ea=!1,(an!==null||on!==null)&&(Wl(),Dl())}}function Wn(e,t){var n=e.stateNode;if(n===null)return null;var i=va(n);if(i===null)return null;n=i[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(i=!i.disabled)||(e=e.type,i=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!i;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(b(231,t,typeof n));return n}var _o=!1;if($e)try{var wn={};Object.defineProperty(wn,"passive",{get:function(){_o=!0}}),window.addEventListener("test",wn,wn),window.removeEventListener("test",wn,wn)}catch{_o=!1}function fd(e,t,n,i,a,o,s,r,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(f){this.onError(f)}}var Bn=!1,zi=null,Wi=!1,wo=null,gd={onError:function(e){Bn=!0,zi=e}};function yd(e,t,n,i,a,o,s,r,l){Bn=!1,zi=null,fd.apply(gd,arguments)}function vd(e,t,n,i,a,o,s,r,l){if(yd.apply(this,arguments),Bn){if(Bn){var u=zi;Bn=!1,zi=null}else throw Error(b(198));Wi||(Wi=!0,wo=u)}}function Nt(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function Xl(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function cr(e){if(Nt(e)!==e)throw Error(b(188))}function bd(e){var t=e.alternate;if(!t){if(t=Nt(e),t===null)throw Error(b(188));return t!==e?null:e}for(var n=e,i=t;;){var a=n.return;if(a===null)break;var o=a.alternate;if(o===null){if(i=a.return,i!==null){n=i;continue}break}if(a.child===o.child){for(o=a.child;o;){if(o===n)return cr(a),e;if(o===i)return cr(a),t;o=o.sibling}throw Error(b(188))}if(n.return!==i.return)n=a,i=o;else{for(var s=!1,r=a.child;r;){if(r===n){s=!0,n=a,i=o;break}if(r===i){s=!0,i=a,n=o;break}r=r.sibling}if(!s){for(r=o.child;r;){if(r===n){s=!0,n=o,i=a;break}if(r===i){s=!0,i=o,n=a;break}r=r.sibling}if(!s)throw Error(b(189))}}if(n.alternate!==i)throw Error(b(190))}if(n.tag!==3)throw Error(b(188));return n.stateNode.current===n?e:t}function Vl(e){return e=bd(e),e!==null?jl(e):null}function jl(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=jl(e);if(t!==null)return t;e=e.sibling}return null}var Zl=qe.unstable_scheduleCallback,dr=qe.unstable_cancelCallback,_d=qe.unstable_shouldYield,wd=qe.unstable_requestPaint,V=qe.unstable_now,qd=qe.unstable_getCurrentPriorityLevel,fs=qe.unstable_ImmediatePriority,Hl=qe.unstable_UserBlockingPriority,Ui=qe.unstable_NormalPriority,Cd=qe.unstable_LowPriority,$l=qe.unstable_IdlePriority,ma=null,We=null;function xd(e){if(We&&typeof We.onCommitFiberRoot=="function")try{We.onCommitFiberRoot(ma,e,void 0,(e.current.flags&128)===128)}catch{}}var Fe=Math.clz32?Math.clz32:kd,Sd=Math.log,Id=Math.LN2;function kd(e){return e>>>=0,e===0?32:31-(Sd(e)/Id|0)|0}var fi=64,gi=4194304;function An(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Xi(e,t){var n=e.pendingLanes;if(n===0)return 0;var i=0,a=e.suspendedLanes,o=e.pingedLanes,s=n&268435455;if(s!==0){var r=s&~a;r!==0?i=An(r):(o&=s,o!==0&&(i=An(o)))}else s=n&~a,s!==0?i=An(s):o!==0&&(i=An(o));if(i===0)return 0;if(t!==0&&t!==i&&!(t&a)&&(a=i&-i,o=t&-t,a>=o||a===16&&(o&4194240)!==0))return t;if(i&4&&(i|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=i;0<t;)n=31-Fe(t),a=1<<n,i|=e[n],t&=~a;return i}function Td(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Md(e,t){for(var n=e.suspendedLanes,i=e.pingedLanes,a=e.expirationTimes,o=e.pendingLanes;0<o;){var s=31-Fe(o),r=1<<s,l=a[s];l===-1?(!(r&n)||r&i)&&(a[s]=Td(r,t)):l<=t&&(e.expiredLanes|=r),o&=~r}}function qo(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function Yl(){var e=fi;return fi<<=1,!(fi&4194240)&&(fi=64),e}function Fa(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function oi(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-Fe(t),e[t]=n}function Ad(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var i=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-Fe(n),o=1<<a;t[a]=0,i[a]=-1,e[a]=-1,n&=~o}}function gs(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var i=31-Fe(n),a=1<<i;a&t|e[i]&t&&(e[i]|=t),n&=~a}}var F=0;function Kl(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var Jl,ys,eu,tu,nu,Co=!1,yi=[],ut=null,ct=null,dt=null,Un=new Map,Xn=new Map,ot=[],Pd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function pr(e,t){switch(e){case"focusin":case"focusout":ut=null;break;case"dragenter":case"dragleave":ct=null;break;case"mouseover":case"mouseout":dt=null;break;case"pointerover":case"pointerout":Un.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Xn.delete(t.pointerId)}}function qn(e,t,n,i,a,o){return e===null||e.nativeEvent!==o?(e={blockedOn:t,domEventName:n,eventSystemFlags:i,nativeEvent:o,targetContainers:[a]},t!==null&&(t=ri(t),t!==null&&ys(t)),e):(e.eventSystemFlags|=i,t=e.targetContainers,a!==null&&t.indexOf(a)===-1&&t.push(a),e)}function Rd(e,t,n,i,a){switch(t){case"focusin":return ut=qn(ut,e,t,n,i,a),!0;case"dragenter":return ct=qn(ct,e,t,n,i,a),!0;case"mouseover":return dt=qn(dt,e,t,n,i,a),!0;case"pointerover":var o=a.pointerId;return Un.set(o,qn(Un.get(o)||null,e,t,n,i,a)),!0;case"gotpointercapture":return o=a.pointerId,Xn.set(o,qn(Xn.get(o)||null,e,t,n,i,a)),!0}return!1}function iu(e){var t=Tt(e.target);if(t!==null){var n=Nt(t);if(n!==null){if(t=n.tag,t===13){if(t=Xl(n),t!==null){e.blockedOn=t,nu(e.priority,function(){eu(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Pi(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=xo(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var i=new n.constructor(n.type,n);vo=i,n.target.dispatchEvent(i),vo=null}else return t=ri(n),t!==null&&ys(t),e.blockedOn=n,!1;t.shift()}return!0}function hr(e,t,n){Pi(e)&&n.delete(t)}function Bd(){Co=!1,ut!==null&&Pi(ut)&&(ut=null),ct!==null&&Pi(ct)&&(ct=null),dt!==null&&Pi(dt)&&(dt=null),Un.forEach(hr),Xn.forEach(hr)}function Cn(e,t){e.blockedOn===t&&(e.blockedOn=null,Co||(Co=!0,qe.unstable_scheduleCallback(qe.unstable_NormalPriority,Bd)))}function Vn(e){function t(a){return Cn(a,e)}if(0<yi.length){Cn(yi[0],e);for(var n=1;n<yi.length;n++){var i=yi[n];i.blockedOn===e&&(i.blockedOn=null)}}for(ut!==null&&Cn(ut,e),ct!==null&&Cn(ct,e),dt!==null&&Cn(dt,e),Un.forEach(t),Xn.forEach(t),n=0;n<ot.length;n++)i=ot[n],i.blockedOn===e&&(i.blockedOn=null);for(;0<ot.length&&(n=ot[0],n.blockedOn===null);)iu(n),n.blockedOn===null&&ot.shift()}var sn=tt.ReactCurrentBatchConfig,Vi=!0;function Od(e,t,n,i){var a=F,o=sn.transition;sn.transition=null;try{F=1,vs(e,t,n,i)}finally{F=a,sn.transition=o}}function Ed(e,t,n,i){var a=F,o=sn.transition;sn.transition=null;try{F=4,vs(e,t,n,i)}finally{F=a,sn.transition=o}}function vs(e,t,n,i){if(Vi){var a=xo(e,t,n,i);if(a===null)Va(e,t,i,ji,n),pr(e,i);else if(Rd(a,e,t,n,i))i.stopPropagation();else if(pr(e,i),t&4&&-1<Pd.indexOf(e)){for(;a!==null;){var o=ri(a);if(o!==null&&Jl(o),o=xo(e,t,n,i),o===null&&Va(e,t,i,ji,n),o===a)break;a=o}a!==null&&i.stopPropagation()}else Va(e,t,i,null,n)}}var ji=null;function xo(e,t,n,i){if(ji=null,e=ms(i),e=Tt(e),e!==null)if(t=Nt(e),t===null)e=null;else if(n=t.tag,n===13){if(e=Xl(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return ji=e,null}function au(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(qd()){case fs:return 1;case Hl:return 4;case Ui:case Cd:return 16;case $l:return 536870912;default:return 16}default:return 16}}var rt=null,bs=null,Ri=null;function ou(){if(Ri)return Ri;var e,t=bs,n=t.length,i,a="value"in rt?rt.value:rt.textContent,o=a.length;for(e=0;e<n&&t[e]===a[e];e++);var s=n-e;for(i=1;i<=s&&t[n-i]===a[o-i];i++);return Ri=a.slice(e,1<i?1-i:void 0)}function Bi(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function vi(){return!0}function mr(){return!1}function xe(e){function t(n,i,a,o,s){this._reactName=n,this._targetInst=a,this.type=i,this.nativeEvent=o,this.target=s,this.currentTarget=null;for(var r in e)e.hasOwnProperty(r)&&(n=e[r],this[r]=n?n(o):o[r]);return this.isDefaultPrevented=(o.defaultPrevented!=null?o.defaultPrevented:o.returnValue===!1)?vi:mr,this.isPropagationStopped=mr,this}return W(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=vi)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=vi)},persist:function(){},isPersistent:vi}),t}var yn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},_s=xe(yn),si=W({},yn,{view:0,detail:0}),Fd=xe(si),Qa,La,xn,fa=W({},si,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ws,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==xn&&(xn&&e.type==="mousemove"?(Qa=e.screenX-xn.screenX,La=e.screenY-xn.screenY):La=Qa=0,xn=e),Qa)},movementY:function(e){return"movementY"in e?e.movementY:La}}),fr=xe(fa),Qd=W({},fa,{dataTransfer:0}),Ld=xe(Qd),Nd=W({},si,{relatedTarget:0}),Na=xe(Nd),Gd=W({},yn,{animationName:0,elapsedTime:0,pseudoElement:0}),Dd=xe(Gd),zd=W({},yn,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Wd=xe(zd),Ud=W({},yn,{data:0}),gr=xe(Ud),Xd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Vd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},jd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Zd(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=jd[e])?!!t[e]:!1}function ws(){return Zd}var Hd=W({},si,{key:function(e){if(e.key){var t=Xd[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Bi(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?Vd[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ws,charCode:function(e){return e.type==="keypress"?Bi(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Bi(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),$d=xe(Hd),Yd=W({},fa,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),yr=xe(Yd),Kd=W({},si,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ws}),Jd=xe(Kd),ep=W({},yn,{propertyName:0,elapsedTime:0,pseudoElement:0}),tp=xe(ep),np=W({},fa,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),ip=xe(np),ap=[9,13,27,32],qs=$e&&"CompositionEvent"in window,On=null;$e&&"documentMode"in document&&(On=document.documentMode);var op=$e&&"TextEvent"in window&&!On,su=$e&&(!qs||On&&8<On&&11>=On),vr=" ",br=!1;function ru(e,t){switch(e){case"keyup":return ap.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function lu(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Vt=!1;function sp(e,t){switch(e){case"compositionend":return lu(t);case"keypress":return t.which!==32?null:(br=!0,vr);case"textInput":return e=t.data,e===vr&&br?null:e;default:return null}}function rp(e,t){if(Vt)return e==="compositionend"||!qs&&ru(e,t)?(e=ou(),Ri=bs=rt=null,Vt=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return su&&t.locale!=="ko"?null:t.data;default:return null}}var lp={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function _r(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!lp[e.type]:t==="textarea"}function uu(e,t,n,i){Gl(i),t=Zi(t,"onChange"),0<t.length&&(n=new _s("onChange","change",null,n,i),e.push({event:n,listeners:t}))}var En=null,jn=null;function up(e){_u(e,0)}function ga(e){var t=Ht(e);if(Bl(t))return e}function cp(e,t){if(e==="change")return t}var cu=!1;if($e){var Ga;if($e){var Da="oninput"in document;if(!Da){var wr=document.createElement("div");wr.setAttribute("oninput","return;"),Da=typeof wr.oninput=="function"}Ga=Da}else Ga=!1;cu=Ga&&(!document.documentMode||9<document.documentMode)}function qr(){En&&(En.detachEvent("onpropertychange",du),jn=En=null)}function du(e){if(e.propertyName==="value"&&ga(jn)){var t=[];uu(t,jn,e,ms(e)),Ul(up,t)}}function dp(e,t,n){e==="focusin"?(qr(),En=t,jn=n,En.attachEvent("onpropertychange",du)):e==="focusout"&&qr()}function pp(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return ga(jn)}function hp(e,t){if(e==="click")return ga(t)}function mp(e,t){if(e==="input"||e==="change")return ga(t)}function fp(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Le=typeof Object.is=="function"?Object.is:fp;function Zn(e,t){if(Le(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),i=Object.keys(t);if(n.length!==i.length)return!1;for(i=0;i<n.length;i++){var a=n[i];if(!oo.call(t,a)||!Le(e[a],t[a]))return!1}return!0}function Cr(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function xr(e,t){var n=Cr(e);e=0;for(var i;n;){if(n.nodeType===3){if(i=e+n.textContent.length,e<=t&&i>=t)return{node:n,offset:t-e};e=i}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=Cr(n)}}function pu(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?pu(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function hu(){for(var e=window,t=Di();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=Di(e.document)}return t}function Cs(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function gp(e){var t=hu(),n=e.focusedElem,i=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&pu(n.ownerDocument.documentElement,n)){if(i!==null&&Cs(n)){if(t=i.start,e=i.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var a=n.textContent.length,o=Math.min(i.start,a);i=i.end===void 0?o:Math.min(i.end,a),!e.extend&&o>i&&(a=i,i=o,o=a),a=xr(n,o);var s=xr(n,i);a&&s&&(e.rangeCount!==1||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==s.node||e.focusOffset!==s.offset)&&(t=t.createRange(),t.setStart(a.node,a.offset),e.removeAllRanges(),o>i?(e.addRange(t),e.extend(s.node,s.offset)):(t.setEnd(s.node,s.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var yp=$e&&"documentMode"in document&&11>=document.documentMode,jt=null,So=null,Fn=null,Io=!1;function Sr(e,t,n){var i=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;Io||jt==null||jt!==Di(i)||(i=jt,"selectionStart"in i&&Cs(i)?i={start:i.selectionStart,end:i.selectionEnd}:(i=(i.ownerDocument&&i.ownerDocument.defaultView||window).getSelection(),i={anchorNode:i.anchorNode,anchorOffset:i.anchorOffset,focusNode:i.focusNode,focusOffset:i.focusOffset}),Fn&&Zn(Fn,i)||(Fn=i,i=Zi(So,"onSelect"),0<i.length&&(t=new _s("onSelect","select",null,t,n),e.push({event:t,listeners:i}),t.target=jt)))}function bi(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var Zt={animationend:bi("Animation","AnimationEnd"),animationiteration:bi("Animation","AnimationIteration"),animationstart:bi("Animation","AnimationStart"),transitionend:bi("Transition","TransitionEnd")},za={},mu={};$e&&(mu=document.createElement("div").style,"AnimationEvent"in window||(delete Zt.animationend.animation,delete Zt.animationiteration.animation,delete Zt.animationstart.animation),"TransitionEvent"in window||delete Zt.transitionend.transition);function ya(e){if(za[e])return za[e];if(!Zt[e])return e;var t=Zt[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in mu)return za[e]=t[n];return e}var fu=ya("animationend"),gu=ya("animationiteration"),yu=ya("animationstart"),vu=ya("transitionend"),bu=new Map,Ir="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function bt(e,t){bu.set(e,t),Lt(t,[e])}for(var Wa=0;Wa<Ir.length;Wa++){var Ua=Ir[Wa],vp=Ua.toLowerCase(),bp=Ua[0].toUpperCase()+Ua.slice(1);bt(vp,"on"+bp)}bt(fu,"onAnimationEnd");bt(gu,"onAnimationIteration");bt(yu,"onAnimationStart");bt("dblclick","onDoubleClick");bt("focusin","onFocus");bt("focusout","onBlur");bt(vu,"onTransitionEnd");un("onMouseEnter",["mouseout","mouseover"]);un("onMouseLeave",["mouseout","mouseover"]);un("onPointerEnter",["pointerout","pointerover"]);un("onPointerLeave",["pointerout","pointerover"]);Lt("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Lt("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Lt("onBeforeInput",["compositionend","keypress","textInput","paste"]);Lt("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Lt("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Lt("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Pn="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),_p=new Set("cancel close invalid load scroll toggle".split(" ").concat(Pn));function kr(e,t,n){var i=e.type||"unknown-event";e.currentTarget=n,vd(i,t,void 0,e),e.currentTarget=null}function _u(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var i=e[n],a=i.event;i=i.listeners;e:{var o=void 0;if(t)for(var s=i.length-1;0<=s;s--){var r=i[s],l=r.instance,u=r.currentTarget;if(r=r.listener,l!==o&&a.isPropagationStopped())break e;kr(a,r,u),o=l}else for(s=0;s<i.length;s++){if(r=i[s],l=r.instance,u=r.currentTarget,r=r.listener,l!==o&&a.isPropagationStopped())break e;kr(a,r,u),o=l}}}if(Wi)throw e=wo,Wi=!1,wo=null,e}function L(e,t){var n=t[Po];n===void 0&&(n=t[Po]=new Set);var i=e+"__bubble";n.has(i)||(wu(t,e,2,!1),n.add(i))}function Xa(e,t,n){var i=0;t&&(i|=4),wu(n,e,i,t)}var _i="_reactListening"+Math.random().toString(36).slice(2);function Hn(e){if(!e[_i]){e[_i]=!0,Tl.forEach(function(n){n!=="selectionchange"&&(_p.has(n)||Xa(n,!1,e),Xa(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[_i]||(t[_i]=!0,Xa("selectionchange",!1,t))}}function wu(e,t,n,i){switch(au(t)){case 1:var a=Od;break;case 4:a=Ed;break;default:a=vs}n=a.bind(null,t,n,e),a=void 0,!_o||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(a=!0),i?a!==void 0?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):a!==void 0?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function Va(e,t,n,i,a){var o=i;if(!(t&1)&&!(t&2)&&i!==null)e:for(;;){if(i===null)return;var s=i.tag;if(s===3||s===4){var r=i.stateNode.containerInfo;if(r===a||r.nodeType===8&&r.parentNode===a)break;if(s===4)for(s=i.return;s!==null;){var l=s.tag;if((l===3||l===4)&&(l=s.stateNode.containerInfo,l===a||l.nodeType===8&&l.parentNode===a))return;s=s.return}for(;r!==null;){if(s=Tt(r),s===null)return;if(l=s.tag,l===5||l===6){i=o=s;continue e}r=r.parentNode}}i=i.return}Ul(function(){var u=o,f=ms(n),m=[];e:{var p=bu.get(e);if(p!==void 0){var g=_s,v=e;switch(e){case"keypress":if(Bi(n)===0)break e;case"keydown":case"keyup":g=$d;break;case"focusin":v="focus",g=Na;break;case"focusout":v="blur",g=Na;break;case"beforeblur":case"afterblur":g=Na;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":g=fr;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":g=Ld;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":g=Jd;break;case fu:case gu:case yu:g=Dd;break;case vu:g=tp;break;case"scroll":g=Fd;break;case"wheel":g=ip;break;case"copy":case"cut":case"paste":g=Wd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":g=yr}var _=(t&4)!==0,B=!_&&e==="scroll",d=_?p!==null?p+"Capture":null:p;_=[];for(var c=u,h;c!==null;){h=c;var y=h.stateNode;if(h.tag===5&&y!==null&&(h=y,d!==null&&(y=Wn(c,d),y!=null&&_.push($n(c,y,h)))),B)break;c=c.return}0<_.length&&(p=new g(p,v,null,n,f),m.push({event:p,listeners:_}))}}if(!(t&7)){e:{if(p=e==="mouseover"||e==="pointerover",g=e==="mouseout"||e==="pointerout",p&&n!==vo&&(v=n.relatedTarget||n.fromElement)&&(Tt(v)||v[Ye]))break e;if((g||p)&&(p=f.window===f?f:(p=f.ownerDocument)?p.defaultView||p.parentWindow:window,g?(v=n.relatedTarget||n.toElement,g=u,v=v?Tt(v):null,v!==null&&(B=Nt(v),v!==B||v.tag!==5&&v.tag!==6)&&(v=null)):(g=null,v=u),g!==v)){if(_=fr,y="onMouseLeave",d="onMouseEnter",c="mouse",(e==="pointerout"||e==="pointerover")&&(_=yr,y="onPointerLeave",d="onPointerEnter",c="pointer"),B=g==null?p:Ht(g),h=v==null?p:Ht(v),p=new _(y,c+"leave",g,n,f),p.target=B,p.relatedTarget=h,y=null,Tt(f)===u&&(_=new _(d,c+"enter",v,n,f),_.target=h,_.relatedTarget=B,y=_),B=y,g&&v)t:{for(_=g,d=v,c=0,h=_;h;h=Wt(h))c++;for(h=0,y=d;y;y=Wt(y))h++;for(;0<c-h;)_=Wt(_),c--;for(;0<h-c;)d=Wt(d),h--;for(;c--;){if(_===d||d!==null&&_===d.alternate)break t;_=Wt(_),d=Wt(d)}_=null}else _=null;g!==null&&Tr(m,p,g,_,!1),v!==null&&B!==null&&Tr(m,B,v,_,!0)}}e:{if(p=u?Ht(u):window,g=p.nodeName&&p.nodeName.toLowerCase(),g==="select"||g==="input"&&p.type==="file")var q=cp;else if(_r(p))if(cu)q=mp;else{q=pp;var I=dp}else(g=p.nodeName)&&g.toLowerCase()==="input"&&(p.type==="checkbox"||p.type==="radio")&&(q=hp);if(q&&(q=q(e,u))){uu(m,q,n,f);break e}I&&I(e,p,u),e==="focusout"&&(I=p._wrapperState)&&I.controlled&&p.type==="number"&&ho(p,"number",p.value)}switch(I=u?Ht(u):window,e){case"focusin":(_r(I)||I.contentEditable==="true")&&(jt=I,So=u,Fn=null);break;case"focusout":Fn=So=jt=null;break;case"mousedown":Io=!0;break;case"contextmenu":case"mouseup":case"dragend":Io=!1,Sr(m,n,f);break;case"selectionchange":if(yp)break;case"keydown":case"keyup":Sr(m,n,f)}var w;if(qs)e:{switch(e){case"compositionstart":var S="onCompositionStart";break e;case"compositionend":S="onCompositionEnd";break e;case"compositionupdate":S="onCompositionUpdate";break e}S=void 0}else Vt?ru(e,n)&&(S="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(S="onCompositionStart");S&&(su&&n.locale!=="ko"&&(Vt||S!=="onCompositionStart"?S==="onCompositionEnd"&&Vt&&(w=ou()):(rt=f,bs="value"in rt?rt.value:rt.textContent,Vt=!0)),I=Zi(u,S),0<I.length&&(S=new gr(S,e,null,n,f),m.push({event:S,listeners:I}),w?S.data=w:(w=lu(n),w!==null&&(S.data=w)))),(w=op?sp(e,n):rp(e,n))&&(u=Zi(u,"onBeforeInput"),0<u.length&&(f=new gr("onBeforeInput","beforeinput",null,n,f),m.push({event:f,listeners:u}),f.data=w))}_u(m,t)})}function $n(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Zi(e,t){for(var n=t+"Capture",i=[];e!==null;){var a=e,o=a.stateNode;a.tag===5&&o!==null&&(a=o,o=Wn(e,n),o!=null&&i.unshift($n(e,o,a)),o=Wn(e,t),o!=null&&i.push($n(e,o,a))),e=e.return}return i}function Wt(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function Tr(e,t,n,i,a){for(var o=t._reactName,s=[];n!==null&&n!==i;){var r=n,l=r.alternate,u=r.stateNode;if(l!==null&&l===i)break;r.tag===5&&u!==null&&(r=u,a?(l=Wn(n,o),l!=null&&s.unshift($n(n,l,r))):a||(l=Wn(n,o),l!=null&&s.push($n(n,l,r)))),n=n.return}s.length!==0&&e.push({event:t,listeners:s})}var wp=/\r\n?/g,qp=/\u0000|\uFFFD/g;function Mr(e){return(typeof e=="string"?e:""+e).replace(wp,`
`).replace(qp,"")}function wi(e,t,n){if(t=Mr(t),Mr(e)!==t&&n)throw Error(b(425))}function Hi(){}var ko=null,To=null;function Mo(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var Ao=typeof setTimeout=="function"?setTimeout:void 0,Cp=typeof clearTimeout=="function"?clearTimeout:void 0,Ar=typeof Promise=="function"?Promise:void 0,xp=typeof queueMicrotask=="function"?queueMicrotask:typeof Ar<"u"?function(e){return Ar.resolve(null).then(e).catch(Sp)}:Ao;function Sp(e){setTimeout(function(){throw e})}function ja(e,t){var n=t,i=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&a.nodeType===8)if(n=a.data,n==="/$"){if(i===0){e.removeChild(a),Vn(t);return}i--}else n!=="$"&&n!=="$?"&&n!=="$!"||i++;n=a}while(n);Vn(t)}function pt(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function Pr(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var vn=Math.random().toString(36).slice(2),De="__reactFiber$"+vn,Yn="__reactProps$"+vn,Ye="__reactContainer$"+vn,Po="__reactEvents$"+vn,Ip="__reactListeners$"+vn,kp="__reactHandles$"+vn;function Tt(e){var t=e[De];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Ye]||n[De]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=Pr(e);e!==null;){if(n=e[De])return n;e=Pr(e)}return t}e=n,n=e.parentNode}return null}function ri(e){return e=e[De]||e[Ye],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function Ht(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(b(33))}function va(e){return e[Yn]||null}var Ro=[],$t=-1;function _t(e){return{current:e}}function N(e){0>$t||(e.current=Ro[$t],Ro[$t]=null,$t--)}function Q(e,t){$t++,Ro[$t]=e.current,e.current=t}var vt={},oe=_t(vt),me=_t(!1),Bt=vt;function cn(e,t){var n=e.type.contextTypes;if(!n)return vt;var i=e.stateNode;if(i&&i.__reactInternalMemoizedUnmaskedChildContext===t)return i.__reactInternalMemoizedMaskedChildContext;var a={},o;for(o in n)a[o]=t[o];return i&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function fe(e){return e=e.childContextTypes,e!=null}function $i(){N(me),N(oe)}function Rr(e,t,n){if(oe.current!==vt)throw Error(b(168));Q(oe,t),Q(me,n)}function qu(e,t,n){var i=e.stateNode;if(t=t.childContextTypes,typeof i.getChildContext!="function")return n;i=i.getChildContext();for(var a in i)if(!(a in t))throw Error(b(108,dd(e)||"Unknown",a));return W({},n,i)}function Yi(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||vt,Bt=oe.current,Q(oe,e),Q(me,me.current),!0}function Br(e,t,n){var i=e.stateNode;if(!i)throw Error(b(169));n?(e=qu(e,t,Bt),i.__reactInternalMemoizedMergedChildContext=e,N(me),N(oe),Q(oe,e)):N(me),Q(me,n)}var Ve=null,ba=!1,Za=!1;function Cu(e){Ve===null?Ve=[e]:Ve.push(e)}function Tp(e){ba=!0,Cu(e)}function wt(){if(!Za&&Ve!==null){Za=!0;var e=0,t=F;try{var n=Ve;for(F=1;e<n.length;e++){var i=n[e];do i=i(!0);while(i!==null)}Ve=null,ba=!1}catch(a){throw Ve!==null&&(Ve=Ve.slice(e+1)),Zl(fs,wt),a}finally{F=t,Za=!1}}return null}var Yt=[],Kt=0,Ki=null,Ji=0,Ie=[],ke=0,Ot=null,je=1,Ze="";function St(e,t){Yt[Kt++]=Ji,Yt[Kt++]=Ki,Ki=e,Ji=t}function xu(e,t,n){Ie[ke++]=je,Ie[ke++]=Ze,Ie[ke++]=Ot,Ot=e;var i=je;e=Ze;var a=32-Fe(i)-1;i&=~(1<<a),n+=1;var o=32-Fe(t)+a;if(30<o){var s=a-a%5;o=(i&(1<<s)-1).toString(32),i>>=s,a-=s,je=1<<32-Fe(t)+a|n<<a|i,Ze=o+e}else je=1<<o|n<<a|i,Ze=e}function xs(e){e.return!==null&&(St(e,1),xu(e,1,0))}function Ss(e){for(;e===Ki;)Ki=Yt[--Kt],Yt[Kt]=null,Ji=Yt[--Kt],Yt[Kt]=null;for(;e===Ot;)Ot=Ie[--ke],Ie[ke]=null,Ze=Ie[--ke],Ie[ke]=null,je=Ie[--ke],Ie[ke]=null}var we=null,_e=null,G=!1,Ee=null;function Su(e,t){var n=Te(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function Or(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,we=e,_e=pt(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,we=e,_e=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=Ot!==null?{id:je,overflow:Ze}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=Te(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,we=e,_e=null,!0):!1;default:return!1}}function Bo(e){return(e.mode&1)!==0&&(e.flags&128)===0}function Oo(e){if(G){var t=_e;if(t){var n=t;if(!Or(e,t)){if(Bo(e))throw Error(b(418));t=pt(n.nextSibling);var i=we;t&&Or(e,t)?Su(i,n):(e.flags=e.flags&-4097|2,G=!1,we=e)}}else{if(Bo(e))throw Error(b(418));e.flags=e.flags&-4097|2,G=!1,we=e}}}function Er(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;we=e}function qi(e){if(e!==we)return!1;if(!G)return Er(e),G=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!Mo(e.type,e.memoizedProps)),t&&(t=_e)){if(Bo(e))throw Iu(),Error(b(418));for(;t;)Su(e,t),t=pt(t.nextSibling)}if(Er(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(b(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){_e=pt(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}_e=null}}else _e=we?pt(e.stateNode.nextSibling):null;return!0}function Iu(){for(var e=_e;e;)e=pt(e.nextSibling)}function dn(){_e=we=null,G=!1}function Is(e){Ee===null?Ee=[e]:Ee.push(e)}var Mp=tt.ReactCurrentBatchConfig;function Sn(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(b(309));var i=n.stateNode}if(!i)throw Error(b(147,e));var a=i,o=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===o?t.ref:(t=function(s){var r=a.refs;s===null?delete r[o]:r[o]=s},t._stringRef=o,t)}if(typeof e!="string")throw Error(b(284));if(!n._owner)throw Error(b(290,e))}return e}function Ci(e,t){throw e=Object.prototype.toString.call(t),Error(b(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Fr(e){var t=e._init;return t(e._payload)}function ku(e){function t(d,c){if(e){var h=d.deletions;h===null?(d.deletions=[c],d.flags|=16):h.push(c)}}function n(d,c){if(!e)return null;for(;c!==null;)t(d,c),c=c.sibling;return null}function i(d,c){for(d=new Map;c!==null;)c.key!==null?d.set(c.key,c):d.set(c.index,c),c=c.sibling;return d}function a(d,c){return d=gt(d,c),d.index=0,d.sibling=null,d}function o(d,c,h){return d.index=h,e?(h=d.alternate,h!==null?(h=h.index,h<c?(d.flags|=2,c):h):(d.flags|=2,c)):(d.flags|=1048576,c)}function s(d){return e&&d.alternate===null&&(d.flags|=2),d}function r(d,c,h,y){return c===null||c.tag!==6?(c=to(h,d.mode,y),c.return=d,c):(c=a(c,h),c.return=d,c)}function l(d,c,h,y){var q=h.type;return q===Xt?f(d,c,h.props.children,y,h.key):c!==null&&(c.elementType===q||typeof q=="object"&&q!==null&&q.$$typeof===it&&Fr(q)===c.type)?(y=a(c,h.props),y.ref=Sn(d,c,h),y.return=d,y):(y=Gi(h.type,h.key,h.props,null,d.mode,y),y.ref=Sn(d,c,h),y.return=d,y)}function u(d,c,h,y){return c===null||c.tag!==4||c.stateNode.containerInfo!==h.containerInfo||c.stateNode.implementation!==h.implementation?(c=no(h,d.mode,y),c.return=d,c):(c=a(c,h.children||[]),c.return=d,c)}function f(d,c,h,y,q){return c===null||c.tag!==7?(c=Rt(h,d.mode,y,q),c.return=d,c):(c=a(c,h),c.return=d,c)}function m(d,c,h){if(typeof c=="string"&&c!==""||typeof c=="number")return c=to(""+c,d.mode,h),c.return=d,c;if(typeof c=="object"&&c!==null){switch(c.$$typeof){case pi:return h=Gi(c.type,c.key,c.props,null,d.mode,h),h.ref=Sn(d,null,c),h.return=d,h;case Ut:return c=no(c,d.mode,h),c.return=d,c;case it:var y=c._init;return m(d,y(c._payload),h)}if(Mn(c)||_n(c))return c=Rt(c,d.mode,h,null),c.return=d,c;Ci(d,c)}return null}function p(d,c,h,y){var q=c!==null?c.key:null;if(typeof h=="string"&&h!==""||typeof h=="number")return q!==null?null:r(d,c,""+h,y);if(typeof h=="object"&&h!==null){switch(h.$$typeof){case pi:return h.key===q?l(d,c,h,y):null;case Ut:return h.key===q?u(d,c,h,y):null;case it:return q=h._init,p(d,c,q(h._payload),y)}if(Mn(h)||_n(h))return q!==null?null:f(d,c,h,y,null);Ci(d,h)}return null}function g(d,c,h,y,q){if(typeof y=="string"&&y!==""||typeof y=="number")return d=d.get(h)||null,r(c,d,""+y,q);if(typeof y=="object"&&y!==null){switch(y.$$typeof){case pi:return d=d.get(y.key===null?h:y.key)||null,l(c,d,y,q);case Ut:return d=d.get(y.key===null?h:y.key)||null,u(c,d,y,q);case it:var I=y._init;return g(d,c,h,I(y._payload),q)}if(Mn(y)||_n(y))return d=d.get(h)||null,f(c,d,y,q,null);Ci(c,y)}return null}function v(d,c,h,y){for(var q=null,I=null,w=c,S=c=0,E=null;w!==null&&S<h.length;S++){w.index>S?(E=w,w=null):E=w.sibling;var A=p(d,w,h[S],y);if(A===null){w===null&&(w=E);break}e&&w&&A.alternate===null&&t(d,w),c=o(A,c,S),I===null?q=A:I.sibling=A,I=A,w=E}if(S===h.length)return n(d,w),G&&St(d,S),q;if(w===null){for(;S<h.length;S++)w=m(d,h[S],y),w!==null&&(c=o(w,c,S),I===null?q=w:I.sibling=w,I=w);return G&&St(d,S),q}for(w=i(d,w);S<h.length;S++)E=g(w,d,S,h[S],y),E!==null&&(e&&E.alternate!==null&&w.delete(E.key===null?S:E.key),c=o(E,c,S),I===null?q=E:I.sibling=E,I=E);return e&&w.forEach(function(se){return t(d,se)}),G&&St(d,S),q}function _(d,c,h,y){var q=_n(h);if(typeof q!="function")throw Error(b(150));if(h=q.call(h),h==null)throw Error(b(151));for(var I=q=null,w=c,S=c=0,E=null,A=h.next();w!==null&&!A.done;S++,A=h.next()){w.index>S?(E=w,w=null):E=w.sibling;var se=p(d,w,A.value,y);if(se===null){w===null&&(w=E);break}e&&w&&se.alternate===null&&t(d,w),c=o(se,c,S),I===null?q=se:I.sibling=se,I=se,w=E}if(A.done)return n(d,w),G&&St(d,S),q;if(w===null){for(;!A.done;S++,A=h.next())A=m(d,A.value,y),A!==null&&(c=o(A,c,S),I===null?q=A:I.sibling=A,I=A);return G&&St(d,S),q}for(w=i(d,w);!A.done;S++,A=h.next())A=g(w,d,S,A.value,y),A!==null&&(e&&A.alternate!==null&&w.delete(A.key===null?S:A.key),c=o(A,c,S),I===null?q=A:I.sibling=A,I=A);return e&&w.forEach(function(Se){return t(d,Se)}),G&&St(d,S),q}function B(d,c,h,y){if(typeof h=="object"&&h!==null&&h.type===Xt&&h.key===null&&(h=h.props.children),typeof h=="object"&&h!==null){switch(h.$$typeof){case pi:e:{for(var q=h.key,I=c;I!==null;){if(I.key===q){if(q=h.type,q===Xt){if(I.tag===7){n(d,I.sibling),c=a(I,h.props.children),c.return=d,d=c;break e}}else if(I.elementType===q||typeof q=="object"&&q!==null&&q.$$typeof===it&&Fr(q)===I.type){n(d,I.sibling),c=a(I,h.props),c.ref=Sn(d,I,h),c.return=d,d=c;break e}n(d,I);break}else t(d,I);I=I.sibling}h.type===Xt?(c=Rt(h.props.children,d.mode,y,h.key),c.return=d,d=c):(y=Gi(h.type,h.key,h.props,null,d.mode,y),y.ref=Sn(d,c,h),y.return=d,d=y)}return s(d);case Ut:e:{for(I=h.key;c!==null;){if(c.key===I)if(c.tag===4&&c.stateNode.containerInfo===h.containerInfo&&c.stateNode.implementation===h.implementation){n(d,c.sibling),c=a(c,h.children||[]),c.return=d,d=c;break e}else{n(d,c);break}else t(d,c);c=c.sibling}c=no(h,d.mode,y),c.return=d,d=c}return s(d);case it:return I=h._init,B(d,c,I(h._payload),y)}if(Mn(h))return v(d,c,h,y);if(_n(h))return _(d,c,h,y);Ci(d,h)}return typeof h=="string"&&h!==""||typeof h=="number"?(h=""+h,c!==null&&c.tag===6?(n(d,c.sibling),c=a(c,h),c.return=d,d=c):(n(d,c),c=to(h,d.mode,y),c.return=d,d=c),s(d)):n(d,c)}return B}var pn=ku(!0),Tu=ku(!1),ea=_t(null),ta=null,Jt=null,ks=null;function Ts(){ks=Jt=ta=null}function Ms(e){var t=ea.current;N(ea),e._currentValue=t}function Eo(e,t,n){for(;e!==null;){var i=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,i!==null&&(i.childLanes|=t)):i!==null&&(i.childLanes&t)!==t&&(i.childLanes|=t),e===n)break;e=e.return}}function rn(e,t){ta=e,ks=Jt=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(he=!0),e.firstContext=null)}function Ae(e){var t=e._currentValue;if(ks!==e)if(e={context:e,memoizedValue:t,next:null},Jt===null){if(ta===null)throw Error(b(308));Jt=e,ta.dependencies={lanes:0,firstContext:e}}else Jt=Jt.next=e;return t}var Mt=null;function As(e){Mt===null?Mt=[e]:Mt.push(e)}function Mu(e,t,n,i){var a=t.interleaved;return a===null?(n.next=n,As(t)):(n.next=a.next,a.next=n),t.interleaved=n,Ke(e,i)}function Ke(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var at=!1;function Ps(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Au(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function He(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function ht(e,t,n){var i=e.updateQueue;if(i===null)return null;if(i=i.shared,O&2){var a=i.pending;return a===null?t.next=t:(t.next=a.next,a.next=t),i.pending=t,Ke(e,n)}return a=i.interleaved,a===null?(t.next=t,As(i)):(t.next=a.next,a.next=t),i.interleaved=t,Ke(e,n)}function Oi(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var i=t.lanes;i&=e.pendingLanes,n|=i,t.lanes=n,gs(e,n)}}function Qr(e,t){var n=e.updateQueue,i=e.alternate;if(i!==null&&(i=i.updateQueue,n===i)){var a=null,o=null;if(n=n.firstBaseUpdate,n!==null){do{var s={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};o===null?a=o=s:o=o.next=s,n=n.next}while(n!==null);o===null?a=o=t:o=o.next=t}else a=o=t;n={baseState:i.baseState,firstBaseUpdate:a,lastBaseUpdate:o,shared:i.shared,effects:i.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function na(e,t,n,i){var a=e.updateQueue;at=!1;var o=a.firstBaseUpdate,s=a.lastBaseUpdate,r=a.shared.pending;if(r!==null){a.shared.pending=null;var l=r,u=l.next;l.next=null,s===null?o=u:s.next=u,s=l;var f=e.alternate;f!==null&&(f=f.updateQueue,r=f.lastBaseUpdate,r!==s&&(r===null?f.firstBaseUpdate=u:r.next=u,f.lastBaseUpdate=l))}if(o!==null){var m=a.baseState;s=0,f=u=l=null,r=o;do{var p=r.lane,g=r.eventTime;if((i&p)===p){f!==null&&(f=f.next={eventTime:g,lane:0,tag:r.tag,payload:r.payload,callback:r.callback,next:null});e:{var v=e,_=r;switch(p=t,g=n,_.tag){case 1:if(v=_.payload,typeof v=="function"){m=v.call(g,m,p);break e}m=v;break e;case 3:v.flags=v.flags&-65537|128;case 0:if(v=_.payload,p=typeof v=="function"?v.call(g,m,p):v,p==null)break e;m=W({},m,p);break e;case 2:at=!0}}r.callback!==null&&r.lane!==0&&(e.flags|=64,p=a.effects,p===null?a.effects=[r]:p.push(r))}else g={eventTime:g,lane:p,tag:r.tag,payload:r.payload,callback:r.callback,next:null},f===null?(u=f=g,l=m):f=f.next=g,s|=p;if(r=r.next,r===null){if(r=a.shared.pending,r===null)break;p=r,r=p.next,p.next=null,a.lastBaseUpdate=p,a.shared.pending=null}}while(!0);if(f===null&&(l=m),a.baseState=l,a.firstBaseUpdate=u,a.lastBaseUpdate=f,t=a.shared.interleaved,t!==null){a=t;do s|=a.lane,a=a.next;while(a!==t)}else o===null&&(a.shared.lanes=0);Ft|=s,e.lanes=s,e.memoizedState=m}}function Lr(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var i=e[t],a=i.callback;if(a!==null){if(i.callback=null,i=n,typeof a!="function")throw Error(b(191,a));a.call(i)}}}var li={},Ue=_t(li),Kn=_t(li),Jn=_t(li);function At(e){if(e===li)throw Error(b(174));return e}function Rs(e,t){switch(Q(Jn,t),Q(Kn,e),Q(Ue,li),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:fo(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=fo(t,e)}N(Ue),Q(Ue,t)}function hn(){N(Ue),N(Kn),N(Jn)}function Pu(e){At(Jn.current);var t=At(Ue.current),n=fo(t,e.type);t!==n&&(Q(Kn,e),Q(Ue,n))}function Bs(e){Kn.current===e&&(N(Ue),N(Kn))}var D=_t(0);function ia(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Ha=[];function Os(){for(var e=0;e<Ha.length;e++)Ha[e]._workInProgressVersionPrimary=null;Ha.length=0}var Ei=tt.ReactCurrentDispatcher,$a=tt.ReactCurrentBatchConfig,Et=0,z=null,Z=null,Y=null,aa=!1,Qn=!1,ei=0,Ap=0;function ne(){throw Error(b(321))}function Es(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Le(e[n],t[n]))return!1;return!0}function Fs(e,t,n,i,a,o){if(Et=o,z=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Ei.current=e===null||e.memoizedState===null?Op:Ep,e=n(i,a),Qn){o=0;do{if(Qn=!1,ei=0,25<=o)throw Error(b(301));o+=1,Y=Z=null,t.updateQueue=null,Ei.current=Fp,e=n(i,a)}while(Qn)}if(Ei.current=oa,t=Z!==null&&Z.next!==null,Et=0,Y=Z=z=null,aa=!1,t)throw Error(b(300));return e}function Qs(){var e=ei!==0;return ei=0,e}function Ge(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Y===null?z.memoizedState=Y=e:Y=Y.next=e,Y}function Pe(){if(Z===null){var e=z.alternate;e=e!==null?e.memoizedState:null}else e=Z.next;var t=Y===null?z.memoizedState:Y.next;if(t!==null)Y=t,Z=e;else{if(e===null)throw Error(b(310));Z=e,e={memoizedState:Z.memoizedState,baseState:Z.baseState,baseQueue:Z.baseQueue,queue:Z.queue,next:null},Y===null?z.memoizedState=Y=e:Y=Y.next=e}return Y}function ti(e,t){return typeof t=="function"?t(e):t}function Ya(e){var t=Pe(),n=t.queue;if(n===null)throw Error(b(311));n.lastRenderedReducer=e;var i=Z,a=i.baseQueue,o=n.pending;if(o!==null){if(a!==null){var s=a.next;a.next=o.next,o.next=s}i.baseQueue=a=o,n.pending=null}if(a!==null){o=a.next,i=i.baseState;var r=s=null,l=null,u=o;do{var f=u.lane;if((Et&f)===f)l!==null&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),i=u.hasEagerState?u.eagerState:e(i,u.action);else{var m={lane:f,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};l===null?(r=l=m,s=i):l=l.next=m,z.lanes|=f,Ft|=f}u=u.next}while(u!==null&&u!==o);l===null?s=i:l.next=r,Le(i,t.memoizedState)||(he=!0),t.memoizedState=i,t.baseState=s,t.baseQueue=l,n.lastRenderedState=i}if(e=n.interleaved,e!==null){a=e;do o=a.lane,z.lanes|=o,Ft|=o,a=a.next;while(a!==e)}else a===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function Ka(e){var t=Pe(),n=t.queue;if(n===null)throw Error(b(311));n.lastRenderedReducer=e;var i=n.dispatch,a=n.pending,o=t.memoizedState;if(a!==null){n.pending=null;var s=a=a.next;do o=e(o,s.action),s=s.next;while(s!==a);Le(o,t.memoizedState)||(he=!0),t.memoizedState=o,t.baseQueue===null&&(t.baseState=o),n.lastRenderedState=o}return[o,i]}function Ru(){}function Bu(e,t){var n=z,i=Pe(),a=t(),o=!Le(i.memoizedState,a);if(o&&(i.memoizedState=a,he=!0),i=i.queue,Ls(Fu.bind(null,n,i,e),[e]),i.getSnapshot!==t||o||Y!==null&&Y.memoizedState.tag&1){if(n.flags|=2048,ni(9,Eu.bind(null,n,i,a,t),void 0,null),K===null)throw Error(b(349));Et&30||Ou(n,t,a)}return a}function Ou(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=z.updateQueue,t===null?(t={lastEffect:null,stores:null},z.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function Eu(e,t,n,i){t.value=n,t.getSnapshot=i,Qu(t)&&Lu(e)}function Fu(e,t,n){return n(function(){Qu(t)&&Lu(e)})}function Qu(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Le(e,n)}catch{return!0}}function Lu(e){var t=Ke(e,1);t!==null&&Qe(t,e,1,-1)}function Nr(e){var t=Ge();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ti,lastRenderedState:e},t.queue=e,e=e.dispatch=Bp.bind(null,z,e),[t.memoizedState,e]}function ni(e,t,n,i){return e={tag:e,create:t,destroy:n,deps:i,next:null},t=z.updateQueue,t===null?(t={lastEffect:null,stores:null},z.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(i=n.next,n.next=e,e.next=i,t.lastEffect=e)),e}function Nu(){return Pe().memoizedState}function Fi(e,t,n,i){var a=Ge();z.flags|=e,a.memoizedState=ni(1|t,n,void 0,i===void 0?null:i)}function _a(e,t,n,i){var a=Pe();i=i===void 0?null:i;var o=void 0;if(Z!==null){var s=Z.memoizedState;if(o=s.destroy,i!==null&&Es(i,s.deps)){a.memoizedState=ni(t,n,o,i);return}}z.flags|=e,a.memoizedState=ni(1|t,n,o,i)}function Gr(e,t){return Fi(8390656,8,e,t)}function Ls(e,t){return _a(2048,8,e,t)}function Gu(e,t){return _a(4,2,e,t)}function Du(e,t){return _a(4,4,e,t)}function zu(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function Wu(e,t,n){return n=n!=null?n.concat([e]):null,_a(4,4,zu.bind(null,t,e),n)}function Ns(){}function Uu(e,t){var n=Pe();t=t===void 0?null:t;var i=n.memoizedState;return i!==null&&t!==null&&Es(t,i[1])?i[0]:(n.memoizedState=[e,t],e)}function Xu(e,t){var n=Pe();t=t===void 0?null:t;var i=n.memoizedState;return i!==null&&t!==null&&Es(t,i[1])?i[0]:(e=e(),n.memoizedState=[e,t],e)}function Vu(e,t,n){return Et&21?(Le(n,t)||(n=Yl(),z.lanes|=n,Ft|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,he=!0),e.memoizedState=n)}function Pp(e,t){var n=F;F=n!==0&&4>n?n:4,e(!0);var i=$a.transition;$a.transition={};try{e(!1),t()}finally{F=n,$a.transition=i}}function ju(){return Pe().memoizedState}function Rp(e,t,n){var i=ft(e);if(n={lane:i,action:n,hasEagerState:!1,eagerState:null,next:null},Zu(e))Hu(t,n);else if(n=Mu(e,t,n,i),n!==null){var a=le();Qe(n,e,i,a),$u(n,t,i)}}function Bp(e,t,n){var i=ft(e),a={lane:i,action:n,hasEagerState:!1,eagerState:null,next:null};if(Zu(e))Hu(t,a);else{var o=e.alternate;if(e.lanes===0&&(o===null||o.lanes===0)&&(o=t.lastRenderedReducer,o!==null))try{var s=t.lastRenderedState,r=o(s,n);if(a.hasEagerState=!0,a.eagerState=r,Le(r,s)){var l=t.interleaved;l===null?(a.next=a,As(t)):(a.next=l.next,l.next=a),t.interleaved=a;return}}catch{}finally{}n=Mu(e,t,a,i),n!==null&&(a=le(),Qe(n,e,i,a),$u(n,t,i))}}function Zu(e){var t=e.alternate;return e===z||t!==null&&t===z}function Hu(e,t){Qn=aa=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function $u(e,t,n){if(n&4194240){var i=t.lanes;i&=e.pendingLanes,n|=i,t.lanes=n,gs(e,n)}}var oa={readContext:Ae,useCallback:ne,useContext:ne,useEffect:ne,useImperativeHandle:ne,useInsertionEffect:ne,useLayoutEffect:ne,useMemo:ne,useReducer:ne,useRef:ne,useState:ne,useDebugValue:ne,useDeferredValue:ne,useTransition:ne,useMutableSource:ne,useSyncExternalStore:ne,useId:ne,unstable_isNewReconciler:!1},Op={readContext:Ae,useCallback:function(e,t){return Ge().memoizedState=[e,t===void 0?null:t],e},useContext:Ae,useEffect:Gr,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,Fi(4194308,4,zu.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Fi(4194308,4,e,t)},useInsertionEffect:function(e,t){return Fi(4,2,e,t)},useMemo:function(e,t){var n=Ge();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var i=Ge();return t=n!==void 0?n(t):t,i.memoizedState=i.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},i.queue=e,e=e.dispatch=Rp.bind(null,z,e),[i.memoizedState,e]},useRef:function(e){var t=Ge();return e={current:e},t.memoizedState=e},useState:Nr,useDebugValue:Ns,useDeferredValue:function(e){return Ge().memoizedState=e},useTransition:function(){var e=Nr(!1),t=e[0];return e=Pp.bind(null,e[1]),Ge().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var i=z,a=Ge();if(G){if(n===void 0)throw Error(b(407));n=n()}else{if(n=t(),K===null)throw Error(b(349));Et&30||Ou(i,t,n)}a.memoizedState=n;var o={value:n,getSnapshot:t};return a.queue=o,Gr(Fu.bind(null,i,o,e),[e]),i.flags|=2048,ni(9,Eu.bind(null,i,o,n,t),void 0,null),n},useId:function(){var e=Ge(),t=K.identifierPrefix;if(G){var n=Ze,i=je;n=(i&~(1<<32-Fe(i)-1)).toString(32)+n,t=":"+t+"R"+n,n=ei++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=Ap++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Ep={readContext:Ae,useCallback:Uu,useContext:Ae,useEffect:Ls,useImperativeHandle:Wu,useInsertionEffect:Gu,useLayoutEffect:Du,useMemo:Xu,useReducer:Ya,useRef:Nu,useState:function(){return Ya(ti)},useDebugValue:Ns,useDeferredValue:function(e){var t=Pe();return Vu(t,Z.memoizedState,e)},useTransition:function(){var e=Ya(ti)[0],t=Pe().memoizedState;return[e,t]},useMutableSource:Ru,useSyncExternalStore:Bu,useId:ju,unstable_isNewReconciler:!1},Fp={readContext:Ae,useCallback:Uu,useContext:Ae,useEffect:Ls,useImperativeHandle:Wu,useInsertionEffect:Gu,useLayoutEffect:Du,useMemo:Xu,useReducer:Ka,useRef:Nu,useState:function(){return Ka(ti)},useDebugValue:Ns,useDeferredValue:function(e){var t=Pe();return Z===null?t.memoizedState=e:Vu(t,Z.memoizedState,e)},useTransition:function(){var e=Ka(ti)[0],t=Pe().memoizedState;return[e,t]},useMutableSource:Ru,useSyncExternalStore:Bu,useId:ju,unstable_isNewReconciler:!1};function Be(e,t){if(e&&e.defaultProps){t=W({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}function Fo(e,t,n,i){t=e.memoizedState,n=n(i,t),n=n==null?t:W({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var wa={isMounted:function(e){return(e=e._reactInternals)?Nt(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var i=le(),a=ft(e),o=He(i,a);o.payload=t,n!=null&&(o.callback=n),t=ht(e,o,a),t!==null&&(Qe(t,e,a,i),Oi(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var i=le(),a=ft(e),o=He(i,a);o.tag=1,o.payload=t,n!=null&&(o.callback=n),t=ht(e,o,a),t!==null&&(Qe(t,e,a,i),Oi(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=le(),i=ft(e),a=He(n,i);a.tag=2,t!=null&&(a.callback=t),t=ht(e,a,i),t!==null&&(Qe(t,e,i,n),Oi(t,e,i))}};function Dr(e,t,n,i,a,o,s){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(i,o,s):t.prototype&&t.prototype.isPureReactComponent?!Zn(n,i)||!Zn(a,o):!0}function Yu(e,t,n){var i=!1,a=vt,o=t.contextType;return typeof o=="object"&&o!==null?o=Ae(o):(a=fe(t)?Bt:oe.current,i=t.contextTypes,o=(i=i!=null)?cn(e,a):vt),t=new t(n,o),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=wa,e.stateNode=t,t._reactInternals=e,i&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=o),t}function zr(e,t,n,i){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,i),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,i),t.state!==e&&wa.enqueueReplaceState(t,t.state,null)}function Qo(e,t,n,i){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},Ps(e);var o=t.contextType;typeof o=="object"&&o!==null?a.context=Ae(o):(o=fe(t)?Bt:oe.current,a.context=cn(e,o)),a.state=e.memoizedState,o=t.getDerivedStateFromProps,typeof o=="function"&&(Fo(e,t,o,n),a.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof a.getSnapshotBeforeUpdate=="function"||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(t=a.state,typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount(),t!==a.state&&wa.enqueueReplaceState(a,a.state,null),na(e,n,a,i),a.state=e.memoizedState),typeof a.componentDidMount=="function"&&(e.flags|=4194308)}function mn(e,t){try{var n="",i=t;do n+=cd(i),i=i.return;while(i);var a=n}catch(o){a=`
Error generating stack: `+o.message+`
`+o.stack}return{value:e,source:t,stack:a,digest:null}}function Ja(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function Lo(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var Qp=typeof WeakMap=="function"?WeakMap:Map;function Ku(e,t,n){n=He(-1,n),n.tag=3,n.payload={element:null};var i=t.value;return n.callback=function(){ra||(ra=!0,Zo=i),Lo(e,t)},n}function Ju(e,t,n){n=He(-1,n),n.tag=3;var i=e.type.getDerivedStateFromError;if(typeof i=="function"){var a=t.value;n.payload=function(){return i(a)},n.callback=function(){Lo(e,t)}}var o=e.stateNode;return o!==null&&typeof o.componentDidCatch=="function"&&(n.callback=function(){Lo(e,t),typeof i!="function"&&(mt===null?mt=new Set([this]):mt.add(this));var s=t.stack;this.componentDidCatch(t.value,{componentStack:s!==null?s:""})}),n}function Wr(e,t,n){var i=e.pingCache;if(i===null){i=e.pingCache=new Qp;var a=new Set;i.set(t,a)}else a=i.get(t),a===void 0&&(a=new Set,i.set(t,a));a.has(n)||(a.add(n),e=Yp.bind(null,e,t,n),t.then(e,e))}function Ur(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function Xr(e,t,n,i,a){return e.mode&1?(e.flags|=65536,e.lanes=a,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=He(-1,1),t.tag=2,ht(n,t,1))),n.lanes|=1),e)}var Lp=tt.ReactCurrentOwner,he=!1;function re(e,t,n,i){t.child=e===null?Tu(t,null,n,i):pn(t,e.child,n,i)}function Vr(e,t,n,i,a){n=n.render;var o=t.ref;return rn(t,a),i=Fs(e,t,n,i,o,a),n=Qs(),e!==null&&!he?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Je(e,t,a)):(G&&n&&xs(t),t.flags|=1,re(e,t,i,a),t.child)}function jr(e,t,n,i,a){if(e===null){var o=n.type;return typeof o=="function"&&!js(o)&&o.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=o,ec(e,t,o,i,a)):(e=Gi(n.type,null,i,t,t.mode,a),e.ref=t.ref,e.return=t,t.child=e)}if(o=e.child,!(e.lanes&a)){var s=o.memoizedProps;if(n=n.compare,n=n!==null?n:Zn,n(s,i)&&e.ref===t.ref)return Je(e,t,a)}return t.flags|=1,e=gt(o,i),e.ref=t.ref,e.return=t,t.child=e}function ec(e,t,n,i,a){if(e!==null){var o=e.memoizedProps;if(Zn(o,i)&&e.ref===t.ref)if(he=!1,t.pendingProps=i=o,(e.lanes&a)!==0)e.flags&131072&&(he=!0);else return t.lanes=e.lanes,Je(e,t,a)}return No(e,t,n,i,a)}function tc(e,t,n){var i=t.pendingProps,a=i.children,o=e!==null?e.memoizedState:null;if(i.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Q(tn,ye),ye|=n;else{if(!(n&1073741824))return e=o!==null?o.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Q(tn,ye),ye|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},i=o!==null?o.baseLanes:n,Q(tn,ye),ye|=i}else o!==null?(i=o.baseLanes|n,t.memoizedState=null):i=n,Q(tn,ye),ye|=i;return re(e,t,a,n),t.child}function nc(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,i,a){var o=fe(n)?Bt:oe.current;return o=cn(t,o),rn(t,a),n=Fs(e,t,n,i,o,a),i=Qs(),e!==null&&!he?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Je(e,t,a)):(G&&i&&xs(t),t.flags|=1,re(e,t,n,a),t.child)}function Zr(e,t,n,i,a){if(fe(n)){var o=!0;Yi(t)}else o=!1;if(rn(t,a),t.stateNode===null)Qi(e,t),Yu(t,n,i),Qo(t,n,i,a),i=!0;else if(e===null){var s=t.stateNode,r=t.memoizedProps;s.props=r;var l=s.context,u=n.contextType;typeof u=="object"&&u!==null?u=Ae(u):(u=fe(n)?Bt:oe.current,u=cn(t,u));var f=n.getDerivedStateFromProps,m=typeof f=="function"||typeof s.getSnapshotBeforeUpdate=="function";m||typeof s.UNSAFE_componentWillReceiveProps!="function"&&typeof s.componentWillReceiveProps!="function"||(r!==i||l!==u)&&zr(t,s,i,u),at=!1;var p=t.memoizedState;s.state=p,na(t,i,s,a),l=t.memoizedState,r!==i||p!==l||me.current||at?(typeof f=="function"&&(Fo(t,n,f,i),l=t.memoizedState),(r=at||Dr(t,n,r,i,p,l,u))?(m||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount()),typeof s.componentDidMount=="function"&&(t.flags|=4194308)):(typeof s.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=i,t.memoizedState=l),s.props=i,s.state=l,s.context=u,i=r):(typeof s.componentDidMount=="function"&&(t.flags|=4194308),i=!1)}else{s=t.stateNode,Au(e,t),r=t.memoizedProps,u=t.type===t.elementType?r:Be(t.type,r),s.props=u,m=t.pendingProps,p=s.context,l=n.contextType,typeof l=="object"&&l!==null?l=Ae(l):(l=fe(n)?Bt:oe.current,l=cn(t,l));var g=n.getDerivedStateFromProps;(f=typeof g=="function"||typeof s.getSnapshotBeforeUpdate=="function")||typeof s.UNSAFE_componentWillReceiveProps!="function"&&typeof s.componentWillReceiveProps!="function"||(r!==m||p!==l)&&zr(t,s,i,l),at=!1,p=t.memoizedState,s.state=p,na(t,i,s,a);var v=t.memoizedState;r!==m||p!==v||me.current||at?(typeof g=="function"&&(Fo(t,n,g,i),v=t.memoizedState),(u=at||Dr(t,n,u,i,p,v,l)||!1)?(f||typeof s.UNSAFE_componentWillUpdate!="function"&&typeof s.componentWillUpdate!="function"||(typeof s.componentWillUpdate=="function"&&s.componentWillUpdate(i,v,l),typeof s.UNSAFE_componentWillUpdate=="function"&&s.UNSAFE_componentWillUpdate(i,v,l)),typeof s.componentDidUpdate=="function"&&(t.flags|=4),typeof s.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof s.componentDidUpdate!="function"||r===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),typeof s.getSnapshotBeforeUpdate!="function"||r===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),t.memoizedProps=i,t.memoizedState=v),s.props=i,s.state=v,s.context=l,i=u):(typeof s.componentDidUpdate!="function"||r===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),typeof s.getSnapshotBeforeUpdate!="function"||r===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),i=!1)}return Go(e,t,n,i,o,a)}function Go(e,t,n,i,a,o){nc(e,t);var s=(t.flags&128)!==0;if(!i&&!s)return a&&Br(t,n,!1),Je(e,t,o);i=t.stateNode,Lp.current=t;var r=s&&typeof n.getDerivedStateFromError!="function"?null:i.render();return t.flags|=1,e!==null&&s?(t.child=pn(t,e.child,null,o),t.child=pn(t,null,r,o)):re(e,t,r,o),t.memoizedState=i.state,a&&Br(t,n,!0),t.child}function ic(e){var t=e.stateNode;t.pendingContext?Rr(e,t.pendingContext,t.pendingContext!==t.context):t.context&&Rr(e,t.context,!1),Rs(e,t.containerInfo)}function Hr(e,t,n,i,a){return dn(),Is(a),t.flags|=256,re(e,t,n,i),t.child}var Do={dehydrated:null,treeContext:null,retryLane:0};function zo(e){return{baseLanes:e,cachePool:null,transitions:null}}function ac(e,t,n){var i=t.pendingProps,a=D.current,o=!1,s=(t.flags&128)!==0,r;if((r=s)||(r=e!==null&&e.memoizedState===null?!1:(a&2)!==0),r?(o=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(a|=1),Q(D,a&1),e===null)return Oo(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(s=i.children,e=i.fallback,o?(i=t.mode,o=t.child,s={mode:"hidden",children:s},!(i&1)&&o!==null?(o.childLanes=0,o.pendingProps=s):o=xa(s,i,0,null),e=Rt(e,i,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=zo(n),t.memoizedState=Do,e):Gs(t,s));if(a=e.memoizedState,a!==null&&(r=a.dehydrated,r!==null))return Np(e,t,s,i,r,a,n);if(o){o=i.fallback,s=t.mode,a=e.child,r=a.sibling;var l={mode:"hidden",children:i.children};return!(s&1)&&t.child!==a?(i=t.child,i.childLanes=0,i.pendingProps=l,t.deletions=null):(i=gt(a,l),i.subtreeFlags=a.subtreeFlags&14680064),r!==null?o=gt(r,o):(o=Rt(o,s,n,null),o.flags|=2),o.return=t,i.return=t,i.sibling=o,t.child=i,i=o,o=t.child,s=e.child.memoizedState,s=s===null?zo(n):{baseLanes:s.baseLanes|n,cachePool:null,transitions:s.transitions},o.memoizedState=s,o.childLanes=e.childLanes&~n,t.memoizedState=Do,i}return o=e.child,e=o.sibling,i=gt(o,{mode:"visible",children:i.children}),!(t.mode&1)&&(i.lanes=n),i.return=t,i.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=i,t.memoizedState=null,i}function Gs(e,t){return t=xa({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function xi(e,t,n,i){return i!==null&&Is(i),pn(t,e.child,null,n),e=Gs(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function Np(e,t,n,i,a,o,s){if(n)return t.flags&256?(t.flags&=-257,i=Ja(Error(b(422))),xi(e,t,s,i)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(o=i.fallback,a=t.mode,i=xa({mode:"visible",children:i.children},a,0,null),o=Rt(o,a,s,null),o.flags|=2,i.return=t,o.return=t,i.sibling=o,t.child=i,t.mode&1&&pn(t,e.child,null,s),t.child.memoizedState=zo(s),t.memoizedState=Do,o);if(!(t.mode&1))return xi(e,t,s,null);if(a.data==="$!"){if(i=a.nextSibling&&a.nextSibling.dataset,i)var r=i.dgst;return i=r,o=Error(b(419)),i=Ja(o,i,void 0),xi(e,t,s,i)}if(r=(s&e.childLanes)!==0,he||r){if(i=K,i!==null){switch(s&-s){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}a=a&(i.suspendedLanes|s)?0:a,a!==0&&a!==o.retryLane&&(o.retryLane=a,Ke(e,a),Qe(i,e,a,-1))}return Vs(),i=Ja(Error(b(421))),xi(e,t,s,i)}return a.data==="$?"?(t.flags|=128,t.child=e.child,t=Kp.bind(null,e),a._reactRetry=t,null):(e=o.treeContext,_e=pt(a.nextSibling),we=t,G=!0,Ee=null,e!==null&&(Ie[ke++]=je,Ie[ke++]=Ze,Ie[ke++]=Ot,je=e.id,Ze=e.overflow,Ot=t),t=Gs(t,i.children),t.flags|=4096,t)}function $r(e,t,n){e.lanes|=t;var i=e.alternate;i!==null&&(i.lanes|=t),Eo(e.return,t,n)}function eo(e,t,n,i,a){var o=e.memoizedState;o===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:i,tail:n,tailMode:a}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=i,o.tail=n,o.tailMode=a)}function oc(e,t,n){var i=t.pendingProps,a=i.revealOrder,o=i.tail;if(re(e,t,i.children,n),i=D.current,i&2)i=i&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&$r(e,n,t);else if(e.tag===19)$r(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}i&=1}if(Q(D,i),!(t.mode&1))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;n!==null;)e=n.alternate,e!==null&&ia(e)===null&&(a=n),n=n.sibling;n=a,n===null?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),eo(t,!1,a,n,o);break;case"backwards":for(n=null,a=t.child,t.child=null;a!==null;){if(e=a.alternate,e!==null&&ia(e)===null){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}eo(t,!0,n,null,o);break;case"together":eo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Qi(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Je(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),Ft|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(b(153));if(t.child!==null){for(e=t.child,n=gt(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=gt(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function Gp(e,t,n){switch(t.tag){case 3:ic(t),dn();break;case 5:Pu(t);break;case 1:fe(t.type)&&Yi(t);break;case 4:Rs(t,t.stateNode.containerInfo);break;case 10:var i=t.type._context,a=t.memoizedProps.value;Q(ea,i._currentValue),i._currentValue=a;break;case 13:if(i=t.memoizedState,i!==null)return i.dehydrated!==null?(Q(D,D.current&1),t.flags|=128,null):n&t.child.childLanes?ac(e,t,n):(Q(D,D.current&1),e=Je(e,t,n),e!==null?e.sibling:null);Q(D,D.current&1);break;case 19:if(i=(n&t.childLanes)!==0,e.flags&128){if(i)return oc(e,t,n);t.flags|=128}if(a=t.memoizedState,a!==null&&(a.rendering=null,a.tail=null,a.lastEffect=null),Q(D,D.current),i)break;return null;case 22:case 23:return t.lanes=0,tc(e,t,n)}return Je(e,t,n)}var sc,Wo,rc,lc;sc=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};Wo=function(){};rc=function(e,t,n,i){var a=e.memoizedProps;if(a!==i){e=t.stateNode,At(Ue.current);var o=null;switch(n){case"input":a=co(e,a),i=co(e,i),o=[];break;case"select":a=W({},a,{value:void 0}),i=W({},i,{value:void 0}),o=[];break;case"textarea":a=mo(e,a),i=mo(e,i),o=[];break;default:typeof a.onClick!="function"&&typeof i.onClick=="function"&&(e.onclick=Hi)}go(n,i);var s;n=null;for(u in a)if(!i.hasOwnProperty(u)&&a.hasOwnProperty(u)&&a[u]!=null)if(u==="style"){var r=a[u];for(s in r)r.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(Dn.hasOwnProperty(u)?o||(o=[]):(o=o||[]).push(u,null));for(u in i){var l=i[u];if(r=a!=null?a[u]:void 0,i.hasOwnProperty(u)&&l!==r&&(l!=null||r!=null))if(u==="style")if(r){for(s in r)!r.hasOwnProperty(s)||l&&l.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in l)l.hasOwnProperty(s)&&r[s]!==l[s]&&(n||(n={}),n[s]=l[s])}else n||(o||(o=[]),o.push(u,n)),n=l;else u==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,r=r?r.__html:void 0,l!=null&&r!==l&&(o=o||[]).push(u,l)):u==="children"?typeof l!="string"&&typeof l!="number"||(o=o||[]).push(u,""+l):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(Dn.hasOwnProperty(u)?(l!=null&&u==="onScroll"&&L("scroll",e),o||r===l||(o=[])):(o=o||[]).push(u,l))}n&&(o=o||[]).push("style",n);var u=o;(t.updateQueue=u)&&(t.flags|=4)}};lc=function(e,t,n,i){n!==i&&(t.flags|=4)};function In(e,t){if(!G)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var i=null;n!==null;)n.alternate!==null&&(i=n),n=n.sibling;i===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:i.sibling=null}}function ie(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,i=0;if(t)for(var a=e.child;a!==null;)n|=a.lanes|a.childLanes,i|=a.subtreeFlags&14680064,i|=a.flags&14680064,a.return=e,a=a.sibling;else for(a=e.child;a!==null;)n|=a.lanes|a.childLanes,i|=a.subtreeFlags,i|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=i,e.childLanes=n,t}function Dp(e,t,n){var i=t.pendingProps;switch(Ss(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ie(t),null;case 1:return fe(t.type)&&$i(),ie(t),null;case 3:return i=t.stateNode,hn(),N(me),N(oe),Os(),i.pendingContext&&(i.context=i.pendingContext,i.pendingContext=null),(e===null||e.child===null)&&(qi(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Ee!==null&&(Yo(Ee),Ee=null))),Wo(e,t),ie(t),null;case 5:Bs(t);var a=At(Jn.current);if(n=t.type,e!==null&&t.stateNode!=null)rc(e,t,n,i,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!i){if(t.stateNode===null)throw Error(b(166));return ie(t),null}if(e=At(Ue.current),qi(t)){i=t.stateNode,n=t.type;var o=t.memoizedProps;switch(i[De]=t,i[Yn]=o,e=(t.mode&1)!==0,n){case"dialog":L("cancel",i),L("close",i);break;case"iframe":case"object":case"embed":L("load",i);break;case"video":case"audio":for(a=0;a<Pn.length;a++)L(Pn[a],i);break;case"source":L("error",i);break;case"img":case"image":case"link":L("error",i),L("load",i);break;case"details":L("toggle",i);break;case"input":or(i,o),L("invalid",i);break;case"select":i._wrapperState={wasMultiple:!!o.multiple},L("invalid",i);break;case"textarea":rr(i,o),L("invalid",i)}go(n,o),a=null;for(var s in o)if(o.hasOwnProperty(s)){var r=o[s];s==="children"?typeof r=="string"?i.textContent!==r&&(o.suppressHydrationWarning!==!0&&wi(i.textContent,r,e),a=["children",r]):typeof r=="number"&&i.textContent!==""+r&&(o.suppressHydrationWarning!==!0&&wi(i.textContent,r,e),a=["children",""+r]):Dn.hasOwnProperty(s)&&r!=null&&s==="onScroll"&&L("scroll",i)}switch(n){case"input":hi(i),sr(i,o,!0);break;case"textarea":hi(i),lr(i);break;case"select":case"option":break;default:typeof o.onClick=="function"&&(i.onclick=Hi)}i=a,t.updateQueue=i,i!==null&&(t.flags|=4)}else{s=a.nodeType===9?a:a.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=Fl(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=s.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof i.is=="string"?e=s.createElement(n,{is:i.is}):(e=s.createElement(n),n==="select"&&(s=e,i.multiple?s.multiple=!0:i.size&&(s.size=i.size))):e=s.createElementNS(e,n),e[De]=t,e[Yn]=i,sc(e,t,!1,!1),t.stateNode=e;e:{switch(s=yo(n,i),n){case"dialog":L("cancel",e),L("close",e),a=i;break;case"iframe":case"object":case"embed":L("load",e),a=i;break;case"video":case"audio":for(a=0;a<Pn.length;a++)L(Pn[a],e);a=i;break;case"source":L("error",e),a=i;break;case"img":case"image":case"link":L("error",e),L("load",e),a=i;break;case"details":L("toggle",e),a=i;break;case"input":or(e,i),a=co(e,i),L("invalid",e);break;case"option":a=i;break;case"select":e._wrapperState={wasMultiple:!!i.multiple},a=W({},i,{value:void 0}),L("invalid",e);break;case"textarea":rr(e,i),a=mo(e,i),L("invalid",e);break;default:a=i}go(n,a),r=a;for(o in r)if(r.hasOwnProperty(o)){var l=r[o];o==="style"?Nl(e,l):o==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&Ql(e,l)):o==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&zn(e,l):typeof l=="number"&&zn(e,""+l):o!=="suppressContentEditableWarning"&&o!=="suppressHydrationWarning"&&o!=="autoFocus"&&(Dn.hasOwnProperty(o)?l!=null&&o==="onScroll"&&L("scroll",e):l!=null&&cs(e,o,l,s))}switch(n){case"input":hi(e),sr(e,i,!1);break;case"textarea":hi(e),lr(e);break;case"option":i.value!=null&&e.setAttribute("value",""+yt(i.value));break;case"select":e.multiple=!!i.multiple,o=i.value,o!=null?nn(e,!!i.multiple,o,!1):i.defaultValue!=null&&nn(e,!!i.multiple,i.defaultValue,!0);break;default:typeof a.onClick=="function"&&(e.onclick=Hi)}switch(n){case"button":case"input":case"select":case"textarea":i=!!i.autoFocus;break e;case"img":i=!0;break e;default:i=!1}}i&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return ie(t),null;case 6:if(e&&t.stateNode!=null)lc(e,t,e.memoizedProps,i);else{if(typeof i!="string"&&t.stateNode===null)throw Error(b(166));if(n=At(Jn.current),At(Ue.current),qi(t)){if(i=t.stateNode,n=t.memoizedProps,i[De]=t,(o=i.nodeValue!==n)&&(e=we,e!==null))switch(e.tag){case 3:wi(i.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&wi(i.nodeValue,n,(e.mode&1)!==0)}o&&(t.flags|=4)}else i=(n.nodeType===9?n:n.ownerDocument).createTextNode(i),i[De]=t,t.stateNode=i}return ie(t),null;case 13:if(N(D),i=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(G&&_e!==null&&t.mode&1&&!(t.flags&128))Iu(),dn(),t.flags|=98560,o=!1;else if(o=qi(t),i!==null&&i.dehydrated!==null){if(e===null){if(!o)throw Error(b(318));if(o=t.memoizedState,o=o!==null?o.dehydrated:null,!o)throw Error(b(317));o[De]=t}else dn(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;ie(t),o=!1}else Ee!==null&&(Yo(Ee),Ee=null),o=!0;if(!o)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(i=i!==null,i!==(e!==null&&e.memoizedState!==null)&&i&&(t.child.flags|=8192,t.mode&1&&(e===null||D.current&1?H===0&&(H=3):Vs())),t.updateQueue!==null&&(t.flags|=4),ie(t),null);case 4:return hn(),Wo(e,t),e===null&&Hn(t.stateNode.containerInfo),ie(t),null;case 10:return Ms(t.type._context),ie(t),null;case 17:return fe(t.type)&&$i(),ie(t),null;case 19:if(N(D),o=t.memoizedState,o===null)return ie(t),null;if(i=(t.flags&128)!==0,s=o.rendering,s===null)if(i)In(o,!1);else{if(H!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(s=ia(e),s!==null){for(t.flags|=128,In(o,!1),i=s.updateQueue,i!==null&&(t.updateQueue=i,t.flags|=4),t.subtreeFlags=0,i=n,n=t.child;n!==null;)o=n,e=i,o.flags&=14680066,s=o.alternate,s===null?(o.childLanes=0,o.lanes=e,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=s.childLanes,o.lanes=s.lanes,o.child=s.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=s.memoizedProps,o.memoizedState=s.memoizedState,o.updateQueue=s.updateQueue,o.type=s.type,e=s.dependencies,o.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Q(D,D.current&1|2),t.child}e=e.sibling}o.tail!==null&&V()>fn&&(t.flags|=128,i=!0,In(o,!1),t.lanes=4194304)}else{if(!i)if(e=ia(s),e!==null){if(t.flags|=128,i=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),In(o,!0),o.tail===null&&o.tailMode==="hidden"&&!s.alternate&&!G)return ie(t),null}else 2*V()-o.renderingStartTime>fn&&n!==1073741824&&(t.flags|=128,i=!0,In(o,!1),t.lanes=4194304);o.isBackwards?(s.sibling=t.child,t.child=s):(n=o.last,n!==null?n.sibling=s:t.child=s,o.last=s)}return o.tail!==null?(t=o.tail,o.rendering=t,o.tail=t.sibling,o.renderingStartTime=V(),t.sibling=null,n=D.current,Q(D,i?n&1|2:n&1),t):(ie(t),null);case 22:case 23:return Xs(),i=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==i&&(t.flags|=8192),i&&t.mode&1?ye&1073741824&&(ie(t),t.subtreeFlags&6&&(t.flags|=8192)):ie(t),null;case 24:return null;case 25:return null}throw Error(b(156,t.tag))}function zp(e,t){switch(Ss(t),t.tag){case 1:return fe(t.type)&&$i(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return hn(),N(me),N(oe),Os(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return Bs(t),null;case 13:if(N(D),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(b(340));dn()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return N(D),null;case 4:return hn(),null;case 10:return Ms(t.type._context),null;case 22:case 23:return Xs(),null;case 24:return null;default:return null}}var Si=!1,ae=!1,Wp=typeof WeakSet=="function"?WeakSet:Set,C=null;function en(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(i){U(e,t,i)}else n.current=null}function Uo(e,t,n){try{n()}catch(i){U(e,t,i)}}var Yr=!1;function Up(e,t){if(ko=Vi,e=hu(),Cs(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var i=n.getSelection&&n.getSelection();if(i&&i.rangeCount!==0){n=i.anchorNode;var a=i.anchorOffset,o=i.focusNode;i=i.focusOffset;try{n.nodeType,o.nodeType}catch{n=null;break e}var s=0,r=-1,l=-1,u=0,f=0,m=e,p=null;t:for(;;){for(var g;m!==n||a!==0&&m.nodeType!==3||(r=s+a),m!==o||i!==0&&m.nodeType!==3||(l=s+i),m.nodeType===3&&(s+=m.nodeValue.length),(g=m.firstChild)!==null;)p=m,m=g;for(;;){if(m===e)break t;if(p===n&&++u===a&&(r=s),p===o&&++f===i&&(l=s),(g=m.nextSibling)!==null)break;m=p,p=m.parentNode}m=g}n=r===-1||l===-1?null:{start:r,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(To={focusedElem:e,selectionRange:n},Vi=!1,C=t;C!==null;)if(t=C,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,C=e;else for(;C!==null;){t=C;try{var v=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(v!==null){var _=v.memoizedProps,B=v.memoizedState,d=t.stateNode,c=d.getSnapshotBeforeUpdate(t.elementType===t.type?_:Be(t.type,_),B);d.__reactInternalSnapshotBeforeUpdate=c}break;case 3:var h=t.stateNode.containerInfo;h.nodeType===1?h.textContent="":h.nodeType===9&&h.documentElement&&h.removeChild(h.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(b(163))}}catch(y){U(t,t.return,y)}if(e=t.sibling,e!==null){e.return=t.return,C=e;break}C=t.return}return v=Yr,Yr=!1,v}function Ln(e,t,n){var i=t.updateQueue;if(i=i!==null?i.lastEffect:null,i!==null){var a=i=i.next;do{if((a.tag&e)===e){var o=a.destroy;a.destroy=void 0,o!==void 0&&Uo(t,n,o)}a=a.next}while(a!==i)}}function qa(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var i=n.create;n.destroy=i()}n=n.next}while(n!==t)}}function Xo(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function uc(e){var t=e.alternate;t!==null&&(e.alternate=null,uc(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[De],delete t[Yn],delete t[Po],delete t[Ip],delete t[kp])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function cc(e){return e.tag===5||e.tag===3||e.tag===4}function Kr(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||cc(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function Vo(e,t,n){var i=e.tag;if(i===5||i===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=Hi));else if(i!==4&&(e=e.child,e!==null))for(Vo(e,t,n),e=e.sibling;e!==null;)Vo(e,t,n),e=e.sibling}function jo(e,t,n){var i=e.tag;if(i===5||i===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(i!==4&&(e=e.child,e!==null))for(jo(e,t,n),e=e.sibling;e!==null;)jo(e,t,n),e=e.sibling}var J=null,Oe=!1;function nt(e,t,n){for(n=n.child;n!==null;)dc(e,t,n),n=n.sibling}function dc(e,t,n){if(We&&typeof We.onCommitFiberUnmount=="function")try{We.onCommitFiberUnmount(ma,n)}catch{}switch(n.tag){case 5:ae||en(n,t);case 6:var i=J,a=Oe;J=null,nt(e,t,n),J=i,Oe=a,J!==null&&(Oe?(e=J,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):J.removeChild(n.stateNode));break;case 18:J!==null&&(Oe?(e=J,n=n.stateNode,e.nodeType===8?ja(e.parentNode,n):e.nodeType===1&&ja(e,n),Vn(e)):ja(J,n.stateNode));break;case 4:i=J,a=Oe,J=n.stateNode.containerInfo,Oe=!0,nt(e,t,n),J=i,Oe=a;break;case 0:case 11:case 14:case 15:if(!ae&&(i=n.updateQueue,i!==null&&(i=i.lastEffect,i!==null))){a=i=i.next;do{var o=a,s=o.destroy;o=o.tag,s!==void 0&&(o&2||o&4)&&Uo(n,t,s),a=a.next}while(a!==i)}nt(e,t,n);break;case 1:if(!ae&&(en(n,t),i=n.stateNode,typeof i.componentWillUnmount=="function"))try{i.props=n.memoizedProps,i.state=n.memoizedState,i.componentWillUnmount()}catch(r){U(n,t,r)}nt(e,t,n);break;case 21:nt(e,t,n);break;case 22:n.mode&1?(ae=(i=ae)||n.memoizedState!==null,nt(e,t,n),ae=i):nt(e,t,n);break;default:nt(e,t,n)}}function Jr(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new Wp),t.forEach(function(i){var a=Jp.bind(null,e,i);n.has(i)||(n.add(i),i.then(a,a))})}}function Re(e,t){var n=t.deletions;if(n!==null)for(var i=0;i<n.length;i++){var a=n[i];try{var o=e,s=t,r=s;e:for(;r!==null;){switch(r.tag){case 5:J=r.stateNode,Oe=!1;break e;case 3:J=r.stateNode.containerInfo,Oe=!0;break e;case 4:J=r.stateNode.containerInfo,Oe=!0;break e}r=r.return}if(J===null)throw Error(b(160));dc(o,s,a),J=null,Oe=!1;var l=a.alternate;l!==null&&(l.return=null),a.return=null}catch(u){U(a,t,u)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)pc(t,e),t=t.sibling}function pc(e,t){var n=e.alternate,i=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(Re(t,e),Ne(e),i&4){try{Ln(3,e,e.return),qa(3,e)}catch(_){U(e,e.return,_)}try{Ln(5,e,e.return)}catch(_){U(e,e.return,_)}}break;case 1:Re(t,e),Ne(e),i&512&&n!==null&&en(n,n.return);break;case 5:if(Re(t,e),Ne(e),i&512&&n!==null&&en(n,n.return),e.flags&32){var a=e.stateNode;try{zn(a,"")}catch(_){U(e,e.return,_)}}if(i&4&&(a=e.stateNode,a!=null)){var o=e.memoizedProps,s=n!==null?n.memoizedProps:o,r=e.type,l=e.updateQueue;if(e.updateQueue=null,l!==null)try{r==="input"&&o.type==="radio"&&o.name!=null&&Ol(a,o),yo(r,s);var u=yo(r,o);for(s=0;s<l.length;s+=2){var f=l[s],m=l[s+1];f==="style"?Nl(a,m):f==="dangerouslySetInnerHTML"?Ql(a,m):f==="children"?zn(a,m):cs(a,f,m,u)}switch(r){case"input":po(a,o);break;case"textarea":El(a,o);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!o.multiple;var g=o.value;g!=null?nn(a,!!o.multiple,g,!1):p!==!!o.multiple&&(o.defaultValue!=null?nn(a,!!o.multiple,o.defaultValue,!0):nn(a,!!o.multiple,o.multiple?[]:"",!1))}a[Yn]=o}catch(_){U(e,e.return,_)}}break;case 6:if(Re(t,e),Ne(e),i&4){if(e.stateNode===null)throw Error(b(162));a=e.stateNode,o=e.memoizedProps;try{a.nodeValue=o}catch(_){U(e,e.return,_)}}break;case 3:if(Re(t,e),Ne(e),i&4&&n!==null&&n.memoizedState.isDehydrated)try{Vn(t.containerInfo)}catch(_){U(e,e.return,_)}break;case 4:Re(t,e),Ne(e);break;case 13:Re(t,e),Ne(e),a=e.child,a.flags&8192&&(o=a.memoizedState!==null,a.stateNode.isHidden=o,!o||a.alternate!==null&&a.alternate.memoizedState!==null||(Ws=V())),i&4&&Jr(e);break;case 22:if(f=n!==null&&n.memoizedState!==null,e.mode&1?(ae=(u=ae)||f,Re(t,e),ae=u):Re(t,e),Ne(e),i&8192){if(u=e.memoizedState!==null,(e.stateNode.isHidden=u)&&!f&&e.mode&1)for(C=e,f=e.child;f!==null;){for(m=C=f;C!==null;){switch(p=C,g=p.child,p.tag){case 0:case 11:case 14:case 15:Ln(4,p,p.return);break;case 1:en(p,p.return);var v=p.stateNode;if(typeof v.componentWillUnmount=="function"){i=p,n=p.return;try{t=i,v.props=t.memoizedProps,v.state=t.memoizedState,v.componentWillUnmount()}catch(_){U(i,n,_)}}break;case 5:en(p,p.return);break;case 22:if(p.memoizedState!==null){tl(m);continue}}g!==null?(g.return=p,C=g):tl(m)}f=f.sibling}e:for(f=null,m=e;;){if(m.tag===5){if(f===null){f=m;try{a=m.stateNode,u?(o=a.style,typeof o.setProperty=="function"?o.setProperty("display","none","important"):o.display="none"):(r=m.stateNode,l=m.memoizedProps.style,s=l!=null&&l.hasOwnProperty("display")?l.display:null,r.style.display=Ll("display",s))}catch(_){U(e,e.return,_)}}}else if(m.tag===6){if(f===null)try{m.stateNode.nodeValue=u?"":m.memoizedProps}catch(_){U(e,e.return,_)}}else if((m.tag!==22&&m.tag!==23||m.memoizedState===null||m===e)&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===e)break e;for(;m.sibling===null;){if(m.return===null||m.return===e)break e;f===m&&(f=null),m=m.return}f===m&&(f=null),m.sibling.return=m.return,m=m.sibling}}break;case 19:Re(t,e),Ne(e),i&4&&Jr(e);break;case 21:break;default:Re(t,e),Ne(e)}}function Ne(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(cc(n)){var i=n;break e}n=n.return}throw Error(b(160))}switch(i.tag){case 5:var a=i.stateNode;i.flags&32&&(zn(a,""),i.flags&=-33);var o=Kr(e);jo(e,o,a);break;case 3:case 4:var s=i.stateNode.containerInfo,r=Kr(e);Vo(e,r,s);break;default:throw Error(b(161))}}catch(l){U(e,e.return,l)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function Xp(e,t,n){C=e,hc(e)}function hc(e,t,n){for(var i=(e.mode&1)!==0;C!==null;){var a=C,o=a.child;if(a.tag===22&&i){var s=a.memoizedState!==null||Si;if(!s){var r=a.alternate,l=r!==null&&r.memoizedState!==null||ae;r=Si;var u=ae;if(Si=s,(ae=l)&&!u)for(C=a;C!==null;)s=C,l=s.child,s.tag===22&&s.memoizedState!==null?nl(a):l!==null?(l.return=s,C=l):nl(a);for(;o!==null;)C=o,hc(o),o=o.sibling;C=a,Si=r,ae=u}el(e)}else a.subtreeFlags&8772&&o!==null?(o.return=a,C=o):el(e)}}function el(e){for(;C!==null;){var t=C;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:ae||qa(5,t);break;case 1:var i=t.stateNode;if(t.flags&4&&!ae)if(n===null)i.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:Be(t.type,n.memoizedProps);i.componentDidUpdate(a,n.memoizedState,i.__reactInternalSnapshotBeforeUpdate)}var o=t.updateQueue;o!==null&&Lr(t,o,i);break;case 3:var s=t.updateQueue;if(s!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}Lr(t,s,n)}break;case 5:var r=t.stateNode;if(n===null&&t.flags&4){n=r;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var u=t.alternate;if(u!==null){var f=u.memoizedState;if(f!==null){var m=f.dehydrated;m!==null&&Vn(m)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(b(163))}ae||t.flags&512&&Xo(t)}catch(p){U(t,t.return,p)}}if(t===e){C=null;break}if(n=t.sibling,n!==null){n.return=t.return,C=n;break}C=t.return}}function tl(e){for(;C!==null;){var t=C;if(t===e){C=null;break}var n=t.sibling;if(n!==null){n.return=t.return,C=n;break}C=t.return}}function nl(e){for(;C!==null;){var t=C;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{qa(4,t)}catch(l){U(t,n,l)}break;case 1:var i=t.stateNode;if(typeof i.componentDidMount=="function"){var a=t.return;try{i.componentDidMount()}catch(l){U(t,a,l)}}var o=t.return;try{Xo(t)}catch(l){U(t,o,l)}break;case 5:var s=t.return;try{Xo(t)}catch(l){U(t,s,l)}}}catch(l){U(t,t.return,l)}if(t===e){C=null;break}var r=t.sibling;if(r!==null){r.return=t.return,C=r;break}C=t.return}}var Vp=Math.ceil,sa=tt.ReactCurrentDispatcher,Ds=tt.ReactCurrentOwner,Me=tt.ReactCurrentBatchConfig,O=0,K=null,j=null,ee=0,ye=0,tn=_t(0),H=0,ii=null,Ft=0,Ca=0,zs=0,Nn=null,pe=null,Ws=0,fn=1/0,Xe=null,ra=!1,Zo=null,mt=null,Ii=!1,lt=null,la=0,Gn=0,Ho=null,Li=-1,Ni=0;function le(){return O&6?V():Li!==-1?Li:Li=V()}function ft(e){return e.mode&1?O&2&&ee!==0?ee&-ee:Mp.transition!==null?(Ni===0&&(Ni=Yl()),Ni):(e=F,e!==0||(e=window.event,e=e===void 0?16:au(e.type)),e):1}function Qe(e,t,n,i){if(50<Gn)throw Gn=0,Ho=null,Error(b(185));oi(e,n,i),(!(O&2)||e!==K)&&(e===K&&(!(O&2)&&(Ca|=n),H===4&&st(e,ee)),ge(e,i),n===1&&O===0&&!(t.mode&1)&&(fn=V()+500,ba&&wt()))}function ge(e,t){var n=e.callbackNode;Md(e,t);var i=Xi(e,e===K?ee:0);if(i===0)n!==null&&dr(n),e.callbackNode=null,e.callbackPriority=0;else if(t=i&-i,e.callbackPriority!==t){if(n!=null&&dr(n),t===1)e.tag===0?Tp(il.bind(null,e)):Cu(il.bind(null,e)),xp(function(){!(O&6)&&wt()}),n=null;else{switch(Kl(i)){case 1:n=fs;break;case 4:n=Hl;break;case 16:n=Ui;break;case 536870912:n=$l;break;default:n=Ui}n=wc(n,mc.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function mc(e,t){if(Li=-1,Ni=0,O&6)throw Error(b(327));var n=e.callbackNode;if(ln()&&e.callbackNode!==n)return null;var i=Xi(e,e===K?ee:0);if(i===0)return null;if(i&30||i&e.expiredLanes||t)t=ua(e,i);else{t=i;var a=O;O|=2;var o=gc();(K!==e||ee!==t)&&(Xe=null,fn=V()+500,Pt(e,t));do try{Hp();break}catch(r){fc(e,r)}while(!0);Ts(),sa.current=o,O=a,j!==null?t=0:(K=null,ee=0,t=H)}if(t!==0){if(t===2&&(a=qo(e),a!==0&&(i=a,t=$o(e,a))),t===1)throw n=ii,Pt(e,0),st(e,i),ge(e,V()),n;if(t===6)st(e,i);else{if(a=e.current.alternate,!(i&30)&&!jp(a)&&(t=ua(e,i),t===2&&(o=qo(e),o!==0&&(i=o,t=$o(e,o))),t===1))throw n=ii,Pt(e,0),st(e,i),ge(e,V()),n;switch(e.finishedWork=a,e.finishedLanes=i,t){case 0:case 1:throw Error(b(345));case 2:It(e,pe,Xe);break;case 3:if(st(e,i),(i&130023424)===i&&(t=Ws+500-V(),10<t)){if(Xi(e,0)!==0)break;if(a=e.suspendedLanes,(a&i)!==i){le(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=Ao(It.bind(null,e,pe,Xe),t);break}It(e,pe,Xe);break;case 4:if(st(e,i),(i&4194240)===i)break;for(t=e.eventTimes,a=-1;0<i;){var s=31-Fe(i);o=1<<s,s=t[s],s>a&&(a=s),i&=~o}if(i=a,i=V()-i,i=(120>i?120:480>i?480:1080>i?1080:1920>i?1920:3e3>i?3e3:4320>i?4320:1960*Vp(i/1960))-i,10<i){e.timeoutHandle=Ao(It.bind(null,e,pe,Xe),i);break}It(e,pe,Xe);break;case 5:It(e,pe,Xe);break;default:throw Error(b(329))}}}return ge(e,V()),e.callbackNode===n?mc.bind(null,e):null}function $o(e,t){var n=Nn;return e.current.memoizedState.isDehydrated&&(Pt(e,t).flags|=256),e=ua(e,t),e!==2&&(t=pe,pe=n,t!==null&&Yo(t)),e}function Yo(e){pe===null?pe=e:pe.push.apply(pe,e)}function jp(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var i=0;i<n.length;i++){var a=n[i],o=a.getSnapshot;a=a.value;try{if(!Le(o(),a))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function st(e,t){for(t&=~zs,t&=~Ca,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-Fe(t),i=1<<n;e[n]=-1,t&=~i}}function il(e){if(O&6)throw Error(b(327));ln();var t=Xi(e,0);if(!(t&1))return ge(e,V()),null;var n=ua(e,t);if(e.tag!==0&&n===2){var i=qo(e);i!==0&&(t=i,n=$o(e,i))}if(n===1)throw n=ii,Pt(e,0),st(e,t),ge(e,V()),n;if(n===6)throw Error(b(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,It(e,pe,Xe),ge(e,V()),null}function Us(e,t){var n=O;O|=1;try{return e(t)}finally{O=n,O===0&&(fn=V()+500,ba&&wt())}}function Qt(e){lt!==null&&lt.tag===0&&!(O&6)&&ln();var t=O;O|=1;var n=Me.transition,i=F;try{if(Me.transition=null,F=1,e)return e()}finally{F=i,Me.transition=n,O=t,!(O&6)&&wt()}}function Xs(){ye=tn.current,N(tn)}function Pt(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,Cp(n)),j!==null)for(n=j.return;n!==null;){var i=n;switch(Ss(i),i.tag){case 1:i=i.type.childContextTypes,i!=null&&$i();break;case 3:hn(),N(me),N(oe),Os();break;case 5:Bs(i);break;case 4:hn();break;case 13:N(D);break;case 19:N(D);break;case 10:Ms(i.type._context);break;case 22:case 23:Xs()}n=n.return}if(K=e,j=e=gt(e.current,null),ee=ye=t,H=0,ii=null,zs=Ca=Ft=0,pe=Nn=null,Mt!==null){for(t=0;t<Mt.length;t++)if(n=Mt[t],i=n.interleaved,i!==null){n.interleaved=null;var a=i.next,o=n.pending;if(o!==null){var s=o.next;o.next=a,i.next=s}n.pending=i}Mt=null}return e}function fc(e,t){do{var n=j;try{if(Ts(),Ei.current=oa,aa){for(var i=z.memoizedState;i!==null;){var a=i.queue;a!==null&&(a.pending=null),i=i.next}aa=!1}if(Et=0,Y=Z=z=null,Qn=!1,ei=0,Ds.current=null,n===null||n.return===null){H=1,ii=t,j=null;break}e:{var o=e,s=n.return,r=n,l=t;if(t=ee,r.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=l,f=r,m=f.tag;if(!(f.mode&1)&&(m===0||m===11||m===15)){var p=f.alternate;p?(f.updateQueue=p.updateQueue,f.memoizedState=p.memoizedState,f.lanes=p.lanes):(f.updateQueue=null,f.memoizedState=null)}var g=Ur(s);if(g!==null){g.flags&=-257,Xr(g,s,r,o,t),g.mode&1&&Wr(o,u,t),t=g,l=u;var v=t.updateQueue;if(v===null){var _=new Set;_.add(l),t.updateQueue=_}else v.add(l);break e}else{if(!(t&1)){Wr(o,u,t),Vs();break e}l=Error(b(426))}}else if(G&&r.mode&1){var B=Ur(s);if(B!==null){!(B.flags&65536)&&(B.flags|=256),Xr(B,s,r,o,t),Is(mn(l,r));break e}}o=l=mn(l,r),H!==4&&(H=2),Nn===null?Nn=[o]:Nn.push(o),o=s;do{switch(o.tag){case 3:o.flags|=65536,t&=-t,o.lanes|=t;var d=Ku(o,l,t);Qr(o,d);break e;case 1:r=l;var c=o.type,h=o.stateNode;if(!(o.flags&128)&&(typeof c.getDerivedStateFromError=="function"||h!==null&&typeof h.componentDidCatch=="function"&&(mt===null||!mt.has(h)))){o.flags|=65536,t&=-t,o.lanes|=t;var y=Ju(o,r,t);Qr(o,y);break e}}o=o.return}while(o!==null)}vc(n)}catch(q){t=q,j===n&&n!==null&&(j=n=n.return);continue}break}while(!0)}function gc(){var e=sa.current;return sa.current=oa,e===null?oa:e}function Vs(){(H===0||H===3||H===2)&&(H=4),K===null||!(Ft&268435455)&&!(Ca&268435455)||st(K,ee)}function ua(e,t){var n=O;O|=2;var i=gc();(K!==e||ee!==t)&&(Xe=null,Pt(e,t));do try{Zp();break}catch(a){fc(e,a)}while(!0);if(Ts(),O=n,sa.current=i,j!==null)throw Error(b(261));return K=null,ee=0,H}function Zp(){for(;j!==null;)yc(j)}function Hp(){for(;j!==null&&!_d();)yc(j)}function yc(e){var t=_c(e.alternate,e,ye);e.memoizedProps=e.pendingProps,t===null?vc(e):j=t,Ds.current=null}function vc(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=zp(n,t),n!==null){n.flags&=32767,j=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{H=6,j=null;return}}else if(n=Dp(n,t,ye),n!==null){j=n;return}if(t=t.sibling,t!==null){j=t;return}j=t=e}while(t!==null);H===0&&(H=5)}function It(e,t,n){var i=F,a=Me.transition;try{Me.transition=null,F=1,$p(e,t,n,i)}finally{Me.transition=a,F=i}return null}function $p(e,t,n,i){do ln();while(lt!==null);if(O&6)throw Error(b(327));n=e.finishedWork;var a=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(b(177));e.callbackNode=null,e.callbackPriority=0;var o=n.lanes|n.childLanes;if(Ad(e,o),e===K&&(j=K=null,ee=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||Ii||(Ii=!0,wc(Ui,function(){return ln(),null})),o=(n.flags&15990)!==0,n.subtreeFlags&15990||o){o=Me.transition,Me.transition=null;var s=F;F=1;var r=O;O|=4,Ds.current=null,Up(e,n),pc(n,e),gp(To),Vi=!!ko,To=ko=null,e.current=n,Xp(n),wd(),O=r,F=s,Me.transition=o}else e.current=n;if(Ii&&(Ii=!1,lt=e,la=a),o=e.pendingLanes,o===0&&(mt=null),xd(n.stateNode),ge(e,V()),t!==null)for(i=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],i(a.value,{componentStack:a.stack,digest:a.digest});if(ra)throw ra=!1,e=Zo,Zo=null,e;return la&1&&e.tag!==0&&ln(),o=e.pendingLanes,o&1?e===Ho?Gn++:(Gn=0,Ho=e):Gn=0,wt(),null}function ln(){if(lt!==null){var e=Kl(la),t=Me.transition,n=F;try{if(Me.transition=null,F=16>e?16:e,lt===null)var i=!1;else{if(e=lt,lt=null,la=0,O&6)throw Error(b(331));var a=O;for(O|=4,C=e.current;C!==null;){var o=C,s=o.child;if(C.flags&16){var r=o.deletions;if(r!==null){for(var l=0;l<r.length;l++){var u=r[l];for(C=u;C!==null;){var f=C;switch(f.tag){case 0:case 11:case 15:Ln(8,f,o)}var m=f.child;if(m!==null)m.return=f,C=m;else for(;C!==null;){f=C;var p=f.sibling,g=f.return;if(uc(f),f===u){C=null;break}if(p!==null){p.return=g,C=p;break}C=g}}}var v=o.alternate;if(v!==null){var _=v.child;if(_!==null){v.child=null;do{var B=_.sibling;_.sibling=null,_=B}while(_!==null)}}C=o}}if(o.subtreeFlags&2064&&s!==null)s.return=o,C=s;else e:for(;C!==null;){if(o=C,o.flags&2048)switch(o.tag){case 0:case 11:case 15:Ln(9,o,o.return)}var d=o.sibling;if(d!==null){d.return=o.return,C=d;break e}C=o.return}}var c=e.current;for(C=c;C!==null;){s=C;var h=s.child;if(s.subtreeFlags&2064&&h!==null)h.return=s,C=h;else e:for(s=c;C!==null;){if(r=C,r.flags&2048)try{switch(r.tag){case 0:case 11:case 15:qa(9,r)}}catch(q){U(r,r.return,q)}if(r===s){C=null;break e}var y=r.sibling;if(y!==null){y.return=r.return,C=y;break e}C=r.return}}if(O=a,wt(),We&&typeof We.onPostCommitFiberRoot=="function")try{We.onPostCommitFiberRoot(ma,e)}catch{}i=!0}return i}finally{F=n,Me.transition=t}}return!1}function al(e,t,n){t=mn(n,t),t=Ku(e,t,1),e=ht(e,t,1),t=le(),e!==null&&(oi(e,1,t),ge(e,t))}function U(e,t,n){if(e.tag===3)al(e,e,n);else for(;t!==null;){if(t.tag===3){al(t,e,n);break}else if(t.tag===1){var i=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof i.componentDidCatch=="function"&&(mt===null||!mt.has(i))){e=mn(n,e),e=Ju(t,e,1),t=ht(t,e,1),e=le(),t!==null&&(oi(t,1,e),ge(t,e));break}}t=t.return}}function Yp(e,t,n){var i=e.pingCache;i!==null&&i.delete(t),t=le(),e.pingedLanes|=e.suspendedLanes&n,K===e&&(ee&n)===n&&(H===4||H===3&&(ee&130023424)===ee&&500>V()-Ws?Pt(e,0):zs|=n),ge(e,t)}function bc(e,t){t===0&&(e.mode&1?(t=gi,gi<<=1,!(gi&130023424)&&(gi=4194304)):t=1);var n=le();e=Ke(e,t),e!==null&&(oi(e,t,n),ge(e,n))}function Kp(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),bc(e,n)}function Jp(e,t){var n=0;switch(e.tag){case 13:var i=e.stateNode,a=e.memoizedState;a!==null&&(n=a.retryLane);break;case 19:i=e.stateNode;break;default:throw Error(b(314))}i!==null&&i.delete(t),bc(e,n)}var _c;_c=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||me.current)he=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return he=!1,Gp(e,t,n);he=!!(e.flags&131072)}else he=!1,G&&t.flags&1048576&&xu(t,Ji,t.index);switch(t.lanes=0,t.tag){case 2:var i=t.type;Qi(e,t),e=t.pendingProps;var a=cn(t,oe.current);rn(t,n),a=Fs(null,t,i,e,a,n);var o=Qs();return t.flags|=1,typeof a=="object"&&a!==null&&typeof a.render=="function"&&a.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,fe(i)?(o=!0,Yi(t)):o=!1,t.memoizedState=a.state!==null&&a.state!==void 0?a.state:null,Ps(t),a.updater=wa,t.stateNode=a,a._reactInternals=t,Qo(t,i,e,n),t=Go(null,t,i,!0,o,n)):(t.tag=0,G&&o&&xs(t),re(null,t,a,n),t=t.child),t;case 16:i=t.elementType;e:{switch(Qi(e,t),e=t.pendingProps,a=i._init,i=a(i._payload),t.type=i,a=t.tag=th(i),e=Be(i,e),a){case 0:t=No(null,t,i,e,n);break e;case 1:t=Zr(null,t,i,e,n);break e;case 11:t=Vr(null,t,i,e,n);break e;case 14:t=jr(null,t,i,Be(i.type,e),n);break e}throw Error(b(306,i,""))}return t;case 0:return i=t.type,a=t.pendingProps,a=t.elementType===i?a:Be(i,a),No(e,t,i,a,n);case 1:return i=t.type,a=t.pendingProps,a=t.elementType===i?a:Be(i,a),Zr(e,t,i,a,n);case 3:e:{if(ic(t),e===null)throw Error(b(387));i=t.pendingProps,o=t.memoizedState,a=o.element,Au(e,t),na(t,i,null,n);var s=t.memoizedState;if(i=s.element,o.isDehydrated)if(o={element:i,isDehydrated:!1,cache:s.cache,pendingSuspenseBoundaries:s.pendingSuspenseBoundaries,transitions:s.transitions},t.updateQueue.baseState=o,t.memoizedState=o,t.flags&256){a=mn(Error(b(423)),t),t=Hr(e,t,i,n,a);break e}else if(i!==a){a=mn(Error(b(424)),t),t=Hr(e,t,i,n,a);break e}else for(_e=pt(t.stateNode.containerInfo.firstChild),we=t,G=!0,Ee=null,n=Tu(t,null,i,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(dn(),i===a){t=Je(e,t,n);break e}re(e,t,i,n)}t=t.child}return t;case 5:return Pu(t),e===null&&Oo(t),i=t.type,a=t.pendingProps,o=e!==null?e.memoizedProps:null,s=a.children,Mo(i,a)?s=null:o!==null&&Mo(i,o)&&(t.flags|=32),nc(e,t),re(e,t,s,n),t.child;case 6:return e===null&&Oo(t),null;case 13:return ac(e,t,n);case 4:return Rs(t,t.stateNode.containerInfo),i=t.pendingProps,e===null?t.child=pn(t,null,i,n):re(e,t,i,n),t.child;case 11:return i=t.type,a=t.pendingProps,a=t.elementType===i?a:Be(i,a),Vr(e,t,i,a,n);case 7:return re(e,t,t.pendingProps,n),t.child;case 8:return re(e,t,t.pendingProps.children,n),t.child;case 12:return re(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(i=t.type._context,a=t.pendingProps,o=t.memoizedProps,s=a.value,Q(ea,i._currentValue),i._currentValue=s,o!==null)if(Le(o.value,s)){if(o.children===a.children&&!me.current){t=Je(e,t,n);break e}}else for(o=t.child,o!==null&&(o.return=t);o!==null;){var r=o.dependencies;if(r!==null){s=o.child;for(var l=r.firstContext;l!==null;){if(l.context===i){if(o.tag===1){l=He(-1,n&-n),l.tag=2;var u=o.updateQueue;if(u!==null){u=u.shared;var f=u.pending;f===null?l.next=l:(l.next=f.next,f.next=l),u.pending=l}}o.lanes|=n,l=o.alternate,l!==null&&(l.lanes|=n),Eo(o.return,n,t),r.lanes|=n;break}l=l.next}}else if(o.tag===10)s=o.type===t.type?null:o.child;else if(o.tag===18){if(s=o.return,s===null)throw Error(b(341));s.lanes|=n,r=s.alternate,r!==null&&(r.lanes|=n),Eo(s,n,t),s=o.sibling}else s=o.child;if(s!==null)s.return=o;else for(s=o;s!==null;){if(s===t){s=null;break}if(o=s.sibling,o!==null){o.return=s.return,s=o;break}s=s.return}o=s}re(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,i=t.pendingProps.children,rn(t,n),a=Ae(a),i=i(a),t.flags|=1,re(e,t,i,n),t.child;case 14:return i=t.type,a=Be(i,t.pendingProps),a=Be(i.type,a),jr(e,t,i,a,n);case 15:return ec(e,t,t.type,t.pendingProps,n);case 17:return i=t.type,a=t.pendingProps,a=t.elementType===i?a:Be(i,a),Qi(e,t),t.tag=1,fe(i)?(e=!0,Yi(t)):e=!1,rn(t,n),Yu(t,i,a),Qo(t,i,a,n),Go(null,t,i,!0,e,n);case 19:return oc(e,t,n);case 22:return tc(e,t,n)}throw Error(b(156,t.tag))};function wc(e,t){return Zl(e,t)}function eh(e,t,n,i){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=i,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Te(e,t,n,i){return new eh(e,t,n,i)}function js(e){return e=e.prototype,!(!e||!e.isReactComponent)}function th(e){if(typeof e=="function")return js(e)?1:0;if(e!=null){if(e=e.$$typeof,e===ps)return 11;if(e===hs)return 14}return 2}function gt(e,t){var n=e.alternate;return n===null?(n=Te(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Gi(e,t,n,i,a,o){var s=2;if(i=e,typeof e=="function")js(e)&&(s=1);else if(typeof e=="string")s=5;else e:switch(e){case Xt:return Rt(n.children,a,o,t);case ds:s=8,a|=8;break;case so:return e=Te(12,n,t,a|2),e.elementType=so,e.lanes=o,e;case ro:return e=Te(13,n,t,a),e.elementType=ro,e.lanes=o,e;case lo:return e=Te(19,n,t,a),e.elementType=lo,e.lanes=o,e;case Pl:return xa(n,a,o,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case Ml:s=10;break e;case Al:s=9;break e;case ps:s=11;break e;case hs:s=14;break e;case it:s=16,i=null;break e}throw Error(b(130,e==null?e:typeof e,""))}return t=Te(s,n,t,a),t.elementType=e,t.type=i,t.lanes=o,t}function Rt(e,t,n,i){return e=Te(7,e,i,t),e.lanes=n,e}function xa(e,t,n,i){return e=Te(22,e,i,t),e.elementType=Pl,e.lanes=n,e.stateNode={isHidden:!1},e}function to(e,t,n){return e=Te(6,e,null,t),e.lanes=n,e}function no(e,t,n){return t=Te(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function nh(e,t,n,i,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Fa(0),this.expirationTimes=Fa(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Fa(0),this.identifierPrefix=i,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Zs(e,t,n,i,a,o,s,r,l){return e=new nh(e,t,n,r,l),t===1?(t=1,o===!0&&(t|=8)):t=0,o=Te(3,null,null,t),e.current=o,o.stateNode=e,o.memoizedState={element:i,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Ps(o),e}function ih(e,t,n){var i=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Ut,key:i==null?null:""+i,children:e,containerInfo:t,implementation:n}}function qc(e){if(!e)return vt;e=e._reactInternals;e:{if(Nt(e)!==e||e.tag!==1)throw Error(b(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(fe(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(b(171))}if(e.tag===1){var n=e.type;if(fe(n))return qu(e,n,t)}return t}function Cc(e,t,n,i,a,o,s,r,l){return e=Zs(n,i,!0,e,a,o,s,r,l),e.context=qc(null),n=e.current,i=le(),a=ft(n),o=He(i,a),o.callback=t??null,ht(n,o,a),e.current.lanes=a,oi(e,a,i),ge(e,i),e}function Sa(e,t,n,i){var a=t.current,o=le(),s=ft(a);return n=qc(n),t.context===null?t.context=n:t.pendingContext=n,t=He(o,s),t.payload={element:e},i=i===void 0?null:i,i!==null&&(t.callback=i),e=ht(a,t,s),e!==null&&(Qe(e,a,s,o),Oi(e,a,s)),s}function ca(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function ol(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function Hs(e,t){ol(e,t),(e=e.alternate)&&ol(e,t)}function ah(){return null}var xc=typeof reportError=="function"?reportError:function(e){console.error(e)};function $s(e){this._internalRoot=e}Ia.prototype.render=$s.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(b(409));Sa(e,t,null,null)};Ia.prototype.unmount=$s.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Qt(function(){Sa(null,e,null,null)}),t[Ye]=null}};function Ia(e){this._internalRoot=e}Ia.prototype.unstable_scheduleHydration=function(e){if(e){var t=tu();e={blockedOn:null,target:e,priority:t};for(var n=0;n<ot.length&&t!==0&&t<ot[n].priority;n++);ot.splice(n,0,e),n===0&&iu(e)}};function Ys(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function ka(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function sl(){}function oh(e,t,n,i,a){if(a){if(typeof i=="function"){var o=i;i=function(){var u=ca(s);o.call(u)}}var s=Cc(t,i,e,0,null,!1,!1,"",sl);return e._reactRootContainer=s,e[Ye]=s.current,Hn(e.nodeType===8?e.parentNode:e),Qt(),s}for(;a=e.lastChild;)e.removeChild(a);if(typeof i=="function"){var r=i;i=function(){var u=ca(l);r.call(u)}}var l=Zs(e,0,!1,null,null,!1,!1,"",sl);return e._reactRootContainer=l,e[Ye]=l.current,Hn(e.nodeType===8?e.parentNode:e),Qt(function(){Sa(t,l,n,i)}),l}function Ta(e,t,n,i,a){var o=n._reactRootContainer;if(o){var s=o;if(typeof a=="function"){var r=a;a=function(){var l=ca(s);r.call(l)}}Sa(t,s,e,a)}else s=oh(n,t,e,a,i);return ca(s)}Jl=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=An(t.pendingLanes);n!==0&&(gs(t,n|1),ge(t,V()),!(O&6)&&(fn=V()+500,wt()))}break;case 13:Qt(function(){var i=Ke(e,1);if(i!==null){var a=le();Qe(i,e,1,a)}}),Hs(e,1)}};ys=function(e){if(e.tag===13){var t=Ke(e,134217728);if(t!==null){var n=le();Qe(t,e,134217728,n)}Hs(e,134217728)}};eu=function(e){if(e.tag===13){var t=ft(e),n=Ke(e,t);if(n!==null){var i=le();Qe(n,e,t,i)}Hs(e,t)}};tu=function(){return F};nu=function(e,t){var n=F;try{return F=e,t()}finally{F=n}};bo=function(e,t,n){switch(t){case"input":if(po(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var i=n[t];if(i!==e&&i.form===e.form){var a=va(i);if(!a)throw Error(b(90));Bl(i),po(i,a)}}}break;case"textarea":El(e,n);break;case"select":t=n.value,t!=null&&nn(e,!!n.multiple,t,!1)}};zl=Us;Wl=Qt;var sh={usingClientEntryPoint:!1,Events:[ri,Ht,va,Gl,Dl,Us]},kn={findFiberByHostInstance:Tt,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},rh={bundleType:kn.bundleType,version:kn.version,rendererPackageName:kn.rendererPackageName,rendererConfig:kn.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:tt.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=Vl(e),e===null?null:e.stateNode},findFiberByHostInstance:kn.findFiberByHostInstance||ah,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var ki=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!ki.isDisabled&&ki.supportsFiber)try{ma=ki.inject(rh),We=ki}catch{}}Ce.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sh;Ce.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Ys(t))throw Error(b(200));return ih(e,t,null,n)};Ce.createRoot=function(e,t){if(!Ys(e))throw Error(b(299));var n=!1,i="",a=xc;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(i=t.identifierPrefix),t.onRecoverableError!==void 0&&(a=t.onRecoverableError)),t=Zs(e,1,!1,null,null,n,!1,i,a),e[Ye]=t.current,Hn(e.nodeType===8?e.parentNode:e),new $s(t)};Ce.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(b(188)):(e=Object.keys(e).join(","),Error(b(268,e)));return e=Vl(t),e=e===null?null:e.stateNode,e};Ce.flushSync=function(e){return Qt(e)};Ce.hydrate=function(e,t,n){if(!ka(t))throw Error(b(200));return Ta(null,e,t,!0,n)};Ce.hydrateRoot=function(e,t,n){if(!Ys(e))throw Error(b(405));var i=n!=null&&n.hydratedSources||null,a=!1,o="",s=xc;if(n!=null&&(n.unstable_strictMode===!0&&(a=!0),n.identifierPrefix!==void 0&&(o=n.identifierPrefix),n.onRecoverableError!==void 0&&(s=n.onRecoverableError)),t=Cc(t,null,e,1,n??null,a,!1,o,s),e[Ye]=t.current,Hn(e),i)for(e=0;e<i.length;e++)n=i[e],a=n._getVersion,a=a(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new Ia(t)};Ce.render=function(e,t,n){if(!ka(t))throw Error(b(200));return Ta(null,e,t,!1,n)};Ce.unmountComponentAtNode=function(e){if(!ka(e))throw Error(b(40));return e._reactRootContainer?(Qt(function(){Ta(null,null,e,!1,function(){e._reactRootContainer=null,e[Ye]=null})}),!0):!1};Ce.unstable_batchedUpdates=Us;Ce.unstable_renderSubtreeIntoContainer=function(e,t,n,i){if(!ka(n))throw Error(b(200));if(e==null||e._reactInternals===void 0)throw Error(b(38));return Ta(e,t,n,!1,i)};Ce.version="18.3.1-next-f1338f8080-20240426";function Sc(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Sc)}catch(e){console.error(e)}}Sc(),Sl.exports=Ce;var lh=Sl.exports,Ic,rl=lh;Ic=rl.createRoot,rl.hydrateRoot;function et(e){return Array.isArray?Array.isArray(e):Mc(e)==="[object Array]"}const uh=1/0;function ch(e){if(typeof e=="string")return e;let t=e+"";return t=="0"&&1/e==-uh?"-0":t}function dh(e){return e==null?"":ch(e)}function ze(e){return typeof e=="string"}function kc(e){return typeof e=="number"}function ph(e){return e===!0||e===!1||hh(e)&&Mc(e)=="[object Boolean]"}function Tc(e){return typeof e=="object"}function hh(e){return Tc(e)&&e!==null}function be(e){return e!=null}function io(e){return!e.trim().length}function Mc(e){return e==null?e===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const mh="Incorrect 'index' type",fh=e=>`Invalid value for key ${e}`,gh=e=>`Pattern length exceeds max of ${e}.`,yh=e=>`Missing ${e} property in key`,vh=e=>`Property 'weight' in key '${e}' must be a positive integer`,ll=Object.prototype.hasOwnProperty;class bh{constructor(t){this._keys=[],this._keyMap={};let n=0;t.forEach(i=>{let a=Ac(i);this._keys.push(a),this._keyMap[a.id]=a,n+=a.weight}),this._keys.forEach(i=>{i.weight/=n})}get(t){return this._keyMap[t]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function Ac(e){let t=null,n=null,i=null,a=1,o=null;if(ze(e)||et(e))i=e,t=ul(e),n=Ko(e);else{if(!ll.call(e,"name"))throw new Error(yh("name"));const s=e.name;if(i=s,ll.call(e,"weight")&&(a=e.weight,a<=0))throw new Error(vh(s));t=ul(s),n=Ko(s),o=e.getFn}return{path:t,id:n,weight:a,src:i,getFn:o}}function ul(e){return et(e)?e:e.split(".")}function Ko(e){return et(e)?e.join("."):e}function _h(e,t){let n=[],i=!1;const a=(o,s,r)=>{if(be(o))if(!s[r])n.push(o);else{let l=s[r];const u=o[l];if(!be(u))return;if(r===s.length-1&&(ze(u)||kc(u)||ph(u)))n.push(dh(u));else if(et(u)){i=!0;for(let f=0,m=u.length;f<m;f+=1)a(u[f],s,r+1)}else s.length&&a(u,s,r+1)}};return a(e,ze(t)?t.split("."):t,0),i?n:n[0]}const wh={includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},qh={isCaseSensitive:!1,ignoreDiacritics:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1},Ch={location:0,threshold:.6,distance:100},xh={useExtendedSearch:!1,getFn:_h,ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1};var T={...qh,...wh,...Ch,...xh};const Sh=/[^ ]+/g;function Ih(e=1,t=3){const n=new Map,i=Math.pow(10,t);return{get(a){const o=a.match(Sh).length;if(n.has(o))return n.get(o);const s=1/Math.pow(o,.5*e),r=parseFloat(Math.round(s*i)/i);return n.set(o,r),r},clear(){n.clear()}}}class Ks{constructor({getFn:t=T.getFn,fieldNormWeight:n=T.fieldNormWeight}={}){this.norm=Ih(n,3),this.getFn=t,this.isCreated=!1,this.setIndexRecords()}setSources(t=[]){this.docs=t}setIndexRecords(t=[]){this.records=t}setKeys(t=[]){this.keys=t,this._keysMap={},t.forEach((n,i)=>{this._keysMap[n.id]=i})}create(){this.isCreated||!this.docs.length||(this.isCreated=!0,ze(this.docs[0])?this.docs.forEach((t,n)=>{this._addString(t,n)}):this.docs.forEach((t,n)=>{this._addObject(t,n)}),this.norm.clear())}add(t){const n=this.size();ze(t)?this._addString(t,n):this._addObject(t,n)}removeAt(t){this.records.splice(t,1);for(let n=t,i=this.size();n<i;n+=1)this.records[n].i-=1}getValueForItemAtKeyId(t,n){return t[this._keysMap[n]]}size(){return this.records.length}_addString(t,n){if(!be(t)||io(t))return;let i={v:t,i:n,n:this.norm.get(t)};this.records.push(i)}_addObject(t,n){let i={i:n,$:{}};this.keys.forEach((a,o)=>{let s=a.getFn?a.getFn(t):this.getFn(t,a.path);if(be(s)){if(et(s)){let r=[];const l=[{nestedArrIndex:-1,value:s}];for(;l.length;){const{nestedArrIndex:u,value:f}=l.pop();if(be(f))if(ze(f)&&!io(f)){let m={v:f,i:u,n:this.norm.get(f)};r.push(m)}else et(f)&&f.forEach((m,p)=>{l.push({nestedArrIndex:p,value:m})})}i.$[o]=r}else if(ze(s)&&!io(s)){let r={v:s,n:this.norm.get(s)};i.$[o]=r}}}),this.records.push(i)}toJSON(){return{keys:this.keys,records:this.records}}}function Pc(e,t,{getFn:n=T.getFn,fieldNormWeight:i=T.fieldNormWeight}={}){const a=new Ks({getFn:n,fieldNormWeight:i});return a.setKeys(e.map(Ac)),a.setSources(t),a.create(),a}function kh(e,{getFn:t=T.getFn,fieldNormWeight:n=T.fieldNormWeight}={}){const{keys:i,records:a}=e,o=new Ks({getFn:t,fieldNormWeight:n});return o.setKeys(i),o.setIndexRecords(a),o}function Ti(e,{errors:t=0,currentLocation:n=0,expectedLocation:i=0,distance:a=T.distance,ignoreLocation:o=T.ignoreLocation}={}){const s=t/e.length;if(o)return s;const r=Math.abs(i-n);return a?s+r/a:r?1:s}function Th(e=[],t=T.minMatchCharLength){let n=[],i=-1,a=-1,o=0;for(let s=e.length;o<s;o+=1){let r=e[o];r&&i===-1?i=o:!r&&i!==-1&&(a=o-1,a-i+1>=t&&n.push([i,a]),i=-1)}return e[o-1]&&o-i>=t&&n.push([i,o-1]),n}const kt=32;function Mh(e,t,n,{location:i=T.location,distance:a=T.distance,threshold:o=T.threshold,findAllMatches:s=T.findAllMatches,minMatchCharLength:r=T.minMatchCharLength,includeMatches:l=T.includeMatches,ignoreLocation:u=T.ignoreLocation}={}){if(t.length>kt)throw new Error(gh(kt));const f=t.length,m=e.length,p=Math.max(0,Math.min(i,m));let g=o,v=p;const _=r>1||l,B=_?Array(m):[];let d;for(;(d=e.indexOf(t,v))>-1;){let w=Ti(t,{currentLocation:d,expectedLocation:p,distance:a,ignoreLocation:u});if(g=Math.min(w,g),v=d+f,_){let S=0;for(;S<f;)B[d+S]=1,S+=1}}v=-1;let c=[],h=1,y=f+m;const q=1<<f-1;for(let w=0;w<f;w+=1){let S=0,E=y;for(;S<E;)Ti(t,{errors:w,currentLocation:p+E,expectedLocation:p,distance:a,ignoreLocation:u})<=g?S=E:y=E,E=Math.floor((y-S)/2+S);y=E;let A=Math.max(1,p-E+1),se=s?m:Math.min(p+E,m)+f,Se=Array(se+2);Se[se+1]=(1<<w)-1;for(let de=se;de>=A;de-=1){let Dt=de-1,zt=n[e.charAt(Dt)];if(_&&(B[Dt]=+!!zt),Se[de]=(Se[de+1]<<1|1)&zt,w&&(Se[de]|=(c[de+1]|c[de])<<1|1|c[de+1]),Se[de]&q&&(h=Ti(t,{errors:w,currentLocation:Dt,expectedLocation:p,distance:a,ignoreLocation:u}),h<=g)){if(g=h,v=Dt,v<=p)break;A=Math.max(1,2*p-v)}}if(Ti(t,{errors:w+1,currentLocation:p,expectedLocation:p,distance:a,ignoreLocation:u})>g)break;c=Se}const I={isMatch:v>=0,score:Math.max(.001,h)};if(_){const w=Th(B,r);w.length?l&&(I.indices=w):I.isMatch=!1}return I}function Ah(e){let t={};for(let n=0,i=e.length;n<i;n+=1){const a=e.charAt(n);t[a]=(t[a]||0)|1<<i-n-1}return t}const da=String.prototype.normalize?e=>e.normalize("NFD").replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g,""):e=>e;class Rc{constructor(t,{location:n=T.location,threshold:i=T.threshold,distance:a=T.distance,includeMatches:o=T.includeMatches,findAllMatches:s=T.findAllMatches,minMatchCharLength:r=T.minMatchCharLength,isCaseSensitive:l=T.isCaseSensitive,ignoreDiacritics:u=T.ignoreDiacritics,ignoreLocation:f=T.ignoreLocation}={}){if(this.options={location:n,threshold:i,distance:a,includeMatches:o,findAllMatches:s,minMatchCharLength:r,isCaseSensitive:l,ignoreDiacritics:u,ignoreLocation:f},t=l?t:t.toLowerCase(),t=u?da(t):t,this.pattern=t,this.chunks=[],!this.pattern.length)return;const m=(g,v)=>{this.chunks.push({pattern:g,alphabet:Ah(g),startIndex:v})},p=this.pattern.length;if(p>kt){let g=0;const v=p%kt,_=p-v;for(;g<_;)m(this.pattern.substr(g,kt),g),g+=kt;if(v){const B=p-kt;m(this.pattern.substr(B),B)}}else m(this.pattern,0)}searchIn(t){const{isCaseSensitive:n,ignoreDiacritics:i,includeMatches:a}=this.options;if(t=n?t:t.toLowerCase(),t=i?da(t):t,this.pattern===t){let _={isMatch:!0,score:0};return a&&(_.indices=[[0,t.length-1]]),_}const{location:o,distance:s,threshold:r,findAllMatches:l,minMatchCharLength:u,ignoreLocation:f}=this.options;let m=[],p=0,g=!1;this.chunks.forEach(({pattern:_,alphabet:B,startIndex:d})=>{const{isMatch:c,score:h,indices:y}=Mh(t,_,B,{location:o+d,distance:s,threshold:r,findAllMatches:l,minMatchCharLength:u,includeMatches:a,ignoreLocation:f});c&&(g=!0),p+=h,c&&y&&(m=[...m,...y])});let v={isMatch:g,score:g?p/this.chunks.length:1};return g&&a&&(v.indices=m),v}}class qt{constructor(t){this.pattern=t}static isMultiMatch(t){return cl(t,this.multiRegex)}static isSingleMatch(t){return cl(t,this.singleRegex)}search(){}}function cl(e,t){const n=e.match(t);return n?n[1]:null}class Ph extends qt{constructor(t){super(t)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(t){const n=t===this.pattern;return{isMatch:n,score:n?0:1,indices:[0,this.pattern.length-1]}}}class Rh extends qt{constructor(t){super(t)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(t){const i=t.indexOf(this.pattern)===-1;return{isMatch:i,score:i?0:1,indices:[0,t.length-1]}}}class Bh extends qt{constructor(t){super(t)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(t){const n=t.startsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,this.pattern.length-1]}}}class Oh extends qt{constructor(t){super(t)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(t){const n=!t.startsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,t.length-1]}}}class Eh extends qt{constructor(t){super(t)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(t){const n=t.endsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[t.length-this.pattern.length,t.length-1]}}}class Fh extends qt{constructor(t){super(t)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(t){const n=!t.endsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,t.length-1]}}}class Bc extends qt{constructor(t,{location:n=T.location,threshold:i=T.threshold,distance:a=T.distance,includeMatches:o=T.includeMatches,findAllMatches:s=T.findAllMatches,minMatchCharLength:r=T.minMatchCharLength,isCaseSensitive:l=T.isCaseSensitive,ignoreDiacritics:u=T.ignoreDiacritics,ignoreLocation:f=T.ignoreLocation}={}){super(t),this._bitapSearch=new Rc(t,{location:n,threshold:i,distance:a,includeMatches:o,findAllMatches:s,minMatchCharLength:r,isCaseSensitive:l,ignoreDiacritics:u,ignoreLocation:f})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(t){return this._bitapSearch.searchIn(t)}}class Oc extends qt{constructor(t){super(t)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(t){let n=0,i;const a=[],o=this.pattern.length;for(;(i=t.indexOf(this.pattern,n))>-1;)n=i+o,a.push([i,n-1]);const s=!!a.length;return{isMatch:s,score:s?0:1,indices:a}}}const Jo=[Ph,Oc,Bh,Oh,Fh,Eh,Rh,Bc],dl=Jo.length,Qh=/ +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,Lh="|";function Nh(e,t={}){return e.split(Lh).map(n=>{let i=n.trim().split(Qh).filter(o=>o&&!!o.trim()),a=[];for(let o=0,s=i.length;o<s;o+=1){const r=i[o];let l=!1,u=-1;for(;!l&&++u<dl;){const f=Jo[u];let m=f.isMultiMatch(r);m&&(a.push(new f(m,t)),l=!0)}if(!l)for(u=-1;++u<dl;){const f=Jo[u];let m=f.isSingleMatch(r);if(m){a.push(new f(m,t));break}}}return a})}const Gh=new Set([Bc.type,Oc.type]);class Dh{constructor(t,{isCaseSensitive:n=T.isCaseSensitive,ignoreDiacritics:i=T.ignoreDiacritics,includeMatches:a=T.includeMatches,minMatchCharLength:o=T.minMatchCharLength,ignoreLocation:s=T.ignoreLocation,findAllMatches:r=T.findAllMatches,location:l=T.location,threshold:u=T.threshold,distance:f=T.distance}={}){this.query=null,this.options={isCaseSensitive:n,ignoreDiacritics:i,includeMatches:a,minMatchCharLength:o,findAllMatches:r,ignoreLocation:s,location:l,threshold:u,distance:f},t=n?t:t.toLowerCase(),t=i?da(t):t,this.pattern=t,this.query=Nh(this.pattern,this.options)}static condition(t,n){return n.useExtendedSearch}searchIn(t){const n=this.query;if(!n)return{isMatch:!1,score:1};const{includeMatches:i,isCaseSensitive:a,ignoreDiacritics:o}=this.options;t=a?t:t.toLowerCase(),t=o?da(t):t;let s=0,r=[],l=0;for(let u=0,f=n.length;u<f;u+=1){const m=n[u];r.length=0,s=0;for(let p=0,g=m.length;p<g;p+=1){const v=m[p],{isMatch:_,indices:B,score:d}=v.search(t);if(_){if(s+=1,l+=d,i){const c=v.constructor.type;Gh.has(c)?r=[...r,...B]:r.push(B)}}else{l=0,s=0,r.length=0;break}}if(s){let p={isMatch:!0,score:l/s};return i&&(p.indices=r),p}}return{isMatch:!1,score:1}}}const es=[];function zh(...e){es.push(...e)}function ts(e,t){for(let n=0,i=es.length;n<i;n+=1){let a=es[n];if(a.condition(e,t))return new a(e,t)}return new Rc(e,t)}const pa={AND:"$and",OR:"$or"},ns={PATH:"$path",PATTERN:"$val"},is=e=>!!(e[pa.AND]||e[pa.OR]),Wh=e=>!!e[ns.PATH],Uh=e=>!et(e)&&Tc(e)&&!is(e),pl=e=>({[pa.AND]:Object.keys(e).map(t=>({[t]:e[t]}))});function Ec(e,t,{auto:n=!0}={}){const i=a=>{let o=Object.keys(a);const s=Wh(a);if(!s&&o.length>1&&!is(a))return i(pl(a));if(Uh(a)){const l=s?a[ns.PATH]:o[0],u=s?a[ns.PATTERN]:a[l];if(!ze(u))throw new Error(fh(l));const f={keyId:Ko(l),pattern:u};return n&&(f.searcher=ts(u,t)),f}let r={children:[],operator:o[0]};return o.forEach(l=>{const u=a[l];et(u)&&u.forEach(f=>{r.children.push(i(f))})}),r};return is(e)||(e=pl(e)),i(e)}function Xh(e,{ignoreFieldNorm:t=T.ignoreFieldNorm}){e.forEach(n=>{let i=1;n.matches.forEach(({key:a,norm:o,score:s})=>{const r=a?a.weight:null;i*=Math.pow(s===0&&r?Number.EPSILON:s,(r||1)*(t?1:o))}),n.score=i})}function Vh(e,t){const n=e.matches;t.matches=[],be(n)&&n.forEach(i=>{if(!be(i.indices)||!i.indices.length)return;const{indices:a,value:o}=i;let s={indices:a,value:o};i.key&&(s.key=i.key.src),i.idx>-1&&(s.refIndex=i.idx),t.matches.push(s)})}function jh(e,t){t.score=e.score}function Zh(e,t,{includeMatches:n=T.includeMatches,includeScore:i=T.includeScore}={}){const a=[];return n&&a.push(Vh),i&&a.push(jh),e.map(o=>{const{idx:s}=o,r={item:t[s],refIndex:s};return a.length&&a.forEach(l=>{l(o,r)}),r})}class bn{constructor(t,n={},i){this.options={...T,...n},this.options.useExtendedSearch,this._keyStore=new bh(this.options.keys),this.setCollection(t,i)}setCollection(t,n){if(this._docs=t,n&&!(n instanceof Ks))throw new Error(mh);this._myIndex=n||Pc(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(t){be(t)&&(this._docs.push(t),this._myIndex.add(t))}remove(t=()=>!1){const n=[];for(let i=0,a=this._docs.length;i<a;i+=1){const o=this._docs[i];t(o,i)&&(this.removeAt(i),i-=1,a-=1,n.push(o))}return n}removeAt(t){this._docs.splice(t,1),this._myIndex.removeAt(t)}getIndex(){return this._myIndex}search(t,{limit:n=-1}={}){const{includeMatches:i,includeScore:a,shouldSort:o,sortFn:s,ignoreFieldNorm:r}=this.options;let l=ze(t)?ze(this._docs[0])?this._searchStringList(t):this._searchObjectList(t):this._searchLogical(t);return Xh(l,{ignoreFieldNorm:r}),o&&l.sort(s),kc(n)&&n>-1&&(l=l.slice(0,n)),Zh(l,this._docs,{includeMatches:i,includeScore:a})}_searchStringList(t){const n=ts(t,this.options),{records:i}=this._myIndex,a=[];return i.forEach(({v:o,i:s,n:r})=>{if(!be(o))return;const{isMatch:l,score:u,indices:f}=n.searchIn(o);l&&a.push({item:o,idx:s,matches:[{score:u,value:o,norm:r,indices:f}]})}),a}_searchLogical(t){const n=Ec(t,this.options),i=(r,l,u)=>{if(!r.children){const{keyId:m,searcher:p}=r,g=this._findMatches({key:this._keyStore.get(m),value:this._myIndex.getValueForItemAtKeyId(l,m),searcher:p});return g&&g.length?[{idx:u,item:l,matches:g}]:[]}const f=[];for(let m=0,p=r.children.length;m<p;m+=1){const g=r.children[m],v=i(g,l,u);if(v.length)f.push(...v);else if(r.operator===pa.AND)return[]}return f},a=this._myIndex.records,o={},s=[];return a.forEach(({$:r,i:l})=>{if(be(r)){let u=i(n,r,l);u.length&&(o[l]||(o[l]={idx:l,item:r,matches:[]},s.push(o[l])),u.forEach(({matches:f})=>{o[l].matches.push(...f)}))}}),s}_searchObjectList(t){const n=ts(t,this.options),{keys:i,records:a}=this._myIndex,o=[];return a.forEach(({$:s,i:r})=>{if(!be(s))return;let l=[];i.forEach((u,f)=>{l.push(...this._findMatches({key:u,value:s[f],searcher:n}))}),l.length&&o.push({idx:r,item:s,matches:l})}),o}_findMatches({key:t,value:n,searcher:i}){if(!be(n))return[];let a=[];if(et(n))n.forEach(({v:o,i:s,n:r})=>{if(!be(o))return;const{isMatch:l,score:u,indices:f}=i.searchIn(o);l&&a.push({score:u,key:t,value:o,idx:s,norm:r,indices:f})});else{const{v:o,n:s}=n,{isMatch:r,score:l,indices:u}=i.searchIn(o);r&&a.push({score:l,key:t,value:o,norm:s,indices:u})}return a}}bn.version="7.1.0";bn.createIndex=Pc;bn.parseIndex=kh;bn.config=T;bn.parseQuery=Ec;zh(Dh);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var Hh={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $h=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase().trim(),Fc=(e,t)=>{const n=ve.forwardRef(({color:i="currentColor",size:a=24,strokeWidth:o=2,absoluteStrokeWidth:s,className:r="",children:l,...u},f)=>ve.createElement("svg",{ref:f,...Hh,width:a,height:a,stroke:i,strokeWidth:s?Number(o)*24/Number(a):o,className:["lucide",`lucide-${$h(e)}`,r].join(" "),...u},[...t.map(([m,p])=>ve.createElement(m,p)),...Array.isArray(l)?l:[l]]));return n.displayName=`${e}`,n};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hl=Fc("Search",[["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}],["path",{d:"m21 21-4.3-4.3",key:"1qie3q"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Yh=Fc("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]),Kh=""+new URL("switcher-CaaC6x9B.svg",import.meta.url).href,Jh=""+new URL("docs-BGLm6Xpv.svg",import.meta.url).href,em=""+new URL("academy-DLOT8zSY.svg",import.meta.url).href,tm=""+new URL("resonance-Du6ePxdd.svg",import.meta.url).href,nm=""+new URL("support-rYw0KIxl.svg",import.meta.url).href,im=()=>{const[e,t]=ve.useState(!1),n=()=>{t(!e)};return k.jsxs("div",{className:"flex items-center pt-2 w-56 p-0",children:[k.jsx("button",{className:"cursor-pointer p-0 border-none bg-transparent",onClick:n,children:k.jsx("img",{className:"title-image cursor-pointer",alt:"IQM Docs Application Switcher",src:Kh,height:50,width:176,style:{maxWidth:"fit-content",height:"50px",width:"176px"}})}),e&&k.jsxs("div",{className:"absolute mt-[12em] bg-white w-44 rounded-lg p-1 pt-1 z-50",children:[k.jsx("div",{children:k.jsx("a",{href:"/","aria-label":"IQM Docs",target:"_blank",children:k.jsx("img",{className:"switcher-title-image hover:filter hover:contrast-[.90]",alt:"IQM Academy",src:Jh,height:40,width:176})})}),k.jsx("div",{children:k.jsx("a",{href:"https://academy.meetiqm.com",target:"_blank","aria-label":"IQM Academy",children:k.jsx("img",{className:"switcher-title-image hover:filter hover:contrast-[.90]",alt:"IQM Academy",src:em,height:40,width:176})})}),k.jsx("div",{children:k.jsx("a",{href:"https://resonance.meetiqm.com",target:"_blank",rel:"noreferrer","aria-label":"IQM Resonance",children:k.jsx("img",{className:"switcher-title-image hover:filter hover:contrast-[.90]",alt:"IQM Resonance",src:tm,height:40,width:176})})}),k.jsx("div",{children:k.jsx("a",{href:"https://support.meetiqm.com",target:"_blank",rel:"noreferrer","aria-label":"IQM Support",children:k.jsx("img",{className:"switcher-title-image hover:filter hover:contrast-[.90]",alt:"IQM Support",src:nm,height:40,width:176})})})]})]})},ao=[{package:"iqm-pulse",title:"Using ScheduleBuilder",url:"/iqm-pulse/using_builder.html",description:`This section describes how to use ScheduleBuilder to compose pulse schedules.
ScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their
topolog...`,content:`This section describes how to use ScheduleBuilder to compose pulse schedules.
ScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their
topology, and control channel properties. In the context of IQM Pulla and EXA, an instance of ScheduleBuilder is given by the framework,
and it contains all the necessary information to execute against a particular quantum computer instance.
Here, we assume that user has an instance of ScheduleBuilder builder to work with. A typical workflow begins with calling get_implementation() with the name of a desired QuantumOp and the locus
for the operation.
The locus is the logical target of the operation, usually a sequence of qubits or computational resonators.
This outputs a an instance of GateImplementation , which is capable of producing TimeBoxes with the correct
calibration for that locus. For example, here we ask for the GateImplementation of prx , cz , and measure , all of which are standard
gates recognized by IQM Pulse, for qubits QB1 and QB3 .
Any gate which is registered in the runtime can be requested this way. Notice how the number of qubits matches the operation: CZ acts on 2 qubits, while PRX acts on only one.
Measure can act on any number of qubits. There might be several available implementations for an operation. get_implementation gives the implementation that is set as the default, unless a specific implementation is
requested with a keyword argument. To instantiate some concrete TimeBoxes, we call time implementation with the logical parameters of the operations, as
defined by the QuantumOps.
PRX has 2 parameters: the 2 angles of a phased rotation.
CZ does not have any parameters. One important method is the wait() , which blocks the control channels of the given components for a certain time: In all of the examples above, the TimeBoxes are atomic, which can be organized into composite TimeBoxes to decide
their relative order. TimeBoxes can be concatenated with the following rules: Addition ( + ) concatenates the children of the operands into a single TimeBox.
Use addition to allow gates on disjoint loci to execute simultaneously, for example doing a PRX on all qubits. The pipe operation ( | ) groups two TimeBoxes together without concatenating.
This results in composite TimeBox with two children, the operands, which are scheduled separately.
Use the pipe to ensure that certain operations execute before some others. Iterables of TimeBoxes are treated as the sum of the elements. This would execute 2 PRX gates on QB1 and QB2 simultaneously: If the last operator was | instead, the second gate on QB2 would execute only after the first 3 gates. Together, these rules provide a handy way of defining complex circuits easily: A TimeBox are made atomic by resolving it using ScheduleBuilder.resolve_timebox() .
When using a framework like IQM Pulla or Exa, the framework will take care of the resolving as part of compilation,
so the user does not need to do it explicitly. TimeBoxes are resolved recursively: The children of a TimeBox are resolved, and resulting (sub-)Schedules are aligned
according to the SchedulingStrategy (ASAP or ALAP) of the TimeBox.
The time duration of a TimeBox is determined by its contents and the way they are scheduled during the resolution.
Finally, all channels are padded with Waits so that the total duration of Instructions on every channel is equal.
In other words, the Schedule becomes a “rectangle”. An important part of the scheduling are the blocking rules, that is, whether the contents of two TimeBoxes block or
slide past each other.
The rules are: An atomic TimeBox is considered to act on a component if it has instructions on any of the non-virtual channels
related to that component. A composite TimeBox acts on the union of its children’s locus components. A TimeBox blocks all channels related to any component it acts on. When scheduling two TimeBoxes, the instructions will not overlap in time if the TimeBoxes block overlapping channels. In addition to blocking the channels actually present in a TimeBox, it is possible to block neighbouring channels
as well (for example in order to limit cross-talk).
The applied neighbourhood is specified in ScheduleBuilder.resolve_timebox() .
The neighbourhood is defined as an integer such that 0 means “block only the involved channels”,
1 means “block the involved channels and the channels of any neighbouring couplers”,
2 means “the same as in (1) but in addition block all channels connected by those couplers”, and so on.
The blocking rules do not add actual Wait or Block instructions are added to the neighbourhood channels, and two
overlapping neighbourhoods do not block each other.
The blocking comes in question only when actual content would be added to those neighbourhood channels. In practice, the rules and default GateImplementations ensure that the user can concatenate arbitrary gates
without worrying that the gates have an adverse effect on each other.
For example, the pulse of a PRX gate playing at the same time as a CZ gate or a measurement would ruin both operations.
If overlapping of such gates is desired, the best way is to arrange the Instructions on the Schedule level and wrap the
schedule into an atomic TimeBox. Note Virtual channels are special channels that exist only to aid the scheduling algorithm.
Examples are tracking the phases of the MOVE gate, and timing of fast feedback.
These channels are removed when the Playlist is finalized. You are encouraged to discover the many features of ScheduleBuilder and TimeBox by reading the
API: ScheduleBuilder , TimeBox . A quick reference of selected features is provided in the examples below. Finding information about the target system: Working with TimeBoxes: Some typical errors that are easy to make with the syntax: Not calling the implementation to get a TimeBox. The call is easy to forget especially if there are no parameters
to give: Giving a single component as locus: previous Concepts and Classes next Custom gate implementations © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Pulse timing",url:"/iqm-pulse/pulse_timing.html",description:`The ReadoutTrigger Instruction responsible of qubit readout has several
timing-related attributes.
The measure.constant gate implementation produces the lower-level ReadoutTrigger instruction
from a s...`,content:`The ReadoutTrigger Instruction responsible of qubit readout has several
timing-related attributes.
The measure.constant gate implementation produces the lower-level ReadoutTrigger instruction
from a simplified set of settings.
The figure below shows how the settings relate to the more flexible attributes of the instruction. With conditional Instructions, we specify how the information from readout operations should affect Instructions at
runtime.
Usually, the goal is use the information as soon as possible, but it takes a finite time to propagate from the
acquisition unit to the drive channels that execute the Instructions conditionally. Note On all hardware supported by IQM QCCSW, ConditionalInstruction reads the signal bit at the time of
excution, regardless of when the signal bit was last updated.
This means that if the Conditionalinstruction is executed too early, the condition will be executed based on the
previous state of the bit. To facilitate efficient timing of the feedback signals, IQM Pulse uses virtual channels between probeline channels
(the source of the signals) and drive channels (the destinations).
Block instructions on the virtual channel represent the travel time of the signals. CCPRX_Composite is GateImplementation of the cc_prx (classically controlled PRX) that outputs two
TimeBoxes:
the first one to represent the travel time, and the second one with the actual ConditionalInstruction .
In typical use, both should be scheduled in the same order, to ensure the Conditionalinstrucion starts when the
signal bit is available. The following image illustrates how the TimeBoxes are used for qubits QB2 and QB3 .
For QB2, this is also how Reset_Conditional implements the reset operation. The equaivalent code would be Instructions are spaced out in time only for visual clarity. When scheduled ASAP, they would be left-aligned
such that the ConditionalInstructions start right after the associated control_delay has passed. The bottom of the image illustrates an alternative use of CCPRX_Composite to have more freedom in the timing.
There, the optional delay TimeBox is not used for scheduling the Instructions on QB4.
Instead, the user has ensured that the other instructions take enough time for the signal to arrive.
This could be used to act on the previous feedback signal (not shown). Note This section is not about IQM Pulse itself, but might help in understanding the details of the execution. The image below shows a typical timing of a Playlist segment with 2 AWG devices for driving, and a readout instrument.
Here, all statements that apply to an AWG apply to readout instruments as well.
The AWGs can output an arbitrary sequence of pulses, and the readout instrument can additionally read out
the response to the pulses. With readout, the raw signal response from the readout pulse will be integrated to produce a single number, such as a
complex number or a bit, corresponding to a particular qubit in a particular segment. In the figure, one of the AWGs has been selected as the trigger master, which means it sends trigger pulses to
start the execution on the slave devices.
As shown in the picture, different delays caused by the travel time of signals can be compensated for by
adjusting the trigger_delay setting of each device. Settings in the figure that can be adjusted by user in the higher level libraries: Setting Explanation <awg>.trigger_delay Wait time between the end of the trigger signal of the AWG master and the beginning of the pulse sequence. <awg>.trigger_delay (slave) Wait time between receiving the trigger signal at the AWG slave and the beginning of the pulse sequence. options.end_delay Wait time between the end of the pulse segment and the next trigger. <gate>.<implementation>.<locus>.duration The duration of the hardware instruction for a gate, possibly rounded to satisfy granularity constraints.
For the ReadoutTrigger instruction, the meaning is different, see below. Other notes: The AWG spcecified by options.trigger_master is the only channel that does not wait for a trigger
at the start of a segment. Slave AWGs may also emit a trigger pulse to allow daisy chaining trigger signals. Systems with IQM Control System are triggered centrally and the channels run independently, and the options.trigger_master has no effect. Pipeline delays are delays between the execution of a command and the pulse actually getting outputted
from a device. This delay is caused by the hardware and cannot be changed.
In practice, it can be thought as being part of the cable delays, and thus can be compensated with trigger_delay setting. previous Custom gate implementations next API Reference © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"References",url:"/iqm-pulse/references.html",description:"John M. Martinis and Michael R. Geller. Fast adiabatic qubit gates using only $\\sigma _z$ control. Phys. Rev. A , 90:022307, Aug 2014. arXiv:1402.5467 , doi:10.1103/PhysRevA.90.022307 . R. G. Lyons. U...",content:"John M. Martinis and Michael R. Geller. Fast adiabatic qubit gates using only $\\sigma _z$ control. Phys. Rev. A , 90:022307, Aug 2014. arXiv:1402.5467 , doi:10.1103/PhysRevA.90.022307 . R. G. Lyons. Understanding Digital Signal Processing . Prentice Hall, 2nd edition, 2004. ISBN 978-0131089891. Cecilia Gisele Jarne. A heuristic approach to obtain signal envelope with a simple software implementation. ANALES AFA , 29(2):51–57, 2018. arXiv:1703.06812 , doi:10.31527/analesafa.2018.29.2.51 . Eyob A. Sete, Nicolas Didier, Angela Q. Chen, Shobhan Kulshreshtha, Riccardo Manenti, and Stefano Poletto. Parametric-resonance entangling gates with a tunable coupler. Phys. Rev. Appl. , 16:024050, Aug 2021. arXiv:2104.03511 , doi:10.1103/PhysRevApplied.16.024050 . Youngkyu Sung, Leon Ding, Jochen Braumüller, Antti Vepsäläinen, Bharath Kannan, Morten Kjaergaard, Ami Greene, Gabriel O. Samach, Chris McNally, David Kim, Alexander Melville, Bethany M. Niedzielski, Mollie E. Schwartz, Jonilyn L. Yoder, Terry P. Orlando, Simon Gustavsson, and William D. Oliver. Realization of high-fidelity CZ and ZZ-free iSWAP gates with a tunable coupler. Phys. Rev. X , 11:021058, Jun 2021. arXiv:2011.01261 , doi:10.1103/PhysRevX.11.021058 . previous Changelog next License © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"Concepts and Classes",url:"/iqm-pulse/concepts.html",description:"This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some con...",content:`This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some control channels connected to it. Control channels deliver physical control pulses
to the QPU. Quantum operations have a locus , which is the set of quantum information carrying components
(qubits and resonators) the operation acts on.
One operation may involve sending pulses to multiple control channels. The assembly of a Playlist, or a batch of quantum circuits, can be summarized as follows: A Playlist contains multiple independent segments , to be executed as a batch. A segment is a conceptual unit at a time scale where the quantum information of the QPU can be
assumed to be preserved. A quantum circuit corresponds to one segment. What is executed during a segment is determined by a Schedule . A Schedule is a set of hardware control channels, each with a strictly timed sequence of Instructions . A Schedule is formed by scheduling a Timebox . A TimeBox can contain other TimeBoxes without precise relative timing,
or it can be atomic, in which case it contains a single Schedule . The image below illustrates how a Playlist of two segments is formed from TimeBoxes. Hardware instructions are the lowest-level construct visible on the client side.
Instructions are a set of atomic, real-time execution commands for the control hardware supported by IQM.
They work in a time scale where the quantum information of the QPU can be assumed to be preserved.
Examples of Instructions are IQPulse to play a microwave pulse on a channel, VirtualRZ to adjust the modulation phase, ReadoutTrigger to acquire measurement data,
and Wait to delay the next Instruction for a given time.
See iqm.pulse.playlist.instructions for the complete list. During execution, each hardware control channel executes its own sequence of Instructions.
Each Instruction blocks the next until it is completed.
Instructions are as explicit as possible, so that there is no ambiguity on what will be executed when.
IQM Station control transforms Instructions to machine-specific commands. All Instructions have a duration, measured in samples, though the duration can be zero.
The durations are subject to hardware-specific granularity constraints.
For example, some hardware might require all instructions to be a multiple of 16 samples long, with a minimum of 32.
Instructions violating the granularity constraints will raise an error.
However, a typical user does not need to concern themselves about the constraints, as
the gate implementations and IQM Pulse’s scheduling ensures the constraints are respected.
The philosophy is that Station Control, which is inaccessible to the user, does not attempt to do any smart
“magic” to fix inconsistencies in the user’s input, it simply executes the Playlist it is given.
Instead, the magic happens on the client side so that it is transparent to the user. Note For technical reasons, IQM Pulse mostly uses classes from iqm.pulse.playlist.instructions , but when
finalizing the output, the instructions are converted to iqm.models.playlist.instructions .
These two class families are semantically equivalent, apart from a few exceptions like Block which
only exists on the client side to help with scheduling. Schedule contains a number of control channels, each with a lists of Instructions.
All channels in a Schedule start executing at the same instant, and the timing is defined by the duration of the
individual Instructions.
Schedules can be thought of as a fixed block that occupies some interval on a timeline of some channels. Schedules appear in two contexts: gate implementations and as complete segments.
For example, when an implementation of a PRX gate is requested,
a small Schedule involving the drive channel of a single qubit is created.
When all the desired gates in a circuit have been scheduled by concatenating the gate-schedules together,
the end result, a segment, is a large Schedule occupying all necessary channels.
A typical segment starts with initializing the qubits and ends with reading out their state. Whereas a Schedule is a container with strict relative timing, a TimeBox is a container with undefined
relative timing.
Each TimeBox can be labeled using a human-readable label describing it, and operates on a number
of locus components , using some of their control channels.
A composite TimeBox contains other TimeBoxes as children, whereas atomic TimeBoxes contain a Schedule. TimeBoxes are the main language in which users define the order and relative alignment of execution elements, be it
gates, Schedules, or larger TimeBoxes. A key process is the scheduling, in which TimeBoxes are resolved recursively into a fixed Schedule.
When resolving, all Schedules inside the TimeBox are concatenated and are either left-aligned (ASAP) or right-aligned
(ALAP), respecting the hardware constraints.
Importantly, if some TimeBoxes have content on disjoint channels, the Schedules are allowed to happen simultaneously.
If they have content on partly overlapping channels, the Schedules are concatenated while preserving their internal
timing.
Any interval that does not have explicit instructions is filled with Wait Instructions.
The figure above demonstrates how TimeBoxes are resolved. The syntax and rules are explained in more detail in Using ScheduleBuilder . A higher-level concept, a QuantumOp can represent a unitary quantum gate,
or for example a measurement operation (not all QuantumOps necessarily represent a unitary gate).
QuantumOps are simple, abstract, self-contained actions one can execute on a station as parts of a quantum circuit.
They include quantum gates like PRX, CZ, and measurements and resets.
Whereas Schedules and Instructions act on control channels, QuantumOps act on named components on the QPU, such as
qubits or computational resonators. A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the
QPU component, but it can be implemented in various ways.
Each implementation is represented as a GateImplementation. The list of available QuantumOps at runtime can be obtained with iqm.pulse.builder.build_quantum_ops() .
A new QuantumOp can be registered at runtime, together with an implementation, with iqm.pulse.gates.register_implementation() . A GateImplementation bridges the gap between QuantumOps and TimeBoxes.
When a user requests a QuantumOp from ScheduleBuilder with specific parameters and locus components, the
chosen GateImplementation (usually the default) for the operation is used to produce a TimeBox.
This TimeBox, usually atomic, contains a Schedule on the appropriate control channels.
The Instructions within are constructed following the calibration values from the ScheduleBuilder. All gate implementations are listed in iqm.pulse.gates .
Section Custom gate implementations explains how to add more implementations. Once all TimeBoxes are scheduled into large Schedules, one for each segment/circuit,
the Schedules are collected into a Playlist .
The Playlist is the final product that is sent to Station Control.
Its contents are compressed by indexing all unique Instructions and waveforms on each channel,
and representing the control channels in each segment as lists of Instruction indices. During execution, the segments in the Playlist are executed in order, and the whole sequence is repeated
a number of times equal to the number of repetitions (shots). Segments are separated in time by end delay , a parameter outside the Playlist.
A long end delay can be used to prevent quantum information carrying from one segment to the next,
thus resetting the qubits.
Alternatively, the reset can be encoded in each segment as a long Wait instruction or using some active reset scheme. Station Control aims to execute all segments together, but sometimes this is not possible due to various memory
constraints.
In case the whole Playlist does not fit in memory, the segments are split into chunks which are executed separately.
The delay between chunks is undefined.
Therefore, the time between segments is guaranteed to be at least the duration of the end delay, but can be much larger. inspect_playlist() provides a neat visual representation of the playlist, as blocks of instructions on a
timeline. previous IQM Pulse next Using ScheduleBuilder © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"API Reference",url:"/iqm-pulse/API.html",description:"iqm.pulse Control pulses and pulse sequences for quantum processors. previous Pulse timing next pulse © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04....",content:"iqm.pulse Control pulses and pulse sequences for quantum processors. previous Pulse timing next pulse © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"IQM Pulse",url:"/iqm-pulse/index.html",description:`7.19 2025-02-04 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations
to a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is an ...`,content:`7.19 2025-02-04 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations
to a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is an abstract mathematical construct which conveniently hides all implementation
details such as the timing of microwave pulses, waveform shapes, sampling rates, signal capture, and so on.
But in order to execute a circuit you need to convert it into a schedule of hardware instructions which involve
all of the above. IQM Pulse provides a framework for defining abstract quantum gates/operations, as well as their concrete implementations in terms of hardware instructions machinery to easily construct circuit-level gate sequences, and compile them into instruction schedules. a set of ready-made gates with implementations. IQM Pulse is not a standalone tool, but is used in IQM’s client libraries, IQM Pulla and Exa.
To use them effectively, you are encouraged to familiarize yourself with IQM Pulse, especially the most common
concepts. Index Module Index Search Page next Concepts and Classes © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Custom gate implementations",url:"/iqm-pulse/custom_gates.html",description:`Quantum gates are represented by QuantumOp data classes, containing the required
metadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the o...`,content:`Quantum gates are represented by QuantumOp data classes, containing the required
metadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the operation acts on. For example,
the PRX operation (Phased X Rotation) is a single-qubit operation, so its arity is 1, whereas the CZ (Controlled-Z) gate
acts on two qubits, having arity 2. Arity 0 has a special meaning that the operation in question can act on any number
of components (for example Barrier ). The attribute symmetric defines whether the effect of the quantum operation
is symmetric with respect to changing the order of its locus components. As an example, the CZ gate is a symmetric
two-qubit gate, whereas CNOT (Controlled-NOT) is not symmetric. Some quantum operations are defined as “functions”, taking one or more parameters to define the effect. These
arguments are stored in the attribute params . As an example, the PRX gate
takes two arguments, angle (the rotation angle with respect to the z-axis of the Bloch sphere), and phase (the rotation phase in the rotating frame). On the other hand, many operations do not require any parameters, in
which case this field is an empty tuple (e.g. the CZ gate). A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the
QPU component, but it can be implemented in various ways. Each implementation is represented as a GateImplementation subclass. A QuantumOp stores its known implementations in the
field implementations . Note that even though QuantumOp is a frozen data class, the implementations dictionary can be modified, e.g.
to add new implementations or to change their order (usually programmatically by some client procedure, but nothing as
such prevents the user from manipulating the contents manually). The default implementation is how the user prefers
to implement the operation unless otherwise specified (in effect, this is what will get called in most cases the
operation is invoked). In the implementations dict, the default implementation is defined as the first entry.
QuantumOp contains helpful methods that allow setting and returning the default implementation for specific cases: set_default_implementation() , get_default_implementation_for_locus() , and set_default_implementation_for_locus() . The attribute unitary stores a function that can be used to get the unitary
matrix representing the quantum operation in question. The unitary function must have the same arguments
as defined in params , such that for each collection of these parameters it
gives the associated unitary matrix. Note that not all QuantumOps necessarily even represent a unitary gate (e.g.
the measure operation is not one), or the exact form of the unitary matrix might not be known. In these cases, the
field can be left None . The unitary does not need to be defined for most of the basic usage of a QuantumOp, but certain
algorithmic methods (e.g. some implementations of Randomized Benchmarking) may require the unitary matrices to be known,
and such operations that do not define the getter function cannot then be used in these contexts. For more information, see the API docs of QuantumOp for the full list of fields needed
to define a quantum operation and the available class methods. While QuantumOp represents an abstract quantum operation, its implementations contain
the concrete logic of how to make that operation happen using QC hardware. Gate implementations are subclasses of GateImplementation . In this section, the main features of that class are
introduced (for a full list of class methods see the API docs), with the emphasis being on how to create your own
gate implementations. Starting with __init__() , it is important to note that the init
methods of all gate implementations must have the exact same signature: Here, parent is the QuantumOp this gate implementation implements, and name is the implementation’s name in
the dictionary implementations . locus is the set of (usually logical) components
the QuantumOp acts on (the size of the locus must be consistent with the parent ’s arity ), while calibration_data gives the required calibration data values
for this implementation and locus (can be empty in case the implementation needs no calibration data). Finally,
The implementations store a reference to the ScheduleBuilder that created it. This is
because GateImplementations are practically never created manually by calling the init method itself. Instead, one
needs a builder and uses get_implementation() . The responsibility of the init method is to (at least) store the calibration_data provided from the builder for
further use, but in many cases, one might want to create some intermediate objects like pulses or instructions from that calibration data already at this point. Note that ScheduleBuilder caches its GateImplementations per each locus and calibration_data , so as long as the calibration is not changed, the code in init will be called just once per locus. GateImplementations are Callables, i.e. they implement the __call__ method. It should take as its arguments at least
the QuantumOpt parameters defined for the parent in params , but in
addition it may have optional extra arguments. The call method should return a TimeBox object
that contains the pulses, instructions and other logic required to implement the quantum operation in question. The
typical usage of gate implementations then looks like this (See Using ScheduleBuilder and Pulse timing for more
info on scheduling and the ScheduleBuilder): The base class __call__() method does automatic TimeBox caching based
on the unique values of the call arguments, and in many cases, one does not want to reimplement this caching in their own
implementations. For this reason, there is the method _call which contains just the pure TimeBox creation logic.
Developers can choose to override that instead of __call__ in cases where the call args are hashable python types,
and then they can utilize the default caching of TimeBoxes from the base class. When writing a GateImplementation, a developer should consider what parts of the logic should go to the class init and
what to the __call__ or _call method. A general rule of thumb would be that any parts that can be precomputed
and do not depend on the call arguments can go to init, and the rest to call. As an example, let’s go through a simple PRX _call method (note that the default PRX implementations do not
use this exact call method, as this is a simplified example for educational purposes): Here, we first create an IQPulse object which is a low-level Instruction. IQPulse
means a “complex pulse” which has two orthogonal components i and q – this what drive pulses look like in general. In
this simplified example, we have hardcoded the pulse waveforms into TruncatedGaussian and TruncatedGaussianDerivative for the i and q components, respectively (this is a DRAG implementation, so the
q component is the derivative of the i component). The waveforms are parametrized by the calibration_data for the
given locus (see the next subsection for more info on Waveforms and calibration data). The PRX QuantumOp param angle scales the pulse amplitude linearly (the waveforms are normalized to one), and the param phase defines relative
phase modulation. Then the returned TimeBox is created out of the instruction . Note that
since we override _call here, instead of __call__ , so this implementation would utilize the default base class
caching such that the TimeBoxes are cached per unique values of (angle, phase) . Another important concept is a the so called locus mapping of a gate implementation. Locus mappings define on which
loci, i.e. groups of components, a given implementation can be defined. They are used to relay the information which
loci are supported to a client application (e.g. EXA). In addition, the gate implementation itself can programmatically
use this information self.builder.chip_topology . For example, a PRX can be defined on all single components that are connected to a drive line, and CZ can be defined on
connected pairs of qubits. Locus mappings live in ScheduleBuilder.chip_topology which is a ChipTopology object. Locus mapping is a dict whose keys are the loci
( tuple[str, ...] keys denote asymmetric loci where the order of the components matter, and frozenset[str] type
loci denote symmetric ones), and the values are groups of components, typed tuple[str, ...] , where each locus can be
mapped with some additional components that are needed for the operation of the implementation. For example, some CZ
implementation that tries to correct for crosstalk could map the non-locus components that see this crosstalk here.
The values of the dict can be left empty or just replicate the key components in case such extra information is not
needed. GateImplementations can define their locus mappings via get_custom_locus_mapping() or if a client application already
adds the mapping, we can just return its name via get_locus_mapping_name() .
If neither of these methods are overridden in a GateImplementation class, the default behaviour will be such that an arity==1 loci will be assumed to use the mapping where all single qubits are the keys, and arity==2 loci the
(symmetric) mapping where the keys are all pairs of connected qubits. For other arities there is no default behaviour,
so it is then mandatory to define the mapping explicitly using the aforementioned methods. In order to implement most QuantumOps, one has to physically alter the state of the QPU. This is typically done by playing
specified and correctly calibrated pulses via the control electronics (this applies to all typical logical gates such as
e.g. PRX or CZ – non-physcial metaoperations such as Barrier are an exception). In defining these pulses, there are two
levels of abstractions: Waveform and Instruction . Waveform represents the physical form of the control pulse, typically normalized to the interval [-1.0, 1.0] . The
Each Waveform subclass can define any number of waveform parameters as class
attributes, which can be used to programmatically define the waveform. For example, a Gaussian could be defined in terms
of the average mu and spread sigma . A Waveform class then essentially contains just the parameters
and a recipe for computing the samples as an np.ndarray . As an example, here is how one writes the Waveform class
for Gaussian : The Instructions RealPulse and IQPulse allow handling the amplitudes (via the attribute scale ) without
having to resample the waveform for every different amplitude value. However, one can always choose to include
the amplitude into the sampling and then use scale=1 . The waveform parameters (like sigma in the above Gaussian) typically require calibration when the Waveform is used
in a quantum gate. However, the GateImplementation usually has other calibrated parameters as well defined in the
implementation itself. As an example, here are the implementation-level parameters of the default PRX implementation,
defined as class attribute: Note the amplitudes are defined here on this level, since the default PRX uses normalized Waveforms and factors in the
amplitudes via scale . In these parameters, the unit is not just metadata. The control electronics understand time
in terms of samples and their sample rate, while human users typically want to input seconds instead of doing the sample
conversion manually. For this reason, there is logic that converts anything that has the unit "s" into samples.
Similarly, parameters with "Hz" units are converted to 1/sample . For the Waveform parameters, the same logic
applies, but by default it is assumed that all parameters are time-like and this converted from seconds to samples.
If some Waveform parameters needs to be made unitless or e.g. frequency-like (with "Hz" units), it can be achieved
with the method non_timelike_attributes() : In the above dict, the keys should be the attribute names and values their units. To make creating new GateImplementations more comfortable, there are additional base classes on top of GateImplementation itself. CompositeGate allows quick implementation of gates in terms of other gates,
using a similar syntax as with creating/scheduling several TimeBoxes together (see Using ScheduleBuilder ). At it
simplest, a ComposteGate is just the _call method: Here, one could use also builder.get_implementation instead of build() , but the latter allows calibrating the member gates
case specifically for this composite if they are first registered via registered_gates (in this case, there is
just one member, PRX). Creating new implementations for the PRX, CZ and Measure gates often means just coming up with new waveforms for the
control pulses. If this is the case, there are helpful base classes that make those implementations into oneliners
(outside of defining the Waveforms themselves): PRX_CustomWaveforms , FluxPulseGate , and Measure_CustomWaveforms . Using these
base classes at its simplest looks like this: All of these classes automatically include the associated Waveform parameters into the calibration parameters of
the implementation itself. There is also a general base class for any gate that implements a single IQPulse (both PRX_CustomWaveForms and Measure_MyCoolWaveforms actually inherit from it), regardless of the context: CustomIQWaveforms . Gate definitions (i.e. QuantumOps) are stored in ScheduleBuilder ’s attribute op_table . When the builder is created, the op_table comes preloaded with the all the basic QuantumOps needed for
typical circuit execution and their default implementations. These include e.g. the PRX gate, the CZ gate, the measure
operation, the conditional prx operation, the reset operation, and the barrier operation. In order to add custom operations, there is a helpful function register_implementation() that
in addition to adding new implementations allows one to add altogether new quantum operations. As an example here is a snippet that adds the CNOT gate, and its implementation, into an existing builder: Here, the CNOT implementation MyCNotClass needs to be of course defined first (a QuantumOp always needs at least one
implementation). Note that often ScheduleBuilder is created and operated by some client application, and the same application usually
has its own interface for adding/manipulating QuantumOps. However, if the user has access to the builder object, the
above method will always work. previous Using ScheduleBuilder next Pulse timing © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CosineRiseFallDerivative",url:"/iqm-pulse/api/iqm.pulse.playlist.waveforms.CosineRiseFallDerivative.html",description:`Bases: Waveform Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. where \\(c\\) is center_offset , \\(r\\) is rise_time , and \\(p\\) is the plateau width,
calcul...`,content:`Bases: Waveform Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. where \\(c\\) is center_offset , \\(r\\) is rise_time , and \\(p\\) is the plateau width,
calculated via \\(p :=\\) full_width - 2 * rise_time . Its values are in \\([-1, 1]\\) . full_width ( float ) – Duration of the support of the pulse, >= 2 * rise_time . rise_time ( float ) – Duration of the sinusoidal rise (and fall) part of the waveform, >= 0. center_offset ( float ) – The waveform is centered at this offset from the midpoint of the sampling window. n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes center_offset  full_width  rise_time  n_samples Requested number of samples for the waveform. Methods Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous Cosine next ModulatedCosineRiseFall © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.quantum_ops.validate_op_calibration",url:"/iqm-pulse/api/iqm.pulse.quantum_ops.validate_op_calibration.html",description:"Validates quantum operation calibration data against the known quantum operations. NOTE: calibration data parameters that have a defined default value are not required to be in the calibration data. c...",content:"Validates quantum operation calibration data against the known quantum operations. NOTE: calibration data parameters that have a defined default value are not required to be in the calibration data. calibration ( OpCalibrationDataTree ) – quantum operation calibration data tree to validate ops ( QuantumOpTable ) – known quantum operations and their implementations ValueError – there is something wrong with the calibration data None previous iqm.pulse.quantum_ops.validate_locus_calibration next QuantumOp © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"playlist",url:"/iqm-pulse/api/iqm.pulse.playlist.playlist.html",description:"Sequences of instruction schedules to execute. Full path: iqm.pulse.playlist.playlist previous Wait next schedule © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04....",content:"Sequences of instruction schedules to execute. Full path: iqm.pulse.playlist.playlist previous Wait next schedule © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"CZ_CRF",url:"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_CRF.html",description:"Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform ...",content:`Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineRiseFall Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous cz next CZ_CRF_ACStarkCRF © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"PRX_GateImplementation",url:"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_GateImplementation.html",description:"Bases: GateImplementation ABC for different implementations of the PRX gate. Module: iqm.pulse.gates.prx Attributes Methods clifford One-qubit XY Clifford gates. get_locus_mapping_name Get the name of...",content:`Bases: GateImplementation ABC for different implementations of the PRX gate. Module: iqm.pulse.gates.prx Attributes Methods clifford One-qubit XY Clifford gates. get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. rx X rotation gate. ry Y rotation gate. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Phased x rotation gate. angle ( float ) – rotation angle (in radians) phase ( float ) – phase angle (in radians) boxed instruction schedule implementing the phased x rotation gate TimeBox X rotation gate. angle ( float ) – rotation angle (in radians) boxed instruction schedule implementing the x rotation gate TimeBox Y rotation gate. angle ( float ) – rotation angle (in radians) boxed instruction schedule implementing the y rotation gate TimeBox One-qubit XY Clifford gates. xy_gate ( XYGate ) – Clifford gate boxed instruction schedule implementing the requested Clifford gate TimeBox Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is "<operation_name>.<implementation_name>" . Inheriting classes may
override this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous PRX_DRAGGaussianSX next PRX_SinglePulse_GateImplementation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.playlist.channel.get_channel_properties_from_station_settings",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.get_channel_properties_from_station_settings.html",description:"Get channel properties from Station Control controller settings following the standard convention. settings ( SettingNode ) – Flat tree of all controllers. chip_topology ( ChipTopology ) – Chip topolo...",content:`Get channel properties from Station Control controller settings following the standard convention. settings ( SettingNode ) – Flat tree of all controllers. chip_topology ( ChipTopology ) – Chip topology. mapping from channel name to its properties
component_to_channel: mapping from chip component to function name to channel name. channel_properties previous iqm.pulse.playlist.channel.get_channel_properties next ChannelConfiguration © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.playlist.channel.get_channel_properties",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.get_channel_properties.html",description:"Internal function to get channel properties. chip_topology ( ChipTopology ) – drive_controllers ( dict [ str , SettingNode ] ) – flux_controllers ( dict [ str , SettingNode ] ) – readout_controllers (...",content:"Internal function to get channel properties. chip_topology ( ChipTopology ) – drive_controllers ( dict [ str , SettingNode ] ) – flux_controllers ( dict [ str , SettingNode ] ) – readout_controllers ( dict [ str , SettingNode ] ) – tuple [ dict [ str , ChannelProperties ], dict [ str , dict [ str , str ]]] previous channel next iqm.pulse.playlist.channel.get_channel_properties_from_station_settings © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"Measure_Constant",url:"/iqm-pulse/api/iqm.pulse.gates.measure.Measure_Constant.html",description:"Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, dispersive measurement in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_wav...",content:`Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, dispersive measurement in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . Required calibration data, may be nested alias of Constant alias of Constant previous measure next Measure_CustomWaveforms © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.get_waveform_parameters",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.get_waveform_parameters.html",description:`Parameters that are required to initialize the given Waveform class. n_samples is handled separately since it is determined by the Instruction duration
and channel sample rate, and thus is shared by a...`,content:`Parameters that are required to initialize the given Waveform class. n_samples is handled separately since it is determined by the Instruction duration
and channel sample rate, and thus is shared by all the waveforms of the Instruction. wave ( type [ Waveform ] ) – waveform class label_prefix ( str ) – optional prefix for the parameter labels for providing additional information parameters of wave , in the format expected by GateImplementation.parameters . Waveform parameters
that have a defined default will be returned as Setting objects and those that do not have default
as Parameter objects. dict [ str , Setting | Parameter] previous iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING next CompositeCache © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"rz",url:"/iqm-pulse/api/iqm.pulse.gates.rz.html",description:"Single-qubit RZ gate. The z rotation gate is defined as where the rotation angle \\(\\phi\\) is in radians. Full path: iqm.pulse.gates.rz Functions get_unitary_rz (angle) Unitary for an RZ gate. Classes ...",content:"Single-qubit RZ gate. The z rotation gate is defined as where the rotation angle \\(\\phi\\) is in radians. Full path: iqm.pulse.gates.rz Functions get_unitary_rz (angle) Unitary for an RZ gate. Classes RZ_ACStarkShift Implementation of the RZ gate using an AC Stark pulse. RZ_ACStarkShift_CosineRiseFall AC stark pulse implemented as a modulated cosine rise fall pulse. RZ_Virtual Implementation of the RZ gate using the virtual z rotation technique. Inheritance previous Reset_Wait next iqm.pulse.gates.rz.get_unitary_rz © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"PRX_DRAGGaussian",url:"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGGaussian.html",description:"Bases: PRX_CustomWaveforms PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel wave...",content:`Bases: PRX_CustomWaveforms PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . Required calibration data, may be nested alias of TruncatedGaussian alias of TruncatedGaussianDerivative previous PRX_DRAGCosineRiseFallSX next PRX_DRAGGaussianSX © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"TimeTrace",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.TimeTrace.html",description:"Bases: AcquisitionMethod Capture the raw IQ signal without integration. Module: iqm.pulse.playlist.instructions Attributes duration_samples Length of the capture window, in samples. label Identifier f...",content:"Bases: AcquisitionMethod Capture the raw IQ signal without integration. Module: iqm.pulse.playlist.instructions Attributes duration_samples Length of the capture window, in samples. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) – delay_samples ( int ) – duration_samples ( int ) – Length of the capture window, in samples. previous ThresholdStateDiscrimination next VirtualRZ © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"TwoQubitGate",url:"/iqm-pulse/api/iqm.pulse.gates.enums.TwoQubitGate.html",description:`Bases: Enum Enumerates a subset of two-qubit gates. Members of this enum can be mapped to the corresponding unitary propagator using
the dictionary returned by TWO_QUBIT_UNITARIES . Module: iqm.pulse....`,content:`Bases: Enum Enumerates a subset of two-qubit gates. Members of this enum can be mapped to the corresponding unitary propagator using
the dictionary returned by TWO_QUBIT_UNITARIES . Module: iqm.pulse.gates.enums Attributes CZ Controlled-Z gate. ISWAP iSWAP gate. SQRT_ISWAP Square root of the iSWAP gate. Methods Controlled-Z gate. iSWAP gate. Square root of the iSWAP gate. previous iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES next XYGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"cz",url:"/iqm-pulse/api/iqm.pulse.gates.cz.html",description:`Two-qubit controlled-Z (CZ) gate. The CZ gate flips the relative phase of the \\(|11⟩\\) state.
It can be represented by the unitary matrix Full path: iqm.pulse.gates.cz Classes CZ_CRF CZ gate using a C...`,content:`Two-qubit controlled-Z (CZ) gate. The CZ gate flips the relative phase of the \\(|11⟩\\) state.
It can be represented by the unitary matrix Full path: iqm.pulse.gates.cz Classes CZ_CRF CZ gate using a CosineRiseFall flux pulse on the coupler. CZ_CRF_ACStarkCRF Controlled-Z two-qubit gate. CZ_GaussianSmoothedSquare CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. CZ_Slepian CZ gate using a Slepian flux pulse on the coupler. CZ_Slepian_ACStarkCRF Controlled-Z two-qubit gate. CZ_Slepian_CRF CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. CZ_TruncatedGaussianSmoothedSquare CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. CouplerFluxPulseQubitACStarkPulseGate Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. FluxPulseGate Discrete two locus component gate implemented using flux pulses, virtual RZs, and the interaction mediated by the coupler. FluxPulseGate_CRF_CRF CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. FluxPulseGate_TGSS_CRF CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Inheritance previous CCPRX_Composite_DRAGGaussian next CZ_CRF © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.utils.normalize_angle",url:"/iqm-pulse/api/iqm.pulse.utils.normalize_angle.html",description:"Normalize the given angle to (-pi, pi]. angle ( float ) – angle to normalize (in radians) angle normalized to (-pi, pi] float previous iqm.pulse.utils.merge_dicts next iqm.pulse.utils.phase_transforma...",content:"Normalize the given angle to (-pi, pi]. angle ( float ) – angle to normalize (in radians) angle normalized to (-pi, pi] float previous iqm.pulse.utils.merge_dicts next iqm.pulse.utils.phase_transformation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"FluxPulseGate_CRF_CRF",url:"/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate_CRF_CRF.html",description:"Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True...",content:`Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineRiseFall Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous FluxPulseGate next FluxPulseGate_TGSS_CRF © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING.html",description:"Locus mapping name for mapping all components that have the drive operation defined. previous iqm.pulse.gate_implementation.NestedParams next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READO...",content:"Locus mapping name for mapping all components that have the drive operation defined. previous iqm.pulse.gate_implementation.NestedParams next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"AcquisitionMethod",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.AcquisitionMethod.html",description:"Bases: object Describes a way to acquire readout data. Module: iqm.pulse.playlist.instructions Attributes label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay fro...",content:"Bases: object Describes a way to acquire readout data. Module: iqm.pulse.playlist.instructions Attributes label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) – delay_samples ( int ) – Identifier for the returned data, like QB1__readout.time_trace . Delay from beginning of probe pulse to beginning of acquisition window, in samples. previous instructions next Block © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"CouplerFluxPulseQubitACStarkPulseGate",url:"/iqm-pulse/api/iqm.pulse.gates.cz.CouplerFluxPulseQubitACStarkPulseGate.html",description:"Bases: GateImplementation Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. Analogous to the fast qubit flux pulse, the AC Stark pulse can tune the frequency of the qubit. To...",content:`Bases: GateImplementation Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. Analogous to the fast qubit flux pulse, the AC Stark pulse can tune the frequency of the qubit. Together with the
coupler flux pulse, this can implement a fast qubit pulsed CZ gate. Module: iqm.pulse.gates.cz Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters  coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. qubit_drive_wave Qubit drive pulse waveform to be played in the qubit drive AWG. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Flux pulse Waveform to be played in the coupler flux AWG. Qubit drive pulse waveform to be played in the qubit drive AWG. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain
parameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Returns an AC Stark pulse which consists of a modulated I and modulated Q waveform, where the Q quadrature
has an additional phase of -pi/2. phase ( float ) – amplitude ( float ) – phase_increment ( float ) – IQPulse The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is "<operation_name>.<implementation_name>" . Inheriting classes may
override this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous CZ_TruncatedGaussianSmoothedSquare next FluxPulseGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.OCalibrationData",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.OCalibrationData.html",description:"For a particular quantum operation, maps implementation names to their calibration data. alias of dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]] previous iqm.pulse.gate_implementat...",content:"For a particular quantum operation, maps implementation names to their calibration data. alias of dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]] previous iqm.pulse.gate_implementation.OICalibrationData next iqm.pulse.gate_implementation.OpCalibrationDataTree © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"builder",url:"/iqm-pulse/api/iqm.pulse.builder.html",description:"Tools for building instruction schedules. Full path: iqm.pulse.builder Functions build_quantum_ops (ops) Builds the table of known quantum operations. load_config (path) Load quantum operation definit...",content:"Tools for building instruction schedules. Full path: iqm.pulse.builder Functions build_quantum_ops (ops) Builds the table of known quantum operations. load_config (path) Load quantum operation definitions and calibration data from a YAML config file. validate_quantum_circuit (operations, op_table, *) Validate a sequence of circuit operations constituting a quantum circuit. Classes CircuitOperation Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. ScheduleBuilder Builds instruction schedules out of quantum circuits or individual quantum operations. Inheritance previous pulse next iqm.pulse.builder.build_quantum_ops © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"Segment",url:"/iqm-pulse/api/iqm.pulse.playlist.schedule.Segment.html",description:"Bases: object Sequence of instructions, for a single channel. Basically a list[Instruction] that keeps track of the time duration of its contents. instructions ( Iterable [ Instruction ] ) – contents ...",content:`Bases: object Sequence of instructions, for a single channel. Basically a list[Instruction] that keeps track of the time duration of its contents. instructions ( Iterable [ Instruction ] ) – contents of the segment duration ( int | None ) – If None, compute the sum of the durations of instructions .
Otherwise, the time duration (in samples) of the segment, which must match
the aforementioned sum if the Segment is still to be modified. Module: iqm.pulse.playlist.schedule Attributes duration Sum of the durations of the instructions in the segment, in samples. Methods append Append an instruction to the end of the segment. copy Make an independent copy of the segment. extend Append all instructions from an iterable to the end of the segment. pop Remove and return the instruction at the given index of the segment. prepend Prepend an instruction to the beginning of the segment. contents total duration of the segment, in samples Make an independent copy of the segment. Mutating the original must not affect the copy, or vice versa.
Instructions are immutable, so they need not be copied. copy of the segment Segment Append an instruction to the end of the segment. instruction ( Instruction ) – None Prepend an instruction to the beginning of the segment. instruction ( Instruction ) – None Append all instructions from an iterable to the end of the segment. instructions ( Iterable [ Instruction ] ) – None Remove and return the instruction at the given index of the segment. idx ( int ) – Instruction Sum of the durations of the instructions in the segment, in samples. previous Schedule next visualisation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gates.prx.get_unitary_prx",url:"/iqm-pulse/api/iqm.pulse.gates.prx.get_unitary_prx.html",description:"Unitary for a PRX gate. angle ( float ) – rotation angle (in rad) phase ( float ) – phase angle (in rad) 2x2 unitary representing prx(angle, phase) . ndarray previous prx next PRX_CustomWaveforms © Co...",content:"Unitary for a PRX gate. angle ( float ) – rotation angle (in rad) phase ( float ) – phase angle (in rad) 2x2 unitary representing prx(angle, phase) . ndarray previous prx next PRX_CustomWaveforms © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"sx",url:"/iqm-pulse/api/iqm.pulse.gates.sx.html",description:"Single-qubit sqrt(X) gate. The gate is doing pi/2 X gate, with additional Z rotation to correct phase. It rotates the qubit state in XZ plane (or around Y axis) for 90 degree. Full path: iqm.pulse.gat...",content:"Single-qubit sqrt(X) gate. The gate is doing pi/2 X gate, with additional Z rotation to correct phase. It rotates the qubit state in XZ plane (or around Y axis) for 90 degree. Full path: iqm.pulse.gates.sx Classes SXGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Inheritance previous RZ_Virtual next SXGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.scheduler.extend_schedule",url:"/iqm-pulse/api/iqm.pulse.scheduler.extend_schedule.html",description:"Extend a Schedule with another Schedule. Extends A with B , modifying both. The extension can add new channels to A . If B has a ragged left side, i.e. some of its channels begin with Nothing instruct...",content:`Extend a Schedule with another Schedule. Extends A with B , modifying both. The extension can add new channels to A . If B has a ragged left side, i.e. some of its channels begin with Nothing instructions,
this algorithm will not always produce an optimally short schedule. A ( Schedule ) – schedule to be extended B ( Schedule ) – schedule to extend A with channels ( dict [ str , ChannelProperties ] ) – properties of the control channels TOL ( float ) – time durations equal or smaller than this are considered zero (in seconds) None previous iqm.pulse.scheduler.extend_hard_boundary_in_seconds next iqm.pulse.scheduler.extend_schedule_new © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.circuit_operations.reorder",url:"/iqm-pulse/api/iqm.pulse.circuit_operations.reorder.html",description:"Reorders the qubits in the n-qubit operator A according to the permutation vector perm. mat ( ndarray ) – Matrix to reorder perm ( list [ int ] ) – Permutation Reordered matrix ndarray previous iqm.pu...",content:"Reorders the qubits in the n-qubit operator A according to the permutation vector perm. mat ( ndarray ) – Matrix to reorder perm ( list [ int ] ) – Permutation Reordered matrix ndarray previous iqm.pulse.circuit_operations.get_unitary_from_op next iqm.pulse.circuit_operations.reshape_unitary © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"AWGScheduleValidationData",url:"/iqm-pulse/api/iqm.pulse.validation.AWGScheduleValidationData.html",description:"Bases: object Controller specific validation data Module: iqm.pulse.validation Attributes sampling_rate  granularity  min_number_of_samples  compatible_instructions  Methods sampling_rate ( float ) – ...",content:"Bases: object Controller specific validation data Module: iqm.pulse.validation Attributes sampling_rate  granularity  min_number_of_samples  compatible_instructions  Methods sampling_rate ( float ) – granularity ( int ) – min_number_of_samples ( int ) – compatible_instructions ( tuple [ type [ Operation ] , ... ] ) – previous iqm.pulse.validation.validate_playlist_compatibility next iqm.pulse.validation.AWGScheduleValidationError © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.circuit_operations.reshape_unitary",url:"/iqm-pulse/api/iqm.pulse.circuit_operations.reshape_unitary.html",description:`Extend a unitary propagator to act on a larger system. Given a unitary matrix acting on N qubits, indices of N qubits in a larger Hilbert space, and the number
of qubits in that Hilbert space, calcula...`,content:`Extend a unitary propagator to act on a larger system. Given a unitary matrix acting on N qubits, indices of N qubits in a larger Hilbert space, and the number
of qubits in that Hilbert space, calculate a unitary acting on the larger Hilbert space, which acts as
the given unitary on the N selected qubits and as identity on the others. unitary ( tuple [ tuple [ float , ... ] , ... ] ) – original unitary as a nested tuple for hashing & caching purposes. indices ( tuple [ int , ... ] ) – qubit indices in the larger Hilbert space, all in range(num_qubits) n_qubits ( int ) – number of qubits in the larger Hilbert space Unitary matrix acting as unitary on the selected qubits in the larger Hilbert space. ndarray previous iqm.pulse.circuit_operations.reorder next CircuitOperationList © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.builder.validate_quantum_circuit",url:"/iqm-pulse/api/iqm.pulse.builder.validate_quantum_circuit.html",description:"Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) – quantum circuit to be validated op_table ( dict [ str , QuantumOp ] ) – table c...",content:"Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) – quantum circuit to be validated op_table ( dict [ str , QuantumOp ] ) – table containing allowed/calibrated quantum operations require_measurements ( bool ) – iff True the circuit must include at least one measurement operation ValueError – operations do not constitute a valid quantum circuit None previous iqm.pulse.builder.load_config next CircuitOperation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"utils",url:"/iqm-pulse/api/iqm.pulse.utils.html",description:"Utility functions. Full path: iqm.pulse.utils Functions load_yaml (path) Load a YAML file from the given path, raise error if the file can't be loaded. map_waveform_param_types (type_hint) Map a pytho...",content:"Utility functions. Full path: iqm.pulse.utils Functions load_yaml (path) Load a YAML file from the given path, raise error if the file can't be loaded. map_waveform_param_types (type_hint) Map a python typehint into EXA Parameter's (DataType, CollectionType) tuple. merge_dicts (A, B[, path, merge_nones]) Merge two dictionaries recursively, leaving the originals unchanged. normalize_angle (angle) Normalize the given angle to (-pi, pi]. phase_transformation ([psi_1, psi_2]) Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the IQ pulse implementing the PRX. previous TimeBox next iqm.pulse.utils.load_yaml © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.Locus",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.Locus.html",description:"Sequence of QPU component physical names a quantum operation is acting on. The order may matter. alias of tuple [ str , …] previous gate_implementation next iqm.pulse.gate_implementation.OILCalibratio...",content:"Sequence of QPU component physical names a quantum operation is acting on. The order may matter. alias of tuple [ str , …] previous gate_implementation next iqm.pulse.gate_implementation.OILCalibrationData © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"CZ_Slepian_ACStarkCRF",url:"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian_ACStarkCRF.html",description:`Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a slepian flux pulse for the coupler and a modulated cosine rise fall (CRF) AC Stark
pulse on one qu...`,content:`Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a slepian flux pulse for the coupler and a modulated cosine rise fall (CRF) AC Stark
pulse on one qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of Slepian Required calibration data, may be nested alias of ModulatedCosineRiseFall True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian next CZ_Slepian_CRF © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gates.move.validate_move_instructions",url:"/iqm-pulse/api/iqm.pulse.gates.move.validate_move_instructions.html",description:"Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Validates that circuit conforms to the MOVE gate constraints. instructions ( Iterable [ CircuitOperation ] ) – quantum ci...",content:"Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Validates that circuit conforms to the MOVE gate constraints. instructions ( Iterable [ CircuitOperation ] ) – quantum circuit to validate builder ( ScheduleBuilder ) – schedule builder, encapsulating information about the station validate_prx ( bool ) – whether to validate the circuit for PRX gates between MOVE sandwiches as well instructions , unmodified ValueError – Circuit does not conform to MOVE constraints. Iterable [ CircuitOperation ] previous iqm.pulse.gates.move.apply_move_gate_phase_corrections next MOVE_CRF_CRF © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.validation.AWGScheduleValidationError",url:"/iqm-pulse/api/iqm.pulse.validation.AWGScheduleValidationError.html",description:"Error raised when schedule validation for an AWG fails. previous AWGScheduleValidationData next iqm.pulse.validation.InvalidInstructionError © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025...",content:"Error raised when schedule validation for an AWG fails. previous AWGScheduleValidationData next iqm.pulse.validation.InvalidInstructionError © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"PRX_DRAGCosineRiseFallSX",url:"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGCosineRiseFallSX.html",description:"Bases: PRX_CustomWaveformsSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q cha...",content:`Bases: PRX_CustomWaveformsSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). excluded_parameters Parameters names to be excluded from self.parameters . parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain
parameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Builds a single sqrt(X) pulse from the calibration data. IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . Required calibration data, may be nested alias of CosineRiseFall alias of CosineRiseFallDerivative previous PRX_DRAGCosineRiseFall next PRX_DRAGGaussian © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"RealChannelConfig",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.RealChannelConfig.html",description:"Bases: ChannelConfiguration Requested configuration of a real channel. Module: iqm.pulse.playlist.channel Attributes sample_rate sample rate of the instrument responsible for the channel (in Hz) Metho...",content:"Bases: ChannelConfiguration Requested configuration of a real channel. Module: iqm.pulse.playlist.channel Attributes sample_rate sample rate of the instrument responsible for the channel (in Hz) Methods sample_rate ( float ) – sample rate of the instrument responsible for the channel (in Hz) previous ProbeChannelProperties next instructions © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.gates.move.apply_move_gate_phase_corrections",url:"/iqm-pulse/api/iqm.pulse.gates.move.apply_move_gate_phase_corrections.html",description:"Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. Note Assumes the MOVE gate implementation is based on MOVE_CustomWaveforms . Processes all the M...",content:`Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. Note Assumes the MOVE gate implementation is based on MOVE_CustomWaveforms . Processes all the MOVE sandwiches in schedule , summing up the VirtualRZ instructions
on the resonator virtual drive channels, adding the phase difference resulting from
qubit-resonator detuning to the total, and applying it on the qubit at the end of each sandwich. schedule ( Schedule ) – instruction schedule to process builder ( ScheduleBuilder ) – schedule builder that was used to build schedule apply_detuning_corrections ( bool ) – if True, also apply detuning phase corrections copy of schedule with the phase corrections applied Schedule previous move next iqm.pulse.gates.move.validate_move_instructions © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Chirp",url:"/iqm-pulse/api/iqm.pulse.playlist.waveforms.Chirp.html",description:`Bases: Waveform Linear chirp, defined as where \\(\\omega[\\alpha, N]\\) is a cosine-tapered window. For \\(\\alpha = 1\\) it becomes rectangular,
and for \\(\\alpha = 0\\) it becomes a Hann (or raised cosine) ...`,content:`Bases: Waveform Linear chirp, defined as where \\(\\omega[\\alpha, N]\\) is a cosine-tapered window. For \\(\\alpha = 1\\) it becomes rectangular,
and for \\(\\alpha = 0\\) it becomes a Hann (or raised cosine) window. The chirp pulse is valued inside the Nyquist zone, such that \\(f_{0}\\) and \\(f_{1}\\) are constrained
in the range \\([-0.5, 0.5]\\) . freq_start ( float ) – Initial frequency of the chirp waveform in the Nyquist zone. freq_stop ( float ) – Final frequency of the chirp waveform in the Nyquist zone. alpha ( float ) – Alpha parameter of the cosine-tapered window. Defaults to 0.05. phase ( float ) – Phase of the waveform. Defaults to 0 n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes alpha  phase  freq_start  freq_stop  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.
By default all the waveform attributes are “timelike” (the unit for their calibration data is s).
However, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of
consisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).
If a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the
sampling window duration, and all frequency-like calibration data into units of inverse sampling
window duration. dict [ str , str ] previous waveforms next ChirpImag © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.validation.validate_channel",url:"/iqm-pulse/api/iqm.pulse.validation.validate_channel.html",description:"Validate a single channel. channel_description ( ChannelDescription ) – device_constraints ( ChannelProperties ) – None previous iqm.pulse.validation.validate_awg_and_schedule_compatibility next iqm.p...",content:"Validate a single channel. channel_description ( ChannelDescription ) – device_constraints ( ChannelProperties ) – None previous iqm.pulse.validation.validate_awg_and_schedule_compatibility next iqm.pulse.validation.validate_instruction_and_wf_length © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"MoveMarker",url:"/iqm-pulse/api/iqm.pulse.gates.move.MoveMarker.html",description:`Bases: Wait Special annotation instruction to indicate the beginning and ending of MOVE gates. The same instance of this instruction will be inserted into the qubit drive channel and the
resonator vir...`,content:`Bases: Wait Special annotation instruction to indicate the beginning and ending of MOVE gates. The same instance of this instruction will be inserted into the qubit drive channel and the
resonator virtual drive channel, right before the beginning MOVE VirtualRZ instructions,
to link the channels together (otherwise, there would be nothing explicit in the Schedule
indicating that there is a MOVE gate happening between the qubit and the resonator). Another shared instance will be inserted to the aforementioned channels right before the ending
MOVE VirtualRZ instruction. The VirtualRZ instructions between the markers on the resonator
channel will be applied to the qubit instead in a post-compilation pass. Module: iqm.pulse.gates.move Attributes duration Time duration of the instruction. qubit  resonator  detuning  Methods duration ( int ) – qubit ( str ) – resonator ( str ) – detuning ( float ) – Time duration of the instruction. In samples at the channel sample rate. previous MOVE_TGSS_CRF next prx © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CZ_GaussianSmoothedSquare",url:"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_GaussianSmoothedSquare.html",description:"Bases: FluxPulseGate CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse W...",content:`Bases: FluxPulseGate CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of GaussianSmoothedSquare Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous CZ_CRF_ACStarkCRF next CZ_Slepian © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CompositeGate",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.CompositeGate.html",description:"Bases: GateImplementation Utility base class for creating gate implementations that are defined in terms of other gate implementations. Gates can be implemented using other pre-existing gate implement...",content:`Bases: GateImplementation Utility base class for creating gate implementations that are defined in terms of other gate implementations. Gates can be implemented using other pre-existing gate implementations by just utilizing the ScheduleBuilder in builder in the __call__() method (e.g. by calling self.builder.get_implementation(<some gate>, <some locus>) . In this way, any such “member gates” will use
the common calibration that exists in builder . In order for a composite gate
implementation to be able to calibrate its member gates with different calibration values from the common
calibration, it needs to know what gates it considers as its “members”. This is what the CompositeGate ABC is for. Inheriting from this class and defining e.g. registered_gates = ["prx", "cz"] allows one to calibrate the
member operations (i.e. "prx" and "cz" in this example) inside this composite gate differently from the
common calibration. However, if no specific calibration data is provided, the gate implementation will be calibrated
with the common calibration. Module: iqm.pulse.gate_implementation Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods build Construct a member gate implementation. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Gates that can be calibrated separately from their common calibration existing in self.builder . The gate
names should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can
also be constructed via self.builder , but these will always use the common calibration. Mapping from operation names to the designated default implementation of that operation. Filling this attribute
allows one to define a different default implementation from the common default in self.builder.op_table to
be used in he context of this composite gate. If an operation is not found in this dict as a key, this
CompositeGate will use the common default as the default implementation for it. Construct a member gate implementation. If the gate op_name is registered, a specific calibration for it in the context of this CompositeGate
will be sought for from self.builder.calibration . If any (non-empty) calibration values are found in self.builder.calibration[self.name][op_name][<impl_name>] they will be merged to the common calibration
(only non-empty values will be merged). If there are no values found, the
common calibration will be used. op_name ( str ) – operation name locus ( tuple [ str , ... ] ) – locus the operation acts on impl_name ( str | None ) – Implementation name. If not given, uses the default implementation defined in the class instance
if any, and otherwise the common default in self.builder.op_table strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may
be changed if no calibration data is available for the requested locus order Calibrated gate implementation. GateImplementation previous CompositeCache next CustomIQWaveforms © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.NestedParams",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.NestedParams.html",description:"Nested dict defining the parameters required by GateImplementation classes. alias of dict [ str , Parameter | Setting | dict ] previous iqm.pulse.gate_implementation.OpCalibrationDataTree next iqm.pul...",content:"Nested dict defining the parameters required by GateImplementation classes. alias of dict [ str , Parameter | Setting | dict ] previous iqm.pulse.gate_implementation.OpCalibrationDataTree next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"timebox",url:"/iqm-pulse/api/iqm.pulse.timebox.html",description:"Reserving QPU resources in instruction scheduling. Full path: iqm.pulse.timebox Classes MultiplexedProbeTimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. Sch...",content:"Reserving QPU resources in instruction scheduling. Full path: iqm.pulse.timebox Classes MultiplexedProbeTimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. SchedulingAlgorithm Algorithms for resolving composite TimeBoxes into atomic ones. SchedulingStrategy Different scheduling strategies for the contents of composite TimeBoxes. TimeBox Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Inheritance previous SegmentPointer next MultiplexedProbeTimeBox © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"PRX_CustomWaveformsSX",url:"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_CustomWaveformsSX.html",description:"Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms ABC for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. If the rotation angle \\(\\theta = \\pi/2\\) , th...",content:`Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms ABC for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. If the rotation angle \\(\\theta = \\pi/2\\) , the timebox will consist of just the SX IQ pulse, with phase. If not, the timebox will consist of two IQ pulses, with phase. The formula for the PRX gate implemented using SX gates and z rotations is The fusing of z rotations to IQPulses is done inside the _call() method. All parameters in the pulse here is referring to the state of the qubits. Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common
to all such implementations. Convert pulses into timebox, via extra Z rotations. There are exceptions while using pi/2 and pi rotation in angle, for calibration reason. The duration of the
timebox can be different. angle ( float ) – phase ( float ) – TimeBox Builds a single sqrt(X) pulse from the calibration data. amplitude_i ( float ) – amplitude_q ( float ) – n_samples ( int ) – IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . previous PRX_CustomWaveforms next PRX_DRAGCosineRiseFall © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gates.expose_implementation",url:"/iqm-pulse/api/iqm.pulse.gates.expose_implementation.html",description:"Add the given gate implementation to the list of known implementations. implementation ( type [ GateImplementation ] ) – GateImplementation to add so that it can be found with get_implementation_class...",content:"Add the given gate implementation to the list of known implementations. implementation ( type [ GateImplementation ] ) – GateImplementation to add so that it can be found with get_implementation_class() . overwrite ( bool ) – If True, does not raise an error if implementation already exists. None previous gates next iqm.pulse.gates.get_implementation_class © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.validation.validate_playlist_compatibility",url:"/iqm-pulse/api/iqm.pulse.validation.validate_playlist_compatibility.html",description:"Validates that the given playlist is compatible with the provided AWG data. The following requirements are validated as they are the same for all controllers. Playlist sample rate vs. Actual controlle...",content:"Validates that the given playlist is compatible with the provided AWG data. The following requirements are validated as they are the same for all controllers. Playlist sample rate vs. Actual controller sample rate Instruction granularity with respect to the controllers granularity requirements Checks that no other than supported instructions are used. Checks that instruction length matches waveform length in IQ and RealPulse Checks that all instructions are at least the length of minimum number of samples Checks that Conditional instruction has the same duration in every child instruction playlist ( Playlist ) – instructions used on each channel, as well as the channel configurations device_constraints ( dict [ str , ChannelProperties ] ) – actual hardware limitations of the channels None previous iqm.pulse.validation.validate_instruction_and_wf_length next AWGScheduleValidationData © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"ComplexIntegration",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.ComplexIntegration.html",description:"Bases: AcquisitionMethod Perform a weighted integration of the IQ raw signal, resulting in a complex number. Module: iqm.pulse.playlist.instructions Attributes weights Integration weights. label Ident...",content:"Bases: AcquisitionMethod Perform a weighted integration of the IQ raw signal, resulting in a complex number. Module: iqm.pulse.playlist.instructions Attributes weights Integration weights. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) – delay_samples ( int ) – weights ( IQPulse ) – Integration weights. previous Block next ConditionalInstruction © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"IQChannelConfig",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.IQChannelConfig.html",description:"Bases: RealChannelConfig Requested configuration of an IQ channel. Module: iqm.pulse.playlist.channel Attributes frequency upconversion frequency for the IQ pulses (in Hz) sample_rate sample rate of t...",content:"Bases: RealChannelConfig Requested configuration of an IQ channel. Module: iqm.pulse.playlist.channel Attributes frequency upconversion frequency for the IQ pulses (in Hz) sample_rate sample rate of the instrument responsible for the channel (in Hz) Methods sample_rate ( float ) – frequency ( float ) – upconversion frequency for the IQ pulses (in Hz) previous ChannelProperties next ProbeChannelProperties © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES",url:"/iqm-pulse/api/iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES.html",description:"Mapping of TwoQubitGates to the corresponding U(4) matrices previous iqm.pulse.gates.enums.XYGATE_UNITARIES next TwoQubitGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04....",content:"Mapping of TwoQubitGates to the corresponding U(4) matrices previous iqm.pulse.gates.enums.XYGATE_UNITARIES next TwoQubitGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"RZ_Virtual",url:"/iqm-pulse/api/iqm.pulse.gates.rz.RZ_Virtual.html",description:`Bases: GateImplementation Implementation of the RZ gate using the virtual z rotation technique. Implements the RZ gate on a specific qubit using a VirtualRZ instruction, which
simply changes the phase...`,content:`Bases: GateImplementation Implementation of the RZ gate using the virtual z rotation technique. Implements the RZ gate on a specific qubit using a VirtualRZ instruction, which
simply changes the phase of the local oscillator driving that qubit.
This requires no calibration data as of now.
The generated VirtualRZ instruction has the shortest possible duration allowed by the instruments. The virtual z rotation method is based on algebraically commuting the RZ gates towards the end
of the circuit, until they hit a measurement operation, at which point they are eliminated. It assumes that all the multi-qubit gates in the circuit commute with arbitrary RZ gates (this holds e.g. for CZ
since it is diagonal), measurements are projective and happen in the z basis, so that RZ gates that immediately
precede them do not affect the measurement result or the state after the measurement, and thus
can be removed, and conjugating the single-qubit gates in the circuit with RZ is equivalent to incrementing the phase of the drive
(holds for PRX ), which can be accomplished either by incrementing the phase of
the local oscillator of the drive channel, or incrementing the phases of all the IQPulse s
following it on the drive channel. If all these assumptions hold we may implement an RZ gate using a VirtualRZ instruction,
with phase_increment equal to the negated rotation angle. channel – name of the drive channel on which the VirtualRZ acts duration – time duration of the VirtualRZ instruction, in seconds parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Module: iqm.pulse.gates.rz Attributes parameters Required calibration data, may be nested Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. Z rotation gate. angle ( float ) – rotation angle (in radians) pulse schedule implementing the z rotation gate TimeBox Required calibration data, may be nested Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is "<operation_name>.<implementation_name>" . Inheriting classes may
override this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous RZ_ACStarkShift_CosineRiseFall next sx © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CustomIQWaveforms",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.CustomIQWaveforms.html",description:"Bases: GateImplementation Base class for GateImplementations using custom waveform definition with IQPulses. The class contains logic for automatic gate calibration parameters handling for such gates ...",content:`Bases: GateImplementation Base class for GateImplementations using custom waveform definition with IQPulses. The class contains logic for automatic gate calibration parameters handling for such gates (see the class
attributes for more info). With given Waveform waveform definitions Something and SomethingElse ,
an inheriting class may define the waveforms for the I and Q channels like this: class MyGate(CustomIQWaveforms, i_wave=Something, q_wave=SomethingElse) . Module: iqm.pulse.gate_implementation Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Waveform for the I channel. Waveform for the Q channel. If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common
to all such implementations. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain
parameters are not wanted in that class (also parameters defined by the waveforms can be excluded). previous CompositeGate next GateImplementation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"ModulatedCosineRiseFall",url:"/iqm-pulse/api/iqm.pulse.playlist.waveforms.ModulatedCosineRiseFall.html",description:`Bases: Waveform Modulated Cosine Rise Fall waveform. This waveform takes the waveform CosineRiseFall and modulates it with a cosine signal
which then has parameters frequency and phase , additional to...`,content:`Bases: Waveform Modulated Cosine Rise Fall waveform. This waveform takes the waveform CosineRiseFall and modulates it with a cosine signal
which then has parameters frequency and phase , additional to the parameters full_width , rise_time , and center_offset , see description of TruncatedGaussianSmoothedSquare for
further details. full_width ( float ) – Full width of the pulse, >= 2 * rise_time . rise_time ( float ) – Duration of the sinusoidal rise (and fall) part of the waveform, >= 0. modulation_frequency ( float ) – Modulation frequency. phase ( float ) – Phase of the modulation. center_offset ( float ) – The waveform is centered around this sampling window coordinate.
If zero, the pulse is placed in the middle of the sampling window. n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes center_offset  modulation_frequency  phase  full_width  rise_time  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.
By default all the waveform attributes are “timelike” (the unit for their calibration data is s).
However, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of
consisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).
If a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the
sampling window duration, and all frequency-like calibration data into units of inverse sampling
window duration. dict [ str , str ] previous CosineRiseFallDerivative next Slepian © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CZ_Slepian",url:"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian.html",description:"Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be p...",content:`Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of Slepian Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous CZ_GaussianSmoothedSquare next CZ_Slepian_ACStarkCRF © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"TimeBox",url:"/iqm-pulse/api/iqm.pulse.timebox.TimeBox.html",description:"Bases: object Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Each TimeBox can be labeled using a human-readable label describing it, and opera...",content:`Bases: object Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Each TimeBox can be labeled using a human-readable label describing it, and operates on a number
of locus components , using some of their control channels.  It can be either atomic or composite . An atomic box only contains a single Schedule . A composite box contains a sequence of other TimeBoxes as its children.
The locus components are the union of the locus components of the children.
If two children use the same channel so that they cannot happen simultaneously, they must
happen in the order they occur in the sequence. A box can be made atomic by resolving it using ScheduleBuilder.resolve_timebox .
The time duration of the box is determined by its contents and the way they are scheduled during the resolution. TimeBoxes can be concatenated with the following rules: Addition concatenates the children of the operands into a single TimeBox. The pipe operation groups two TimeBoxes together without concatenating. Iterables of Boxes are treated as the sum of the elements. Let a, b, c, d be TimeBoxes. Then Module: iqm.pulse.timebox Attributes scheduling Determines how the contents of a composite TimeBox are scheduled by ScheduleBuilder. scheduling_algorithm Determines the algorithm used in converting the TimeBox to a Schedule. label Description the contents of the box for users' convenience. locus_components Names of the QPU components on which this timebox operates. atom Resolved contents of the TimeBox, or None if not resolved. children Further Timeboxes inside this TimeBox. neighborhood_components Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox . Methods atomic Build an atomic timebox from a schedule. composite Build a composite timebox from a sequence of timeboxes. print Print a simple representation of the contents of this box. set_alap Set the scheduling strategy to As late as possible (ALAP). set_asap Set the scheduling strategy to As soon as possible (ASAP). validate Validate the contents of the TimeBox. label ( str ) – locus_components ( set [ str ] ) – atom ( Schedule | None ) – children ( tuple [ TimeBox , ... ] ) – scheduling ( SchedulingStrategy ) – scheduling_algorithm ( SchedulingAlgorithm ) – neighborhood_components ( dict [ int , set [ str ] ] ) – Description the contents of the box for users’ convenience. Has no functional effect. Names of the QPU components on which this timebox operates. These can include additional components
to the ones included in one of the channels occupied by this TimeBox . The components included in this
attribute will be blocked in scheduling, in addition to the ones dictated by the neighborhood range (see neighborhood_components ). Resolved contents of the TimeBox, or None if not resolved. Further Timeboxes inside this TimeBox. Determines how the contents of a composite TimeBox are scheduled by ScheduleBuilder.
Has no meaning for an atomic TimeBox. Determines the algorithm used in converting the TimeBox to a Schedule. Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox .
These are used in the scheduling when the corresponding neighborhood range is used.
The scheduling algorithm computes the neighborhood components (unless it has been already precomputed by
e.g. the GateImplementation ) and caches them under this attribute. Neighborhood range 0 means just the components
affected by one of the channels in self.atom + self.locus , 1 means also neighboring couplers, 2 the
components connected to those couplers, and so on. Note: range 0 may differ from self.locus_components : it can
have additional components that have occupied channels in self but are not defined as a part of the ‘locus’ of
this TimeBox for any reason. Build a composite timebox from a sequence of timeboxes. boxes ( Iterable [ TimeBox | Iterable [ TimeBox ] ] ) – contents of the new timebox. Any iterables of timeboxes will be flattened (recursively) and extended
to the contents in the same order. label ( str ) – label of the new timebox scheduling ( SchedulingStrategy ) – scheduling strategy to use when resolving the new timebox scheduling_algorithm ( SchedulingAlgorithm ) – scheduling algorithm to use when resolving the new timebox composite timebox containing boxes as its children TimeBox Build an atomic timebox from a schedule. schedule ( Schedule ) – contents of the new timebox locus_components ( Iterable [ str ] ) – names QPU components schedule operates on label ( str ) – label of the new timebox atomic timebox containing schedule TimeBox Validate the contents of the TimeBox. path ( tuple [ str , ... ] ) – Labels of ancestor boxes, to generate a better error message. None Set the scheduling strategy to As soon as possible (ASAP). TimeBox Set the scheduling strategy to As late as possible (ALAP). TimeBox Print a simple representation of the contents of this box. _idxs ( tuple [ int , ... ] ) – None previous SchedulingStrategy next utils © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Measure_CustomWaveforms",url:"/iqm-pulse/api/iqm.pulse.gates.measure.Measure_CustomWaveforms.html",description:"Bases: CustomIQWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. You may define a measurement implementation that uses the Waveform instances S...",content:`Bases: CustomIQWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. You may define a measurement implementation that uses the Waveform instances Something and SomethingElse as the probe pulse waveforms in the
I and Q channels as follows: class MyGate(Measure_CustomWaveforms, i_wave=Something, q_wave=SomethingElse) . The measure operation is factorizable, and its arity is 0, which together mean that it can operate
on loci of any dimensionality, but is calibrated only on single component loci. When the gate is constructed in the len(locus) > 1 , case (e.g. builder.get_implementation('measure', ('QB1', 'QB2', 'QB3'))() ) the resulting TimeBox is constructed from the calibrated single-component gates. For each measured component, the readout IQPulse will be modulated with the
intermediate frequency (IF), computed as the difference between the readout
frequency of that component and the probe line center frequency, and offset in phase
by the readout phase of the component. The measurement is implemented using a ReadoutTrigger instruction, with a duration set by the
requirements of the acquisition(s). Note that this is typically different from gates.measure.constant.{locus}.duration , which is the probe pulse duration. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. probe_timebox Returns a "naked" probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . time_trace Returns a multiplexed simultaneous measurement with an additional time trace acquisition. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common
to all such implementations. Cache for probe_timebox() . Cache for time_trace() . Builds a probe pulse and an acquisition method using the calibration data. Subclasses may override this method if needed. waveform_params ( dict [ str , Any ] ) – root_params ( dict [ str , Any ] ) – if_freq ( float ) – tuple [ IQPulse , AcquisitionMethod ] Returns a “naked” probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . This method can be used if the user wants to control the multiplexing explicitly. With two MultiplexedProbeTimeBox\`\`es \`\`A and B the result A + B has all the ReadoutTrigger instructions
on each probe channel of A and B multiplexed together and played simultaneously. key ( str ) – The readout results generated on this trigger will be assigned to f"{qubit}__{key}" , where qubit goes over the component names in self.locus . If empty,
the key “readout.result” will be used to maintain backwards compatibility. feedback_key ( str ) – The signals generated by this measure operation are routed using this key for
fast feedback purposes. See __call__() . do_acquisition ( bool ) – if False, no acquisitions are added. MultiplexedProbeTimeBox containing the ReadoutTrigger instruction. MultiplexedProbeTimeBox Returns a TimeBox containing the multiplexed simultaneous measurement. If len(self.locus) == 1 , the TimeBox contains the measurement for just that component, otherwise
the measurements of components that belong to the same probeline are multiplexed together. The returned TimeBox instances behave like any other TimeBox in scheduling and circuit
generation. With measurement TimeBoxes A and B the result A + B first plays the ReadoutTrigger instructions of A and only then those of B in each probe channel. If the multiplexing features of MultiplexedProbeTimeBox are needed, the method probe_timebox() can be used. In scheduling, the returned TimeBox blocks the locus components and the probe
lines they are associated with. key ( str ) – Readout results generated on this trigger will be assigned to the acquisition labels f"{qubit}__{key}" , where qubit goes over the component names in self.locus .
If empty, the key "readout.result" will be used to maintain backwards compatibility. feedback_key ( str ) – If the readout mode is “threshold”, the results generated by this measure operation
are routed using the label f"{qubit}__{feedback_key}" for fast feedback purposes.
The signals are picked up by ConditionalInstruction\`s that have the same label. The default value \` ””\`\` means the signal is not routed anywhere. TODO: currently the HW does not
support multiple feedback keys per drive channel, so the actual key used will be FEEDBACK_KEY whenever any non-empty key is inputted. When the HW is improved, the actual key the user inputs
should be passed. TimeBox containing the ReadoutTrigger instruction. TimeBox Returns a multiplexed simultaneous measurement with an additional time trace acquisition. The returned TimeBox is the same as the one returned by __call__() except the time trace
acquisition is appended to the acquisitions of each probe line’s ReadoutTrigger instruction. key ( str ) – Readout results generated on this trigger will be used to assigned to f"{qubit}__{key}" , where qubit goes over the component names in self.locus , whereas
the recorded time traces will be assigned to f"{probe_line}__{key}" where probe_line goes through all the probe lines associated with self.locus .
If empty, the key "readout.result" will be used for integrated results and the key "readout.time_trace" for the recorded time traces. acquisition_delay ( float | None ) – optionally override the time trace acquisition delay with this value (given in
seconds). Does not affect the acqusition delays of the integrated measurements. acquisition_duration ( float | None ) – optionally override the time trace acquisition duration with this value (given in
seconds). Does not affect the integration lengths of the integrated measurements. feedback_key ( str ) – The signals generated by the integration are routed using this label, prefixed by
the component. See __call__() . TimeBox containing the ReadoutTrigger instruction. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is "<operation_name>.<implementation_name>" . Inheriting classes may
override this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . previous Measure_Constant next ProbePulse_CustomWaveforms © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.quantum_ops.validate_locus_calibration",url:"/iqm-pulse/api/iqm.pulse.quantum_ops.validate_locus_calibration.html",description:"Validates calibration for a particular gate implementation at particular locus. cal_data ( OILCalibrationData ) – Calibration data tree for the locus. impl ( type [ GateImplementation ] ) – GateImplem...",content:"Validates calibration for a particular gate implementation at particular locus. cal_data ( OILCalibrationData ) – Calibration data tree for the locus. impl ( type [ GateImplementation ] ) – GateImplementation class that defines the required parameters. op ( QuantumOp ) – QuantumOp that impl implements. impl_name ( str ) – name of the implementation, for error messages. locus ( tuple [ str , ... ] ) – Locus of the operation ValueError – there is something wrong with the calibration data None previous iqm.pulse.quantum_ops.QuantumOpTable next iqm.pulse.quantum_ops.validate_op_calibration © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"ChirpImag",url:"/iqm-pulse/api/iqm.pulse.playlist.waveforms.ChirpImag.html",description:"Bases: Chirp Imaginary part of the linear chirp, which sets the phase to $-pi/2$. n_samples ( int ) – freq_start ( float ) – freq_stop ( float ) – alpha ( float ) – phase ( float ) – Phase of the puls...",content:"Bases: Chirp Imaginary part of the linear chirp, which sets the phase to $-pi/2$. n_samples ( int ) – freq_start ( float ) – freq_stop ( float ) – alpha ( float ) – phase ( float ) – Phase of the pulse. Defaults to $pi/2$ float Module: iqm.pulse.playlist.waveforms Attributes phase  freq_start  freq_stop  n_samples Requested number of samples for the waveform. Methods previous Chirp next Cosine © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"gates",url:"/iqm-pulse/api/iqm.pulse.gates.html",description:`GateImplementations for implementing quantum gates. The GateImplementation subclasses in this subpackage construct TimeBox instances to
implement specific native gates, using the calibration data that...`,content:`GateImplementations for implementing quantum gates. The GateImplementation subclasses in this subpackage construct TimeBox instances to
implement specific native gates, using the calibration data that the class has been initialized with.
Each GateImplementation instance encapsulates the calibration data for a specific implementation of a specific
native gate acting on a specific locus. Several different implementations and calibration schemes can be supported for a given gate,
each represented by its own GateImplementation subclass.
Likewise, a single GateImplementation subclass can be sometimes used to implement several different gates
through different calibration data. Full path: iqm.pulse.gates Functions expose_implementation (implementation[, ...]) Add the given gate implementation to the list of known implementations. get_implementation_class (class_name) Get gate implementation class by class name. register_implementation (operations, ...[, ...]) Register a new gate implementation, and a new gate if needed. Subpackages and modules barrier Barrier metaoperation. conditional Classically controlled gates. cz Two-qubit controlled-Z (CZ) gate. enums Enumerations for representing a set of important one- and two-qubit gates. measure Projective measurement in the Z basis. move Two-qubit MOVE gate. prx Single-qubit PRX gate. reset Resetting qubits to the zero state. rz Single-qubit RZ gate. sx Single-qubit sqrt(X) gate. u Single-qubit SU(2) gate. previous SinglePulseGate next iqm.pulse.gates.expose_implementation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"PRX_SinglePulse_GateImplementation",url:"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_SinglePulse_GateImplementation.html",description:"Bases: SinglePulseGate , PRX_GateImplementation ABC for PRX gates implemented using a single IQ pulse. This class implements phased x rotation gates on a specific qubit using an IQPulse instance, deri...",content:`Bases: SinglePulseGate , PRX_GateImplementation ABC for PRX gates implemented using a single IQ pulse. This class implements phased x rotation gates on a specific qubit using an IQPulse instance, derived from the pulse calibration data provided at construction by
the static method _single_iq_pulse() .
The pulse is used to resonantly drive the qubit to effect the required rotation. The pulse calibration data consists of the parameters of an \\(x_\\pi\\) IQPulse only.
It is assumed that the transfer function from the AWG to the qubit is linear, i.e.,
other rotation angles can be obtained by linearly scaling the pulse amplitude, and other phase angles can be obtained by adjusting the IQ modulation phase. The generated pulses all have the same time duration, also for identity rotations. In the special case of the
duration being zero, the gate implementation will apply a Block(0) instruction to the qubit’s drive channel. Module: iqm.pulse.gates.prx Attributes iq_pulse Alias for self.pulse for backward compatibility Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Phased x rotation gate. angle ( float ) – rotation angle (in radians) phase ( float ) – phase angle (in radians) boxed instruction schedule implementing the phased x rotation gate TimeBox Alias for self.pulse for backward compatibility previous PRX_GateImplementation next reset © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"FluxPulseGate",url:"/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate.html",description:`Bases: GateImplementation Discrete two locus component gate implemented using flux pulses, virtual RZs,
and the interaction mediated by the coupler. Does not take any parameters since it is discrete. ...`,content:`Bases: GateImplementation Discrete two locus component gate implemented using flux pulses, virtual RZs,
and the interaction mediated by the coupler. Does not take any parameters since it is discrete. The two locus components of the gate must be coupled by a tunable coupler. Consists of a flux pulse for the coupler, and possibly another one for the first locus component,
assumed to be a qubit, both with arbitrary waveforms, and virtual RZs on both components.
Inherit from this class and assign
waveforms to the coupler_wave and qubit_wave pulse slots to create a specific implementation. Can be used as a base class for both CZ and MOVE gate implementations. Note: the coupler and qubit pulses typically have the same duration (given in the calibration data), and in the
special case of the duration being zero, the gate implementation will apply Block(0) instructions
to all the channels where it would otherwise apply flux pulses or virtual z rotations. flux_pulses – mapping from flux channel name to its flux pulse rz – mapping from drive channel name to the virtual z rotation angle, in radians, that should be performed on it parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Module: iqm.pulse.gates.cz Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters Parameters shared by all FluxPulseGate classes. coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. Flux pulse Waveform to be played in the coupler flux AWG. Flux pulse Waveform to be played in the qubit flux AWG. Parameters shared by all FluxPulseGate classes. Inheriting classes may override this if there’s
a need for additional calibration parameters. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain
parameters are not wanted in that class (also parameters defined by the waveforms can be excluded). The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is "<operation_name>.<implementation_name>" . Inheriting classes may
override this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous CouplerFluxPulseQubitACStarkPulseGate next FluxPulseGate_CRF_CRF © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"VirtualRZ",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.VirtualRZ.html",description:`Bases: Instruction Change the upconversion phase reference. The phase change can be done either by updating the phase of the local oscillator directly using
a hardware instruction, or algebraically by...`,content:`Bases: Instruction Change the upconversion phase reference. The phase change can be done either by updating the phase of the local oscillator directly using
a hardware instruction, or algebraically by incrementing IQPulse.phase of all the IQPulses
following the VirtualRZ instruction in the Segment . Module: iqm.pulse.playlist.instructions Attributes phase_increment Phase increment for the local oscillator of a drive channel, in radians. duration Time duration of the instruction. Methods duration ( int ) – phase_increment ( float ) – Phase increment for the local oscillator of a drive channel, in radians. previous TimeTrace next Wait © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.validation.PlaylistValidationError",url:"/iqm-pulse/api/iqm.pulse.validation.PlaylistValidationError.html",description:"Error raised when Playlist validation fails. previous iqm.pulse.validation.InvalidInstructionError next Changelog © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04....",content:"Error raised when Playlist validation fails. previous iqm.pulse.validation.InvalidInstructionError next Changelog © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.utils.map_waveform_param_types",url:"/iqm-pulse/api/iqm.pulse.utils.map_waveform_param_types.html",description:"Map a python typehint into EXA Parameter’s (DataType, CollectionType) tuple. type – python typehint. type_hint ( type ) – A (DataType, CollectionType) tuple ValueError – for a non-supported type. tupl...",content:"Map a python typehint into EXA Parameter’s (DataType, CollectionType) tuple. type – python typehint. type_hint ( type ) – A (DataType, CollectionType) tuple ValueError – for a non-supported type. tuple [ DataType , CollectionType ] previous iqm.pulse.utils.load_yaml next iqm.pulse.utils.merge_dicts © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"SinglePulseGate",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.SinglePulseGate.html",description:`Bases: GateImplementation Base class for GateImplementations that play a single pulse on a single channel. The pulse is created in _get_pulse() and the channel is specified in _get_pulse_channel() .
T...`,content:`Bases: GateImplementation Base class for GateImplementations that play a single pulse on a single channel. The pulse is created in _get_pulse() and the channel is specified in _get_pulse_channel() .
The base class also implements a basic _call() method that just inserts the specified pulse into the specified
channel, and a method for computing the pulse’s duration. All of these methods can be overridden in subclasses. Module: iqm.pulse.gate_implementation Attributes Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Return the channel for the pulse. The default is the drive channel for a single qubit locus. str Return pulse based on the provided calibration data. Instruction Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float previous GateImplementation next gates © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"IQPulse",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.IQPulse.html",description:"Bases: Instruction Play an upconverted pulse that contains real in-phase and quadrature waveforms. Module: iqm.pulse.playlist.instructions Attributes modulation_frequency Modulation frequency of the w...",content:`Bases: Instruction Play an upconverted pulse that contains real in-phase and quadrature waveforms. Module: iqm.pulse.playlist.instructions Attributes modulation_frequency Modulation frequency of the waveforms, in units of the sampling rate. phase Phase of the pulse relative to the channel frequency, in radians. phase_increment Relative phase increment to the phase in the carrier frequency of this pulse and all pulses that are played after it. scale_i Scaling factor for the I quadrature. scale_q Scaling factor for the Q quadrature. wave_i I quadrature envelope. wave_q Q quadrature envelope. duration Time duration of the instruction. Methods get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) – wave_i ( Waveform ) – wave_q ( Waveform ) – scale_i ( float ) – scale_q ( float ) – phase ( float ) – modulation_frequency ( float ) – phase_increment ( float ) – I quadrature envelope. Q quadrature envelope. Scaling factor for the I quadrature. Scaling factor for the Q quadrature. Phase of the pulse relative to the channel frequency, in radians. Modulation frequency of the waveforms, in units of the sampling rate.
This modulation is additional to the channel frequency.
The default value of 0.0 does not modulate.
Note that the phase of this modulation resets for every instruction, that is, successive instances of the same
modulated pulse are not phase coherent. Relative phase increment to the phase in the carrier frequency of this pulse and all pulses that
are played after it. Unit: rad. Validate the instruction attributes. ValueError – something about the instruction is not ok Returns all the waveforms the Instruction contains. tuple [ Waveform , …] previous ConditionalInstruction next Instruction © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.utils.load_yaml",url:"/iqm-pulse/api/iqm.pulse.utils.load_yaml.html",description:"Load a YAML file from the given path, raise error if the file can’t be loaded. path ( str ) – path to a YAML file contents of the YAML file as Python types dict [ str , Any ] previous utils next iqm.p...",content:"Load a YAML file from the given path, raise error if the file can’t be loaded. path ( str ) – path to a YAML file contents of the YAML file as Python types dict [ str , Any ] previous utils next iqm.pulse.utils.map_waveform_param_types © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"ChannelConfiguration",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelConfiguration.html",description:"Bases: object Base class for configuring channels. Module: iqm.pulse.playlist.channel Methods previous iqm.pulse.playlist.channel.get_channel_properties_from_station_settings next ChannelDescription ©...",content:"Bases: object Base class for configuring channels. Module: iqm.pulse.playlist.channel Methods previous iqm.pulse.playlist.channel.get_channel_properties_from_station_settings next ChannelDescription © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"MOVE_TGSS_CRF",url:"/iqm-pulse/api/iqm.pulse.gates.move.MOVE_TGSS_CRF.html",description:`Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the
CRF waveform for the qubit flux pulse. Module: iqm.pulse.gates.move Attributes paramete...`,content:`Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the
CRF waveform for the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous MOVE_CustomWaveforms next MoveMarker © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CZ_TruncatedGaussianSmoothedSquare",url:"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_TruncatedGaussianSmoothedSquare.html",description:"Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flu...",content:`Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian_CRF next CouplerFluxPulseQubitACStarkPulseGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"instructions",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.html",description:"Instructions for control instruments. Full path: iqm.pulse.playlist.instructions Classes AcquisitionMethod Describes a way to acquire readout data. Block Behave strictly as if outputting zero-valued s...",content:"Instructions for control instruments. Full path: iqm.pulse.playlist.instructions Classes AcquisitionMethod Describes a way to acquire readout data. Block Behave strictly as if outputting zero-valued samples for the duration of the instruction. ComplexIntegration Perform a weighted integration of the IQ raw signal, resulting in a complex number. ConditionalInstruction Choice between multiple Instructions, depending on a condition. IQPulse Play an upconverted pulse that contains real in-phase and quadrature waveforms. Instruction Command that can be executed by the quantum computer on a control channel. MultiplexedIQPulse Instruction to simultaneously play multiple IQ pulses. ReadoutTrigger Instruction for playing a probe pulse and acquiring the associated readout results. RealPulse Play a real-valued pulse. ThresholdStateDiscrimination Perform a weighted integration of the IQ raw signal and compare the real part of the result against a threshold value, resulting in a boolean. TimeTrace Capture the raw IQ signal without integration. VirtualRZ Change the upconversion phase reference. Wait Behave as if outputting zero-valued samples for the duration of the instruction. Inheritance previous RealChannelConfig next AcquisitionMethod © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.gates.enums.XYGATE_UNITARIES",url:"/iqm-pulse/api/iqm.pulse.gates.enums.XYGATE_UNITARIES.html",description:"Mapping of XYGates to the corresponding SU(2) matrices previous enums next iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04....",content:"Mapping of XYGates to the corresponding SU(2) matrices previous enums next iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"playlist",url:"/iqm-pulse/api/iqm.pulse.playlist.html",description:"Control pulses and pulse sequences for quantum processors. Full path: iqm.pulse.playlist Subpackages and modules channel Control channel properties. instructions Instructions for control instruments. ...",content:"Control pulses and pulse sequences for quantum processors. Full path: iqm.pulse.playlist Subpackages and modules channel Control channel properties. instructions Instructions for control instruments. playlist Sequences of instruction schedules to execute. schedule Instruction schedules for controlling the instruments. visualisation  waveforms Waveform definitions. previous UGate next channel © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"ThresholdStateDiscrimination",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.ThresholdStateDiscrimination.html",description:`Bases: ComplexIntegration Perform a weighted integration of the IQ raw signal and compare the real part of the result
against a threshold value, resulting in a boolean. Module: iqm.pulse.playlist.inst...`,content:`Bases: ComplexIntegration Perform a weighted integration of the IQ raw signal and compare the real part of the result
against a threshold value, resulting in a boolean. Module: iqm.pulse.playlist.instructions Attributes feedback_signal_label In fast feedback routing, the transmitted signals are associated with this label. threshold The real part of the integration result is compared against this. weights Integration weights. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) – delay_samples ( int ) – weights ( IQPulse ) – threshold ( float ) – feedback_signal_label ( str ) – The real part of the integration result is compared against this. In fast feedback routing, the transmitted signals are associated with this label.
ConditionalInstructions whose “condition” field has the string value of feedback_signal_label will receive the signal from this ThresholdStateDiscrimination.
Empty string (default) means the signal is not routed anywhere.
The same feedback_signal_label may not be used multiple times within the same ReadoutTrigger.
The same feedback_signal_label can be used in different ReadoutTriggers and different segments. previous RealPulse next TimeTrace © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING.html",description:"Locus mapping name for mapping all components that have the readout operation defined. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING next iqm.pulse.gate_implementat...",content:"Locus mapping name for mapping all components that have the readout operation defined. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"RZ_ACStarkShift_CosineRiseFall",url:"/iqm-pulse/api/iqm.pulse.gates.rz.RZ_ACStarkShift_CosineRiseFall.html",description:"Bases: RZ_ACStarkShift AC stark pulse implemented as a modulated cosine rise fall pulse. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes paramet...",content:`Bases: RZ_ACStarkShift AC stark pulse implemented as a modulated cosine rise fall pulse. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of ModulatedCosineRiseFall Required calibration data, may be nested True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous RZ_ACStarkShift next RZ_Virtual © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"quantum_ops",url:"/iqm-pulse/api/iqm.pulse.quantum_ops.html",description:"Quantum operations. Full path: iqm.pulse.quantum_ops Module Attributes QuantumOpTable Type for representing tables of known quantum operations, maps names of the ops to their definitions. Functions va...",content:"Quantum operations. Full path: iqm.pulse.quantum_ops Module Attributes QuantumOpTable Type for representing tables of known quantum operations, maps names of the ops to their definitions. Functions validate_locus_calibration (cal_data, impl, ...) Validates calibration for a particular gate implementation at particular locus. validate_op_calibration (calibration, ops) Validates quantum operation calibration data against the known quantum operations. Classes QuantumOp Describes a native quantum operation type. Inheritance previous Slepian next iqm.pulse.quantum_ops.QuantumOpTable © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"ChannelDescription",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelDescription.html",description:"Bases: object Channel specific data, including tables for the instructions and waveforms used. name ( str ) – name of the controller handling the channel, also the name of the channel config ( RealCha...",content:`Bases: object Channel specific data, including tables for the instructions and waveforms used. name ( str ) – name of the controller handling the channel, also the name of the channel config ( RealChannelConfig ) – properties of the channel instruction_table – mapping of the instructions to be executed on this channel. Each
instruction should be unique. waveform_table – Contains mapping of the waveforms to be executed on this channel. Each
waveform should be unique. Module: iqm.pulse.playlist.channel Attributes name  config  instruction_table  waveform_table  Methods add_instruction Add an instruction to the channel. Add an instruction to the channel. Each unique instruction in a channel gets assigned an integer index that can be used to refer to it.
If the instruction has associated Waveform s, they are indexed in a similar manner. instruction ( Instruction ) – instruction to be added index of the instruction int previous ChannelConfiguration next ChannelProperties © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.validation.validate_instruction_and_wf_length",url:"/iqm-pulse/api/iqm.pulse.validation.validate_instruction_and_wf_length.html",description:"Validate that instruction and waveform lengths match instruction ( Instruction ) – The IQPulse or RealPulse to be validated previous iqm.pulse.validation.validate_channel next iqm.pulse.validation.val...",content:"Validate that instruction and waveform lengths match instruction ( Instruction ) – The IQPulse or RealPulse to be validated previous iqm.pulse.validation.validate_channel next iqm.pulse.validation.validate_playlist_compatibility © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"MultiplexedProbeTimeBox",url:"/iqm-pulse/api/iqm.pulse.timebox.MultiplexedProbeTimeBox.html",description:"Bases: TimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. A MultiplexedProbeTimeBox ’s atom contains exactly one ReadoutTrigger for each probe channel. Module...",content:"Bases: TimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. A MultiplexedProbeTimeBox ’s atom contains exactly one ReadoutTrigger for each probe channel. Module: iqm.pulse.timebox Attributes label Description the contents of the box for users' convenience. locus_components Names of the QPU components on which this timebox operates. atom Resolved contents of the TimeBox, or None if not resolved. children Further Timeboxes inside this TimeBox. neighborhood_components Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox . Methods from_readout_trigger Build an atomic MultiplexedProbeTimeBox` from a single ``ReadoutTrigger instruction. label ( str ) – locus_components ( set [ str ] ) – atom ( Schedule | None ) – children ( tuple [ TimeBox , ... ] ) – scheduling ( SchedulingStrategy ) – scheduling_algorithm ( SchedulingAlgorithm ) – neighborhood_components ( dict [ int , set [ str ] ] ) – Build an atomic MultiplexedProbeTimeBox` from a single ``ReadoutTrigger instruction. readout_trigger ( ReadoutTrigger ) – Readout trigger instruction. probe_channel ( str ) – Name of the probe channel to play readout_trigger in. locus_components ( Iterable [ str ] ) – Locus components. label ( str ) – Label of the new timebox. block_channels ( Iterable [ str ] ) – Names of channels to block. block_duration ( int ) – Duration of the required blocking (in samples). atomic timebox containing readout_trigger in the channel probe_channel . MultiplexedProbeTimeBox previous timebox next SchedulingAlgorithm © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"SXGate",url:"/iqm-pulse/api/iqm.pulse.gates.sx.SXGate.html",description:"Bases: CompositeGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Module: iqm.pulse.gates.sx Attributes registered_gates Gates that can be calibrated separately from thei...",content:`Bases: CompositeGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Module: iqm.pulse.gates.sx Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Gates that can be calibrated separately from their common calibration existing in self.builder . The gate
names should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can
also be constructed via self.builder , but these will always use the common calibration. Call PRX gate with angle equals to pi / 2. TimeBox previous sx next u © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Reset_Wait",url:"/iqm-pulse/api/iqm.pulse.gates.reset.Reset_Wait.html",description:"Bases: GateImplementation Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Adds a Wait pulse for all the (non-virtual) channels of the locus compon...",content:`Bases: GateImplementation Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Adds a Wait pulse for all the (non-virtual) channels of the locus components. In addition, blocks all the probes
associated with the locus and in case the locus is connected via couplers, blocks them as well. The operation
is factorizable, so that the calibration data it uses (i.e. the wait duration in seconds) is defined for each
component, and when acting on multiple components, the maximum of the associated wait durations will be applied. Reset by relaxation is intended to be used in the circuit initialisation between shots / segments.
It also can be called on specific qubits inside a segment, but as it works by
waiting longer than the qubit relaxation time, the states of all the other qubits
will likely have been destroyed as well by the time the reset has finished. Module: iqm.pulse.gates.reset Attributes parameters Required calibration data, may be nested Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_custom_locus_mapping Supported loci: all components that have channels. wait_box TimeBox that contains Wait instructions for all non-virtual channels associated with self.locus . parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Required calibration data, may be nested TimeBox that contains Wait instructions for all non-virtual channels associated with self.locus . Does not block any additional components beside the locus itself. TimeBox The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float Supported loci: all components that have channels. chip_topology ( ChipTopology ) – component_to_channels ( dict [ str , Iterable [ str ] ] ) – dict [ tuple [ str , …] | frozenset [ str ], tuple [ str , …]] | None previous Reset_Conditional next rz © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"SchedulingAlgorithm",url:"/iqm-pulse/api/iqm.pulse.timebox.SchedulingAlgorithm.html",description:"Bases: Enum Algorithms for resolving composite TimeBoxes into atomic ones. Module: iqm.pulse.timebox Attributes HARD_BOUNDARY Respects the TimeBox boundary such that the longest channel with a box def...",content:`Bases: Enum Algorithms for resolving composite TimeBoxes into atomic ones. Module: iqm.pulse.timebox Attributes HARD_BOUNDARY Respects the TimeBox boundary such that the longest channel with a box defines its boundary and all other channels are padded to this length (using the specified SchedulingStrategy ). TETRIS Will pack the schedule as tightly as possible while respecting the defined scheduling neighborhood. Methods Respects the TimeBox boundary such that the longest channel with a box defines
its boundary and all other channels are padded to this length (using the specified SchedulingStrategy ). Will pack the schedule as tightly as possible while respecting the defined scheduling neighborhood. previous MultiplexedProbeTimeBox next SchedulingStrategy © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"UGate",url:"/iqm-pulse/api/iqm.pulse.gates.u.UGate.html",description:"Bases: CompositeGate SU(2) gate implemented using PRX. Assumes the chosen PRX implementation uses resonant driving, and that the virtual RZ technique can be used. Module: iqm.pulse.gates.u Attributes ...",content:`Bases: CompositeGate SU(2) gate implemented using PRX. Assumes the chosen PRX implementation uses resonant driving, and that the virtual RZ technique can be used. Module: iqm.pulse.gates.u Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Gates that can be calibrated separately from their common calibration existing in self.builder . The gate
names should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can
also be constructed via self.builder , but these will always use the common calibration. Convert pulses into timebox, via Euler decomposition. theta ( float ) – phi ( float ) – lam ( float ) – TimeBox previous iqm.pulse.gates.u.get_unitary_u next playlist © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gates.get_implementation_class",url:"/iqm-pulse/api/iqm.pulse.gates.get_implementation_class.html",description:"Get gate implementation class by class name. class_name ( str ) – type [ GateImplementation ] | None previous iqm.pulse.gates.expose_implementation next iqm.pulse.gates.register_implementation © Copyr...",content:"Get gate implementation class by class name. class_name ( str ) – type [ GateImplementation ] | None previous iqm.pulse.gates.expose_implementation next iqm.pulse.gates.register_implementation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"ProbeChannelProperties",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.ProbeChannelProperties.html",description:"Bases: ChannelProperties ChannelProperties for probe line channels. Module: iqm.pulse.playlist.channel Attributes center_frequency Center frequency for the channel. integration_start_dead_time Dead ti...",content:"Bases: ChannelProperties ChannelProperties for probe line channels. Module: iqm.pulse.playlist.channel Attributes center_frequency Center frequency for the channel. integration_start_dead_time Dead time samples before integration. integration_stop_dead_time Dead time samples after integration. sample_rate sample rate of the instrument responsible for the channel (in Hz) instruction_duration_granularity all instruction durations on this channel must be multiples of this granularity (in samples) instruction_duration_min all instruction durations on this channel must at least this long (in samples) compatible_instructions instruction types that are allowed on this channel Methods sample_rate ( float ) – instruction_duration_granularity ( int ) – instruction_duration_min ( int ) – compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) – is_iq ( bool ) – is_virtual ( bool ) – blocks_component ( bool ) – center_frequency ( float ) – integration_start_dead_time ( int ) – integration_stop_dead_time ( int ) – Center frequency for the channel. Dead time samples before integration. Dead time samples after integration. previous IQChannelConfig next RealChannelConfig © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.playlist.schedule.TOLERANCE",url:"/iqm-pulse/api/iqm.pulse.playlist.schedule.TOLERANCE.html",description:"remove when COMP-1281 is done. TODO previous schedule next Nothing © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04....",content:"remove when COMP-1281 is done. TODO previous schedule next Nothing © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.validation.validate_awg_and_schedule_compatibility",url:"/iqm-pulse/api/iqm.pulse.validation.validate_awg_and_schedule_compatibility.html",description:`Validates that the given playlist is compatible with the provided AWG data.
The following requirements are validated as they are the same for all controllers. Playlist sampling rate vs. Actual control...`,content:`Validates that the given playlist is compatible with the provided AWG data.
The following requirements are validated as they are the same for all controllers. Playlist sampling rate vs. Actual controller sampling rate Instruction granularity with respect to the controllers granularity requirements Checks that no other than supported instructions are used. Checks that instruction length matches waveform length in IQ and RealPulse Checks that all instructions are at least the length of minimum number of samples Checks that Conditional instruction has the same duration in every child instruction channel_description ( ChannelDescription ) – Contains instructions used as well as the channel specific configuration from playlist device_constraints ( AWGScheduleValidationData ) – Contains the actual hardware limitations previous validation next iqm.pulse.validation.validate_channel © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.scheduler.extend_hard_boundary_in_seconds",url:"/iqm-pulse/api/iqm.pulse.scheduler.extend_hard_boundary_in_seconds.html",description:`The same as extend_hard_boundary , but the scheduling is done in seconds. Used when the probe channel sampling rate differs from the other channels’ rate.
The incoming schedules measure Instruction du...`,content:`The same as extend_hard_boundary , but the scheduling is done in seconds. Used when the probe channel sampling rate differs from the other channels’ rate.
The incoming schedules measure Instruction durations in samples, but component_durations is in seconds. schedule ( Schedule ) – Schedule that should be extended with child_schedule . Modified in place. child_schedule ( Schedule ) – Child schedule to be added. child_components ( set [ str ] ) – Components (qubits, couplers, computational_resonators) that have at least
one channel in child_schedule . neighborhood_components ( set [ str ] ) – Components neighboring the child_components that should
additionally be blocked in the scheduling. component_durations ( dict [ str , float ] ) – Blocked durations for each component in schedule .
These act as the earliest starting points for new segment added to any of the channels
of a given component, but will also block the component even if it has no occupied channels
in the schedule yet or ever (e.g. a computational resonator).
The durations are in seconds. Modified in place. is_alap ( bool ) – Whether the scheduling strategy is ALAP (As Late As Possible). channel_properties ( dict [ str , ChannelProperties ] ) – Mapping from channel name to its properties (e.g. the sample rates
and granularities). None previous iqm.pulse.scheduler.extend_hard_boundary next iqm.pulse.scheduler.extend_schedule © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"move",url:"/iqm-pulse/api/iqm.pulse.gates.move.html",description:`Two-qubit MOVE gate. The MOVE gate is a population exchange operation between a qubit and a resonator,
mediated by a coupler, that has the following properties: MOVE is unitary. The effect of MOVE is ...`,content:`Two-qubit MOVE gate. The MOVE gate is a population exchange operation between a qubit and a resonator,
mediated by a coupler, that has the following properties: MOVE is unitary. The effect of MOVE is only defined in the invariant
subspace \\(S = \\text{span}\\{|00\\rangle, |01\\rangle, |10\\rangle\\}\\) , where it swaps the populations of the states \\(|01\\rangle\\) and \\(|10\\rangle\\) . Anything may happen in the orthogonal subspace as long as it is unitary and
invariant. In the subspace where it is defined, MOVE is an involution: \\(\\text{MOVE}_S^2 = I_S\\) . Thus MOVE has the following presentation in the subspace \\(S\\) : where \\(a\\) is an undefined complex phase. This degree of freedom (in addition to the undefined effect of the gate
in the orthogonal subspace) means there is a continuum of different MOVE gates, all equally valid.
The phase \\(a\\) is canceled when the MOVE gate is applied a second time due to the involution property. Full path: iqm.pulse.gates.move Functions apply_move_gate_phase_corrections (schedule, ...) Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. validate_move_instructions (instructions, builder) Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Classes MOVE_CRF_CRF Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. MOVE_CustomWaveforms Qubit-resonator MOVE gate using flux pulses on both components. MOVE_TGSS_CRF Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the CRF waveform for the qubit flux pulse. MoveMarker Special annotation instruction to indicate the beginning and ending of MOVE gates. Inheritance previous ProbePulse_CustomWaveforms next iqm.pulse.gates.move.apply_move_gate_phase_corrections © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"conditional",url:"/iqm-pulse/api/iqm.pulse.gates.conditional.html",description:"Classically controlled gates. Full path: iqm.pulse.gates.conditional Classes CCPRX_Composite Classically controlled PRX gate. CCPRX_Composite_DRAGCosineRiseFall Conditional drag_crf pulse. CCPRX_Compo...",content:"Classically controlled gates. Full path: iqm.pulse.gates.conditional Classes CCPRX_Composite Classically controlled PRX gate. CCPRX_Composite_DRAGCosineRiseFall Conditional drag_crf pulse. CCPRX_Composite_DRAGGaussian Conditional drag_gaussian pulse. Inheritance previous Barrier next CCPRX_Composite © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"u",url:"/iqm-pulse/api/iqm.pulse.gates.u.html",description:"Single-qubit SU(2) gate. The SU(2) matrix in the computational basis is parametrized using Euler angles: where the angles \\(\\theta\\) , \\(\\phi\\) and \\(\\lambda\\) are in radians. They are the angles of s...",content:`Single-qubit SU(2) gate. The SU(2) matrix in the computational basis is parametrized using Euler angles: where the angles \\(\\theta\\) , \\(\\phi\\) and \\(\\lambda\\) are in radians. They are the angles of subsequent
Z, Y and Z Euler rotations: It rotates the qubit state around an arbitrary axis on the Bloch sphere. Some common single-qubit gates expressed as U gates: References https://openqasm.com/language/gates.html#built-in-gates Full path: iqm.pulse.gates.u Functions get_unitary_u (theta, phi, lam) Unitary for an SU(2) gate. Classes UGate SU(2) gate implemented using PRX. Inheritance previous SXGate next iqm.pulse.gates.u.get_unitary_u © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.OICalibrationData",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.OICalibrationData.html",description:"For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. alias of dict [ tuple [ str , …] | None , dict [ str , Any ]] previous iqm.pulse.gate_...",content:"For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. alias of dict [ tuple [ str , …] | None , dict [ str , Any ]] previous iqm.pulse.gate_implementation.OILCalibrationData next iqm.pulse.gate_implementation.OCalibrationData © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING.html",description:`Locus mapping name for mapping all components that have the flux operation defined and the flux controller
has an AWG. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPI...`,content:`Locus mapping name for mapping all components that have the flux operation defined and the flux controller
has an AWG. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING next iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.scheduler.extend_hard_boundary",url:"/iqm-pulse/api/iqm.pulse.scheduler.extend_hard_boundary.html",description:`Merge two Schedules together such that the timebox boundary is respected. This scheduling algorithm treats the Schedules as hard, rectangular boxes where any ragged edges
will be padded with Waits, an...`,content:`Merge two Schedules together such that the timebox boundary is respected. This scheduling algorithm treats the Schedules as hard, rectangular boxes where any ragged edges
will be padded with Waits, and the boxes are not allowed to overlap. The algorithm is as follows: 1. When adding child_schedule to schedule , the longest channel in schedule that overlaps with the
channels present in child determines the earliest possible starting time for the child_schedule , and all other
channels in schedule are padded with Wait to the aforementioned max length. 2. An occupied channel in schedule will always occupy all channels of the corresponding component (qubit,
coupler, …). This is handled by keeping track of occupied durations for each component (no unnecessary padding
is added to channels which do not have an actual physical pulse). 3. After the schedules are combined, all the common channels of schedule and child_schedule are blocked
up to their common maximum length. This algorithm should not be used with variable sampling rates in the schedule channels. In that case, use extend_hard_boundary_in_seconds() instead. schedule ( Schedule ) – Schedule that should be extended with child_schedule . Modified in place. child_schedule ( Schedule ) – Child schedule to be added. child_components ( set [ str ] ) – Components (qubits, couplers, computational_resonators) that have at least
one channel in child_schedule . neighborhood_components ( set [ str ] ) – QPU components neighboring the child_components that should
additionally be blocked in the scheduling. component_durations ( dict [ str , int ] ) – Blocked durations for each component used by schedule .
These act as the earliest starting points for a new segment added to any of the channels
of the component, but will also block the component even if it has no occupied channels
in the schedule yet or ever (e.g. a computational resonator).
Modified in place. is_alap ( bool ) – Whether the scheduling strategy is ALAP (As Late As Possible). None previous iqm.pulse.scheduler.BLOCKING next iqm.pulse.scheduler.extend_hard_boundary_in_seconds © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.builder.build_quantum_ops",url:"/iqm-pulse/api/iqm.pulse.builder.build_quantum_ops.html",description:`Builds the table of known quantum operations. Hardcoded default native ops table is extended by the ones in ops .
In case of name collisions, the content of ops takes priority over the defaults. ops (...`,content:`Builds the table of known quantum operations. Hardcoded default native ops table is extended by the ones in ops .
In case of name collisions, the content of ops takes priority over the defaults. ops ( dict [ str , Any ] ) – Contents of the gate_definitions section defining the quantum operations in the
configuration YAML file. Modified by the function. Mapping from quantum operation name to its definition dict [ str , QuantumOp ] previous builder next iqm.pulse.builder.load_config © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Wait",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.Wait.html",description:`Bases: Instruction Behave as if outputting zero-valued samples for the duration of the instruction. Used to idle QPU components. However, may be replaced with a dynamical decoupling sequence
after the...`,content:`Bases: Instruction Behave as if outputting zero-valued samples for the duration of the instruction. Used to idle QPU components. However, may be replaced with a dynamical decoupling sequence
after the scheduling step. If you want to make sure that this does not happen, use Block instead. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods duration ( int ) – previous VirtualRZ next playlist © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.circuit_operations.get_unitary_from_op",url:"/iqm-pulse/api/iqm.pulse.circuit_operations.get_unitary_from_op.html",description:`Unitary matrix representing an operation within the context of the circuit. First, fetches the unitary corresponding to the correct operation from the QuantumOpTable. If that unitary
is a function, ge...`,content:`Unitary matrix representing an operation within the context of the circuit. First, fetches the unitary corresponding to the correct operation from the QuantumOpTable. If that unitary
is a function, gets the matrix by calling the function with values of quantum operation params stored
in the operation. Checks whether the size of the unitary is correct. Then, optionally extends that unitary to act
on the Hilbert space of the entire circuit. op ( CircuitOperation ) – quantum operation instance table ( dict [ str , QuantumOp ] ) – registered quantum operations qubits ( list [ str ] ) – qubits of the whole circuit, in big-endian order Unitary matrix representing op on the Hilbert space of the circuit. ndarray previous iqm.pulse.circuit_operations.get_unitary_from_circuit next iqm.pulse.circuit_operations.reorder © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"RealPulse",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.RealPulse.html",description:"Bases: Instruction Play a real-valued pulse. Module: iqm.pulse.playlist.instructions Attributes wave Shape of the pulse. scale Scaling factor for the waveform. duration Time duration of the instructio...",content:"Bases: Instruction Play a real-valued pulse. Module: iqm.pulse.playlist.instructions Attributes wave Shape of the pulse. scale Scaling factor for the waveform. duration Time duration of the instruction. Methods get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) – wave ( Waveform ) – scale ( float ) – Shape of the pulse. Scaling factor for the waveform. Validate the instruction attributes. ValueError – something about the instruction is not ok Returns all the waveforms the Instruction contains. tuple [ Waveform , …] previous ReadoutTrigger next ThresholdStateDiscrimination © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"CircuitOperationList",url:"/iqm-pulse/api/iqm.pulse.circuit_operations.CircuitOperationList.html",description:`Bases: list A list of iqm.pulse.builder.CircuitOperation objects with methods to add, remove and transform them. The class is used to work with CircuitOperation s directly. It is mostly meant as
conve...`,content:`Bases: list A list of iqm.pulse.builder.CircuitOperation objects with methods to add, remove and transform them. The class is used to work with CircuitOperation s directly. It is mostly meant as
convenience to enable easy creation of circuits, calculations of their properties, and mapping them onto physical
qubits. In addition to the list of contents, this class has two important attributes: qubits and table .
The former defines the list of qubits which are allowed to be in the loci of all the CircuitOperation s present in the list. Think about it as the qiskit’s Quantum
Register. The latter is a iqm.pulse.quantum_ops.QuantumOpTable , which contains all the QuantumOp s which are allowed to be in the circuit. In most cases, the table is
simply taken to contain all the default operations defined in iqm-pulse. If using this class in the context of a ScheduleBuilder , it is good practice to set table = builder.op_table . The QuantumOpTable is mutable, so any additional registered gates will automatically
be possible to be used in any CircuitOperationList associated with that ScheduleBuilder instance. The fundamental use of the class would be to first define a new instance: The num_qubits parameter populates the .qubits argument with qubits QB1-QBn, in this case ['QB1', 'QB2'] . Alternatively, you can use qubits directly: To add your own QuantumOpTable, initialize like this: Remembering that the table is mutable. If you already have a list of CircuitOperations, you can initialize with it: Calling the find_qubits() populates the qubits attribute with the qubits found in loci of
the operations included in the original circuit. If the list is empty, it will set qubits to an empty list,
which most of the time is not what you want to do. The class has the add, multiply, and get_item methods redefined, which means all the following: circuit * 3 , circuit1 + circuit2 , and circuit[0:4] will produce a CircuitOperationList with the same qubits and table attributes as the original. To add a prx operation to the list, call: The class also has shortcut methods defined, so the above can be shortened to: Which is exactly the same syntax as in qiskit + implementation name, which usually does not need to be used. The
names of the shortcut methods are taken from the attached table at init. All the operations with non-zero arity
will be added as shortcuts. If all the operations in the circuit are unitary, you can quickly calculate the unitary of the entire circuit
by calling: The dimension of the unitary will always be defined by the qubits attribute. In particular, if your circuit
contains 3 qubits, 'QB1', 'QB2', 'QB3' , but you only add gates to the first two, the resulting unitary will
still be an 8x8 matrix, corresponding to the three qubits 'QB1', 'QB2', 'QB3' , in the big endian convention.
With no operations affecting 'QB3' , you should expect the action of the unitary on this qubit to be an identity. To map the circuit onto physical qubits, all you need to do is call: This will create a copy of the circuit, with all the placeholder qubits replaced by the physical qubits, with the
order defined by the qubits attribute. For example, if qubits = ['QB1', 'QB2', 'QB3'] , and physical_qubits = ['QB2', 'QB5', 'QB10'] , all occurrences of 'QB1' will be mapped to 'QB2' , 'QB2' to 'QB5' and 'QB3' to 'QB10' . The original circuit is not modified, so you can create many copies with
different physical qubits, which is helpful when running parallel experiments on a large chip. args – a list of CircuitOperation objects. Can be empty. qubits ( list [ str ] ) – a list of qubits allowed to be in the circuit. num_qubits ( int ) – the number of qubits allowed to be in the circuit. Ignored if qubits is given. table ( QuantumOpTable | None ) – table containing allowed quantum operations. Module: iqm.pulse.circuit_operations Attributes qubits  Methods add_op Adds a new CircuitOperation to the circuit. add_qubits Adds generic placeholder qubits from 1 to n. barrier Add barrier to the circuit compose A safer way to add circuits together, but will probably take time. count_ops Count each type of operation in the circuit. find_qubits Set attribute qubits to qubits in the loci of operations in the list. get_unitary Calculate the overall unitary implemented by a sequence of CircuitOperations. map_loci Creates a new list of CircuitOperation s with locus mapped onto physical qubits. Set attribute qubits to qubits in the loci of operations in the list. None Adds generic placeholder qubits from 1 to n. n ( int ) – None Calculate the overall unitary implemented by a sequence of CircuitOperations. self – list of CircuitOperations in order qubit_names ( list [ str ] | None ) – Optionally, the ordering of the qubits. Array describing the action of the circuit in big endian convention. ndarray Adds a new CircuitOperation to the circuit. Appends a new CircuitOperation at the end of the list. The CircuitOperation is created using a QuantumOp name from the
QuantumOpTable attached to the CircuitOperationList. The locus of that CircuitOperation is built from the qubits stored in qubits , by selecting
the qubits at indices given by locus_indices . For example, if qubits is ['QB1', 'QB2', 'QB4'] , and the locus_indices is [2, 1] , the locus of the new CircuitOperation will be ('QB4', 'QB2') . All arguments for the values of the
params of the requested QuantumOp need to be provided. name ( str ) – Name of the QuantumOp which will generate a new CircuitOperation . locus_indices ( Sequence [ int ] ) – Indices of the qubits in the attribute .qubits which will become the locus of the operation. args – Any arguments the CircuitOperation needs, must correspond to the params of the QuantumOp . impl_name ( str | None ) – Name of the implementation to use when converting the CircuitOperation into
a Timebox later. None Add barrier to the circuit None A safer way to add circuits together, but will probably take time. All the CircuitOperation s from the 'other' list are appended to the end of
this list. The wire k of the second circuit is connected to wire locus_indices[k] of the first. This
is achieved by mapping the locus of each operation in the second circuit onto the qubits of the first. For example, if the qubits of the first list are ['QB1', 'QB2'] , the second list has ['QB3', 'QB4'] , and the locus_indices argument is [1,0] , all the operations in the second list will have
their 'QB3' mapped to 'QB2' and 'QB4' mapped to 'QB1' . other – Second CircuitOperationList. Must have less or equal qubits than this one. locus_indices ( list [ int ] | None ) – Indices of the qubits in this CircuitOperationList onto which the qubits in the second
circuit ar mapped. Self, with new operations added. Self Count each type of operation in the circuit. Counter mapping operation names to numbers of times they occur in the circuit. Counter Creates a new list of CircuitOperation s with locus mapped onto physical qubits. Creates a fresh list of fresh CircuitOperation s with fresh arguments. If locus is provided, it needs to have the same length as the total number of qubits across the circuit,
and the qubits will then be mapped onto the new locus. If it is not provided, this is identical to a deepcopy
of the original list. locus ( list [ str ] | None ) – List of new qubits to replace the qubits in the loci of the operations in the circuit. make_circuit ( bool ) – If True, creates a CircuitOperationList . If False, it is just a list. New CircuitOperationList with loci mapped onto new locus. CircuitOperationList | list [ CircuitOperation ] Add the convenience methods for adding new operations, based on the default QuantumOpTable . name ( str ) – None previous iqm.pulse.circuit_operations.reshape_unitary next gate_implementation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"SegmentPointer",url:"/iqm-pulse/api/iqm.pulse.scheduler.SegmentPointer.html",description:"Bases: object Tool for working with Segments. Serves as a time pointer inside the Segment. Module: iqm.pulse.scheduler Attributes frac time, in seconds, after the start of the current instruction rema...",content:`Bases: object Tool for working with Segments. Serves as a time pointer inside the Segment. Module: iqm.pulse.scheduler Attributes frac time, in seconds, after the start of the current instruction remainder Remaining duration of the current instruction (in seconds). source contents of the Segment idx index of the current instruction TOL time durations equal or smaller than this tolerance are considered zero (in seconds) Methods cut_tail Cut the source of the pointer at the current index. fastforward Move the pointer forward by duration seconds. get Current instruction. next Move to the beginning of the next instruction. rewind Move the pointer back by duration seconds. tail Instructions from the current index onwards. source ( list [ Instruction ] ) – idx ( int ) – TOL ( float ) – frac ( float ) – contents of the Segment index of the current instruction time durations equal or smaller than this tolerance are considered zero (in seconds) time, in seconds, after the start of the current instruction Current instruction. Instruction Remaining duration of the current instruction (in seconds). Move to the beginning of the next instruction. bool Cut the source of the pointer at the current index. Truncate source at idx , make self point to
the cut tail part only. frac is not changed. Note: modifies source . None Instructions from the current index onwards. Sequence [ Instruction ] Move the pointer back by duration seconds. duration ( float ) – None Move the pointer forward by duration seconds. duration ( float ) – bool previous iqm.pulse.scheduler.extend_schedule_new next timebox © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CZ_CRF_ACStarkCRF",url:"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_CRF_ACStarkCRF.html",description:`Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a cosine rise fall flux pulse for the coupler and a modulated
cosine rise fall (CRF) AC Stark pulse ...`,content:`Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a cosine rise fall flux pulse for the coupler and a modulated
cosine rise fall (CRF) AC Stark pulse on one qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineRiseFall Required calibration data, may be nested alias of ModulatedCosineRiseFall True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous CZ_CRF next CZ_GaussianSmoothedSquare © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CircuitOperation",url:"/iqm-pulse/api/iqm.pulse.builder.CircuitOperation.html",description:"Bases: object Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. Module: iqm.pulse.builder Attributes implementation name of the implementation name name of t...",content:"Bases: object Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. Module: iqm.pulse.builder Attributes implementation name of the implementation name name of the quantum operation locus names of the information-bearing QPU components (qubits, computational resonators...) the operation acts on args arguments for the operation Methods validate Validate the operation against a table of operation definitions. name ( str ) – locus ( tuple [ str , ... ] ) – args ( dict [ str , Any ] ) – implementation ( str | None ) – name of the quantum operation names of the information-bearing QPU components (qubits, computational resonators…) the operation acts on arguments for the operation name of the implementation Validate the operation against a table of operation definitions. op_table ( dict [ str , QuantumOp ] ) – table containing allowed quantum operations ValueError – operation is not valid None previous iqm.pulse.builder.validate_quantum_circuit next ScheduleBuilder © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"XYGate",url:"/iqm-pulse/api/iqm.pulse.gates.enums.XYGate.html",description:"Bases: IntEnum Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Members of this enum can be mapped to the corresponding unitary propagator using XYGATE_UNITARIES . Onl...",content:"Bases: IntEnum Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Members of this enum can be mapped to the corresponding unitary propagator using XYGATE_UNITARIES . Only used in the tomography experiments. Module: iqm.pulse.gates.enums Attributes IDENTITY  X_90  X_180  X_M90  Y_90  Y_180  Y_M90  Methods previous TwoQubitGate next measure © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"visualisation",url:"/iqm-pulse/api/iqm.pulse.playlist.visualisation.html",description:"Full path: iqm.pulse.playlist.visualisation Subpackages and modules base Function for visualising playlists. previous Segment next base © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-0...",content:"Full path: iqm.pulse.playlist.visualisation Subpackages and modules base Function for visualising playlists. previous Segment next base © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"MOVE_CustomWaveforms",url:"/iqm-pulse/api/iqm.pulse.gates.move.MOVE_CustomWaveforms.html",description:`Bases: FluxPulseGate Qubit-resonator MOVE gate using flux pulses on both components. This class implements the extra phase bookkeeping logic required to make the MOVE
gates work as intended. Due to th...`,content:`Bases: FluxPulseGate Qubit-resonator MOVE gate using flux pulses on both components. This class implements the extra phase bookkeeping logic required to make the MOVE
gates work as intended. Due to the unknown phase in the MOVE gate definition, the MOVEs
need to be applied in pairs, i.e. the resonator state is always moved back to the qubit
it came from. Between this pair of MOVE gates you can apply any number of other two-component
gates (CZs for example) between the resonator and other qubits. This sequence of
gates acting on the resonator is called a MOVE sandwich . At the end of a sandwich we have
to apply a local phase correction (z rotation) on the state that was moved back to the qubit. The __call__() method of this class uses the MoveMarker annotation instruction
to mark the beginning and end of each MOVE sandwich, in order to enable the calculation of the
angle of the z rotation to be applied on the moved qubit at the end of the sandwich to
counteract the phase accumulation during the sandwich relative to the computational frame of
the qubit.
The phase accumulation has two sources: Phase due to the frequency detuning between the qubit and the resonator,
proportional to the time duration the MOVE sandwich. Phase due to the virtual z rotations applied on the resonator as
gates are applied between it and another qubit, which need to be summed up.
By convention the resonator VirtualRZ angle of the MOVE implementation itself is currently
always zero (since only the sum of the resonator and qubit z rotation angles matters for MOVE),
but we also include it in the sum for completeness. The phases are calculated and applied on the qubits using apply_move_gate_phase_corrections() . Module: iqm.pulse.gates.move Attributes coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. root_parameters Include the frequency difference between qubit and resonator in the gate parameters for phase tracking. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Include the frequency difference between qubit and resonator in the gate parameters for phase tracking. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Flux pulse Waveform to be played in the coupler flux AWG. Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous MOVE_CRF_CRF next MOVE_TGSS_CRF © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.OpCalibrationDataTree",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.OpCalibrationDataTree.html",description:"Maps quantum operation names to their calibration data. alias of dict [ str , dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]]] previous iqm.pulse.gate_implementation.OCalibrationDat...",content:"Maps quantum operation names to their calibration data. alias of dict [ str , dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]]] previous iqm.pulse.gate_implementation.OCalibrationData next iqm.pulse.gate_implementation.NestedParams © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"scheduler",url:"/iqm-pulse/api/iqm.pulse.scheduler.html",description:`Tools for merging instruction schedules in time. Under the idealized, noiseless, crosstalk-less computational model, the scheduling algorithms
should preserve the effect of the schedules on the comput...`,content:`Tools for merging instruction schedules in time. Under the idealized, noiseless, crosstalk-less computational model, the scheduling algorithms
should preserve the effect of the schedules on the computational subspace, i.e.
executing Schedule A immediately followed by B should be equivalent to
executing the merged schedule A+B . The merging is always done so that in A+B all the channels of B start
their execution simultaneously, and remain in sync. Nothing instructions can be added
as spacers between the channels of A and B as necessary to make this happen. Typically the scheduling algorithms also try to minimize the total duration of the merged schedule. Full path: iqm.pulse.scheduler Module Attributes NONSOLID Instructions that can be converted to Wait after scheduling. BLOCKING Nonsolid Instructions that nevertheless block. Functions extend_hard_boundary (schedule, ...) Merge two Schedules together such that the timebox boundary is respected. extend_hard_boundary_in_seconds (schedule, ...) The same as extend_hard_boundary , but the scheduling is done in seconds. extend_schedule (A, B, channels, *[, TOL]) Extend a Schedule with another Schedule. extend_schedule_new (A, B, channels, *[, TOL]) Extend a Schedule with another Schedule. Classes SegmentPointer Tool for working with Segments. Inheritance previous QuantumOp next iqm.pulse.scheduler.NONSOLID © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Schedule",url:"/iqm-pulse/api/iqm.pulse.playlist.schedule.Schedule.html",description:"Bases: object Set of synchronously executed AWG/readout programs that start on a single trigger. Consists of a number of channels , each containing a Segment of Instruction s for a specific controller...",content:`Bases: object Set of synchronously executed AWG/readout programs that start on a single trigger. Consists of a number of channels , each containing a Segment of Instruction s for a specific controller.  For each channel, maps the channel name to
its Segment of Instructions. Mutable. To make an independent copy, use copy() . contents ( Mapping [ str , Iterable [ Instruction ] ] | None ) – mapping from channel name to a list of Instructions for that channel duration ( int | None ) – Optional precomputed duration (in samples). In cases where the duration is known and performance
is critical, the duration can be given in the constructor, allowing one to skip computing it. Module: iqm.pulse.playlist.schedule Attributes duration The maximum duration of the Schedule's channels, in samples. Methods add_channels Add new empty channels to the schedule. append Append a single Instruction to a specific channel in the Schedule. channels The channels occupied in self . cleanup Cleans up the schedule by removing things that do not affect the execution. copy Make an independent copy of the schedule. duration_in_seconds Schedule duration in seconds, taking into account the sample rates of the channels. extend Append given Instruction to a specific channel in the Schedule. front_pad Modifies the schedule in place by front-padding it with Wait instructions. front_pad_in_seconds Modifies the schedule in place by front-padding it with Wait instructions. has_content_in Returns True if self has content in any of the given channels, otherwise False . items Iterator over the schedule channel names and segments. pad_to_hard_box Pad channels in self to the maximum channel length found within with Wait instructions. pad_to_hard_box_in_seconds Pad channels in self to the maximum channel length (seconds) found within with Wait instructions. pprint Fixed-width character graphics representation of the Schedule. reverse Copy of the schedule with the order of the instructions in each channel reversed. reverse_hard_box Copy of the schedule with the order of the instructions in each channel reversed. validate Validate the contents of the schedule. The maximum duration of the Schedule’s channels, in samples. Computed only when needed and cached for performance. Schedule duration in seconds, taking into account the sample rates of the channels. channel_properties ( dict [ str , ChannelProperties ] ) – channel properties. schedule duration (in seconds) float Fixed-width character graphics representation of the Schedule. Assumes the Instruction.duration s are in samples. time_unit ( int ) – unit of time represented by a single symbol (in samples) str Iterator over the schedule channel names and segments. The channels occupied in self . KeysView Make an independent copy of the schedule. Mutating the original must not affect the copy, or vice versa.
Instructions are immutable, so they need not be copied. copy of the schedule Schedule Add new empty channels to the schedule. If a given channel (identified by its controller name) already exist in the schedule,
it is unchanged. Modifies self . channel_names ( Iterable [ str ] ) – names of the controllers for which empty channels are added None Append a single Instruction to a specific channel in the Schedule. channel ( str ) – name of the channel to append the instruction to instruction ( Instruction ) – instruction to append None Append given Instruction to a specific channel in the Schedule. channel ( str ) – name of the channel to append the instructions to instructions ( Iterable [ Instruction ] ) – instructions to append None Modifies the schedule in place by front-padding it with Wait instructions. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. In that
case, use the method front_pad_in_seconds . to_duration ( int ) – duration of the resulting schedule, in samples self , with the padding Schedule Modifies the schedule in place by front-padding it with Wait instructions. The new duration is given in seconds, and this method works also with variable sample rates. channel_properties ( dict [ str , ChannelProperties ] ) – channel properties. to_duration ( float ) – self , with the padding Pad channels in self to the maximum channel length found within with Wait instructions. The Wait\`\`s are appended to the end of the segments. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. In that case, use the method \`\`pad_to_hard_box_in_seconds . None Pad channels in self to the maximum channel length (seconds) found within with Wait instructions. The Waits are appended to the end of the segments. The segment durations are compared in seconds, so this
method works in the case of variable sampling rates as well. The padding is added to a channel only if the
difference between the channel’s duration and the maximum duration is larger than the smallest possible
instruction duration for that channel. channel_properties ( dict [ str , ChannelProperties ] ) – channel properties (containing the sampling rates and granularities). None Copy of the schedule with the order of the instructions in each channel reversed. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. To preserve synchronization of the channels, the channels are first rear-padded
with Nothing instructions. Schedule Copy of the schedule with the order of the instructions in each channel reversed. No additional time-synchronisation logic is implemented, so this method will break the synchronisation
if self is not a schedule with matching durations in all segments. Schedule Cleans up the schedule by removing things that do not affect the execution. Removes empty channels, and channels that only have idling instructions. Modifies self . Schedule Validate the contents of the schedule. path ( tuple [ str , ... ] ) – None Returns True if self has content in any of the given channels, otherwise False . channel_names ( Iterable [ str ] ) – bool previous Nothing next Segment © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Barrier",url:"/iqm-pulse/api/iqm.pulse.gates.barrier.Barrier.html",description:`Bases: GateImplementation GateImplementation for the n-qudit barrier metaoperation. Returns a schedule with zero-duration Block metainstructions.
When this is appended to another Schedule ,
it causes ...`,content:`Bases: GateImplementation GateImplementation for the n-qudit barrier metaoperation. Returns a schedule with zero-duration Block metainstructions.
When this is appended to another Schedule ,
it causes the affected channels to be padded with Wait instructions to the same length,
which in turn imposes a definite temporal order for the operations on different sides of
the barrier (the ones preceding it are always executed first). Note Assumes that all instructions involve either the drive, flux or probe channels of the locus QPU components. channels – channels related to the locus QPU components, to be blocked parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Module: iqm.pulse.gates.barrier Attributes symmetric True iff the implementation is symmetric in its locus components. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float previous barrier next conditional © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CCPRX_Composite_DRAGGaussian",url:"/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite_DRAGGaussian.html",description:"Bases: CCPRX_Composite Conditional drag_gaussian pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of ...",content:`Bases: CCPRX_Composite Conditional drag_gaussian pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Mapping from operation names to the designated default implementation of that operation. Filling this attribute
allows one to define a different default implementation from the common default in self.builder.op_table to
be used in he context of this composite gate. If an operation is not found in this dict as a key, this
CompositeGate will use the common default as the default implementation for it. previous CCPRX_Composite_DRAGCosineRiseFall next cz © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY",url:"/iqm-pulse/api/iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY.html",description:`Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore
emphasizes the fact that this label should not be manually used in fast feedback). pr...`,content:`Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore
emphasizes the fact that this label should not be manually used in fast feedback). previous reset next iqm.pulse.gates.reset.RESET_FEEDBACK_KEY © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Reset_Conditional",url:"/iqm-pulse/api/iqm.pulse.gates.reset.Reset_Conditional.html",description:`Bases: CompositeGate Conditional reset operation. Uses a measurement followed by a conditional PRX gate with angle \\(\\pi\\) .
It is assumed the measurement projects the state into the computational bas...`,content:`Bases: CompositeGate Conditional reset operation. Uses a measurement followed by a conditional PRX gate with angle \\(\\pi\\) .
It is assumed the measurement projects the state into the computational basis. The conditional PRX implementation handles any necessary waits to accommodate for the feedback result propagation
delay. This reset implementation is factorizable. It can act upon any set of locus components, and the measurement
used in the conditional reset will be multiplexed to those components. However, only locus components that have
readout and drive can be reset via conditional reset. Otherwise, locus components will just have their channels
blocked. Module: iqm.pulse.gates.reset Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Gates that can be calibrated separately from their common calibration existing in self.builder . The gate
names should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can
also be constructed via self.builder , but these will always use the common calibration. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is "<operation_name>.<implementation_name>" . Inheriting classes may
override this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous iqm.pulse.gates.reset.RESET_FEEDBACK_KEY next Reset_Wait © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Instruction",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.Instruction.html",description:"Bases: object Command that can be executed by the quantum computer on a control channel. Has a well-specified time duration. Module: iqm.pulse.playlist.instructions Attributes duration Time duration o...",content:"Bases: object Command that can be executed by the quantum computer on a control channel. Has a well-specified time duration. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods copy Make a copy of the Instruction with the given changes applied to its contents. get_child_instructions Returns all the child Instructions the Instruction contains. get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) – Time duration of the instruction. In samples at the channel sample rate. Validate the instruction attributes. ValueError – something about the instruction is not ok None Make a copy of the Instruction with the given changes applied to its contents. Instruction Returns all the child Instructions the Instruction contains. tuple [ Instruction , …] Returns all the waveforms the Instruction contains. tuple [ Waveform , …] previous IQPulse next MultiplexedIQPulse © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.gates.rz.get_unitary_rz",url:"/iqm-pulse/api/iqm.pulse.gates.rz.get_unitary_rz.html",description:"Unitary for an RZ gate. angle ( float ) – rotation angle (in rad) 2x2 unitary representing rz(angle) . ndarray previous rz next RZ_ACStarkShift © Copyright 2019-2025, IQM Finland Oy. Last updated on 2...",content:"Unitary for an RZ gate. angle ( float ) – rotation angle (in rad) 2x2 unitary representing rz(angle) . ndarray previous rz next RZ_ACStarkShift © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.scheduler.BLOCKING",url:"/iqm-pulse/api/iqm.pulse.scheduler.BLOCKING.html",description:"Nonsolid Instructions that nevertheless block. previous iqm.pulse.scheduler.NONSOLID next iqm.pulse.scheduler.extend_hard_boundary © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04....",content:"Nonsolid Instructions that nevertheless block. previous iqm.pulse.scheduler.NONSOLID next iqm.pulse.scheduler.extend_hard_boundary © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"base",url:"/iqm-pulse/api/iqm.pulse.playlist.visualisation.base.html",description:"Function for visualising playlists. Full path: iqm.pulse.playlist.visualisation.base Functions inspect_playlist (playlist[, segments]) Creates an HTML string from the given playlist and segments. prev...",content:"Function for visualising playlists. Full path: iqm.pulse.playlist.visualisation.base Functions inspect_playlist (playlist[, segments]) Creates an HTML string from the given playlist and segments. previous visualisation next iqm.pulse.playlist.visualisation.base.inspect_playlist © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.quantum_ops.QuantumOpTable",url:"/iqm-pulse/api/iqm.pulse.quantum_ops.QuantumOpTable.html",description:"Type for representing tables of known quantum operations, maps names of the ops to their definitions. alias of dict [ str , QuantumOp ] previous quantum_ops next iqm.pulse.quantum_ops.validate_locus_c...",content:"Type for representing tables of known quantum operations, maps names of the ops to their definitions. alias of dict [ str , QuantumOp ] previous quantum_ops next iqm.pulse.quantum_ops.validate_locus_calibration © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"PRX_DRAGCosineRiseFall",url:"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGCosineRiseFall.html",description:"Bases: PRX_CustomWaveforms PRX gate, DRAG / CosineRiseFall IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel wavefor...",content:`Bases: PRX_CustomWaveforms PRX gate, DRAG / CosineRiseFall IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). excluded_parameters Parameters names to be excluded from self.parameters . parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain
parameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Builds an x_pi pulse out of the calibration data. IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . Required calibration data, may be nested alias of CosineRiseFall alias of CosineRiseFallDerivative previous PRX_CustomWaveformsSX next PRX_DRAGCosineRiseFallSX © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"SchedulingStrategy",url:"/iqm-pulse/api/iqm.pulse.timebox.SchedulingStrategy.html",description:"Bases: Enum Different scheduling strategies for the contents of composite TimeBoxes. Module: iqm.pulse.timebox Attributes ASAP TimeBox contents are scheduled as soon as possible within the box. ALAP T...",content:"Bases: Enum Different scheduling strategies for the contents of composite TimeBoxes. Module: iqm.pulse.timebox Attributes ASAP TimeBox contents are scheduled as soon as possible within the box. ALAP TimeBox contents are scheduled as late as possible within the box. Methods TimeBox contents are scheduled as soon as possible within the box. TimeBox contents are scheduled as late as possible within the box. previous SchedulingAlgorithm next TimeBox © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"pulse",url:"/iqm-pulse/api/iqm.pulse.html",description:"Control pulses and pulse sequences for quantum processors. Full path: iqm.pulse Subpackages and modules builder Tools for building instruction schedules. circuit_operations Methods for operating on li...",content:"Control pulses and pulse sequences for quantum processors. Full path: iqm.pulse Subpackages and modules builder Tools for building instruction schedules. circuit_operations Methods for operating on lists of CircuitOperation objects. gate_implementation Factories for implementing quantum operations in terms of instruction schedules. gates GateImplementations for implementing quantum gates. playlist Control pulses and pulse sequences for quantum processors. quantum_ops Quantum operations. scheduler Tools for merging instruction schedules in time. timebox Reserving QPU resources in instruction scheduling. utils Utility functions. validation Validation of Schedule related data. previous API Reference next builder © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"ConditionalInstruction",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.ConditionalInstruction.html",description:"Bases: Instruction Choice between multiple Instructions, depending on a condition. Module: iqm.pulse.playlist.instructions Attributes condition can be evaluated to an integer >= 0 outcomes maps possib...",content:"Bases: Instruction Choice between multiple Instructions, depending on a condition. Module: iqm.pulse.playlist.instructions Attributes condition can be evaluated to an integer >= 0 outcomes maps possible outcomes of the condition to the corresponding instructions duration Time duration of the instruction. Methods get_child_instructions Returns all the child Instructions the Instruction contains. validate Validate the instruction attributes. duration ( int ) – condition ( str ) – outcomes ( tuple [ Instruction , ... ] ) – can be evaluated to an integer >= 0 maps possible outcomes of the condition to the corresponding instructions Validate the instruction attributes. ValueError – something about the instruction is not ok Returns all the child Instructions the Instruction contains. tuple [ Instruction , …] previous ComplexIntegration next IQPulse © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"validation",url:"/iqm-pulse/api/iqm.pulse.validation.html",description:"Validation of Schedule related data. Full path: iqm.pulse.validation Functions validate_awg_and_schedule_compatibility (...) Validates that the given playlist is compatible with the provided AWG data....",content:"Validation of Schedule related data. Full path: iqm.pulse.validation Functions validate_awg_and_schedule_compatibility (...) Validates that the given playlist is compatible with the provided AWG data. validate_channel (channel_description, ...) Validate a single channel. validate_instruction_and_wf_length (instruction) Validate that instruction and waveform lengths match validate_playlist_compatibility (playlist, ...) Validates that the given playlist is compatible with the provided AWG data. Classes AWGScheduleValidationData Controller specific validation data Exceptions AWGScheduleValidationError Error raised when schedule validation for an AWG fails. InvalidInstructionError (instruction[, ...]) Error raised when encountering an invalid instruction. PlaylistValidationError Error raised when Playlist validation fails. Inheritance previous iqm.pulse.utils.phase_transformation next iqm.pulse.validation.validate_awg_and_schedule_compatibility © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"MultiplexedIQPulse",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.MultiplexedIQPulse.html",description:`Bases: Instruction Instruction to simultaneously play multiple IQ pulses. Each component pulse can have an arbitrary delay from the beginning of this instruction.
Outside the interval of the Multiplex...`,content:`Bases: Instruction Instruction to simultaneously play multiple IQ pulses. Each component pulse can have an arbitrary delay from the beginning of this instruction.
Outside the interval of the MultiplexedIQPulse, the component pulses are truncated.
Where overlapping, samples of component pulse entries are summed.
Where the interval of a MultiplexedIQPulse does not overlap with any of its component pulses,
its samples are zeroes. Module: iqm.pulse.playlist.instructions Attributes entries ( pulse , offset ) pairs. duration Time duration of the instruction. Methods duration ( int ) – entries ( tuple [ tuple [ IQPulse , int ] , ... ] ) – ( pulse , offset ) pairs. offset is the number of samples pulse is delayed from the beginning of the instruction.
It has no granularity constraints. Negative values are allowed, but beginning will be truncated. previous Instruction next ReadoutTrigger © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Cosine",url:"/iqm-pulse/api/iqm.pulse.playlist.waveforms.Cosine.html",description:"Bases: Waveform Periodic sinusoidal waveform which defaults to cosine. The use case for this waveform is to do manual modulation of other waveforms. where \\(f\\) is the frequency, and \\(\\phi\\) the phas...",content:`Bases: Waveform Periodic sinusoidal waveform which defaults to cosine. The use case for this waveform is to do manual modulation of other waveforms. where \\(f\\) is the frequency, and \\(\\phi\\) the phase of the wave. frequency ( float ) – frequency of the wave, in units of inverse sampling window duration phase ( float ) – phase of the wave, in radians n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes phase  frequency  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.
By default all the waveform attributes are “timelike” (the unit for their calibration data is s).
However, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of
consisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).
If a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the
sampling window duration, and all frequency-like calibration data into units of inverse sampling
window duration. dict [ str , str ] previous ChirpImag next CosineRiseFallDerivative © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.utils.phase_transformation",url:"/iqm-pulse/api/iqm.pulse.utils.phase_transformation.html",description:`Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the
IQ pulse implementing the PRX. By commutation rules we have Hence an arbitrary (RZ, PRX, RZ) gate sequence is equi...`,content:`Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the
IQ pulse implementing the PRX. By commutation rules we have Hence an arbitrary (RZ, PRX, RZ) gate sequence is equivalent to (RZ, PRX) with adjusted angles. Use case: with resonant driving, the PRX gate can be implemented using an IQPulse instance,
and the preceding RZ can be handled by decrementing the local oscillator phase beforehand (something
the IQPulse instruction can also do), which is equivalent to rotating the local computational frame
around the z axis in the opposite direction of the required quantum state rotation. psi_1 ( float ) – RZ angle before the PRX (in rad) psi_2 ( float ) – RZ angle after the PRX (in rad) change to the PRX phase angle (in rad),
phase increment for the IQ pulse that implements the remaining RZ (in rad) tuple [ float , float ] previous iqm.pulse.utils.normalize_angle next validation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gates.register_implementation",url:"/iqm-pulse/api/iqm.pulse.gates.register_implementation.html",description:"Register a new gate implementation, and a new gate if needed. TODO: split the method for adding a new gate implementation and a new gate + implementation operations ( dict [ str , QuantumOp ] ) – Know...",content:`Register a new gate implementation, and a new gate if needed. TODO: split the method for adding a new gate implementation and a new gate + implementation operations ( dict [ str , QuantumOp ] ) – Known operations, mapping gate names to QuantumOps. A new QuantumOp is inserted here. gate_name ( str ) – The gate name for which to register a new implementation. impl_name ( str ) – The “human-readable” name with which the new gate implementation will be found e.g. in settings. impl_class ( type [ GateImplementation ] ) – The python class of the new gate implementation to be addded. set_as_default ( bool ) – Whether to set the new implementation as the default implementation for the gate. overwrite ( bool ) – If True, allows replacing any existing implementation of the same name. quantum_op_specs ( QuantumOp | dict | None ) – The quantum operation this gate represents. If a QuantumOp is given, it is used as is.
If None is given and the same gate has been registered before, the previously registered properties are
used.
Otherwise, the given dict values are given to the constructor of QuantumOp .
For any missing constructor values, some defaults suitable for a 1-QB gate are used. None previous iqm.pulse.gates.get_implementation_class next barrier © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING.html",description:"Locus mapping name for mapping all probe lines. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING next iqm.pulse.gate_implementation.get_waveform_parameters © Copyri...",content:"Locus mapping name for mapping all probe lines. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING next iqm.pulse.gate_implementation.get_waveform_parameters © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"FluxPulseGate_TGSS_CRF",url:"/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate_TGSS_CRF.html",description:`Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall
flux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required c...`,content:`Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall
flux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous FluxPulseGate_CRF_CRF next enums © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"ReadoutTrigger",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.ReadoutTrigger.html",description:"Bases: Instruction Instruction for playing a probe pulse and acquiring the associated readout results. Module: iqm.pulse.playlist.instructions Attributes probe_pulse Probe pulse to play, usually a Mul...",content:"Bases: Instruction Instruction for playing a probe pulse and acquiring the associated readout results. Module: iqm.pulse.playlist.instructions Attributes probe_pulse Probe pulse to play, usually a MultiplexedIQPulse. acquisitions Active readout acquisition methods associated with this trigger instance. duration Time duration of the instruction. Methods duration ( int ) – probe_pulse ( MultiplexedIQPulse ) – acquisitions ( tuple [ AcquisitionMethod , ... ] ) – Probe pulse to play, usually a MultiplexedIQPulse. Active readout acquisition methods associated with this trigger instance. previous MultiplexedIQPulse next RealPulse © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"channel",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.html",description:"Control channel properties. Full path: iqm.pulse.playlist.channel Functions get_channel_properties (chip_topology, ...) Internal function to get channel properties. get_channel_properties_from_station...",content:"Control channel properties. Full path: iqm.pulse.playlist.channel Functions get_channel_properties (chip_topology, ...) Internal function to get channel properties. get_channel_properties_from_station_settings (...) Get channel properties from Station Control controller settings following the standard convention. Classes ChannelConfiguration Base class for configuring channels. ChannelDescription Channel specific data, including tables for the instructions and waveforms used. ChannelProperties Defines the properties of a control or measurement channel. IQChannelConfig Requested configuration of an IQ channel. ProbeChannelProperties ChannelProperties for probe line channels. RealChannelConfig Requested configuration of a real channel. Inheritance previous playlist next iqm.pulse.playlist.channel.get_channel_properties © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"ChannelProperties",url:"/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelProperties.html",description:`Bases: object Defines the properties of a control or measurement channel. All ZI instruments (HDAWG, UHFQA, SHFSG, SHFQA) can handle control pulses and waits where the
number of samples is 32 + n * 16...`,content:`Bases: object Defines the properties of a control or measurement channel. All ZI instruments (HDAWG, UHFQA, SHFSG, SHFQA) can handle control pulses and waits where the
number of samples is 32 + n * 16 , where n in {0, 1, 2, ...} . TODO Some of them might be more capable (at least some SHFQA commands can handle 4 + n * 4 ) ? Module: iqm.pulse.playlist.channel Attributes blocks_component Whether content in this channel should block the entire component that it is associated with in the scheduling. is_iq HACK, True iff this is an IQ channel. is_virtual Virtual channels are only used on the frontend side during compilation and scheduling. sample_rate sample rate of the instrument responsible for the channel (in Hz) instruction_duration_granularity all instruction durations on this channel must be multiples of this granularity (in samples) instruction_duration_min all instruction durations on this channel must at least this long (in samples) compatible_instructions instruction types that are allowed on this channel Methods duration_to_int_samples Convert a time duration to an integer number of samples at the channel sample rate. duration_to_samples Convert a time duration to number of samples at the channel sample rate. duration_to_seconds Convert a time duration in samples at the channel sample rate to seconds. round_duration_to_granularity Round a time duration to the channel granularity. sample_rate ( float ) – instruction_duration_granularity ( int ) – instruction_duration_min ( int ) – compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) – is_iq ( bool ) – is_virtual ( bool ) – blocks_component ( bool ) – sample rate of the instrument responsible for the channel (in Hz) all instruction durations on this channel must be multiples of this granularity (in samples) all instruction durations on this channel must at least this long (in samples) instruction types that are allowed on this channel HACK, True iff this is an IQ channel. TODO do better Virtual channels are only used on the frontend side during compilation and scheduling.
They are removed from the Schedule before it is sent to Station
Control. For example, virtual drive channels of computational resonators. Whether content in this channel should block the entire component that it is associated with in the scheduling.
Typically all physical channels should block their components, but certain virtual channels might not
require this. Convert a time duration to number of samples at the channel sample rate. duration ( float ) – time duration in s duration in samples float Convert a time duration in samples at the channel sample rate to seconds. duration ( float ) – time duration in samples duration in seconds float Convert a time duration to an integer number of samples at the channel sample rate. duration must be sufficiently close to an integer number of samples, and
that number must be something the channel can handle. duration ( float ) – time duration in s message ( str ) – message identifying the duration we are testing check_min_samples ( bool ) – If True, check that the output is at least instruction_duration_min . duration as an integer number of samples ValueError – duration is not close to an integer number of samples, or is
    otherwise unacceptable to the channel int Round a time duration to the channel granularity. duration ( float ) – time duration in s round_up ( bool ) – whether to round the durations up to the closest granularity force_min_duration ( bool ) – whether to force the duration to be at least self.instruction_duration_min in
seconds duration rounded to channel granularity, in s float previous ChannelDescription next IQChannelConfig © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"PRX_CustomWaveforms",url:"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_CustomWaveforms.html",description:"Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms ABC for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. Module: iqm.pulse.gates.prx Attributes dependent_waves ...",content:`Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms ABC for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common
to all such implementations. Builds an x_pi pulse out of the calibration data. amplitude_i ( float ) – amplitude_q ( float ) – n_samples ( int ) – IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . previous iqm.pulse.gates.prx.get_unitary_prx next PRX_CustomWaveformsSX © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.playlist.visualisation.base.inspect_playlist",url:"/iqm-pulse/api/iqm.pulse.playlist.visualisation.base.inspect_playlist.html",description:"Creates an HTML string from the given playlist and segments. The output can be viewed in a browser or in a Jupyter notebook using IPython.core.display.HTML . playlist ( Playlist ) – The Playlist to be...",content:"Creates an HTML string from the given playlist and segments. The output can be viewed in a browser or in a Jupyter notebook using IPython.core.display.HTML . playlist ( Playlist ) – The Playlist to be visualised segments ( Sequence [ int ] ) – Indices of the Playlist segments to inspect. The generated raw HTML string. str previous base next waveforms © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"MOVE_CRF_CRF",url:"/iqm-pulse/api/iqm.pulse.gates.move.MOVE_CRF_CRF.html",description:"Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may...",content:`Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineRiseFall Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous iqm.pulse.gates.move.validate_move_instructions next MOVE_CustomWaveforms © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.scheduler.extend_schedule_new",url:"/iqm-pulse/api/iqm.pulse.scheduler.extend_schedule_new.html",description:"Extend a Schedule with another Schedule. Extends A with B , modifying A . The extension can add new channels to A . Can also handle cases where B has a ragged left side, i.e. some of its channels begi...",content:`Extend a Schedule with another Schedule. Extends A with B , modifying A . The extension can add new channels to A . Can also handle cases where B has a ragged left side, i.e. some of its channels begin
with Nothing instructions. A ( Schedule ) – schedule to be extended B ( Schedule ) – schedule to extend A with channels ( dict [ str , ChannelProperties ] ) – properties of the control channels TOL ( float ) – time durations equal or smaller than this are considered zero (in seconds) None previous iqm.pulse.scheduler.extend_schedule next SegmentPointer © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"ScheduleBuilder",url:"/iqm-pulse/api/iqm.pulse.builder.ScheduleBuilder.html",description:`Bases: object Builds instruction schedules out of quantum circuits or individual quantum operations. Encapsulates known quantum ops, the calibration information for them, QPU components and their
topo...`,content:`Bases: object Builds instruction schedules out of quantum circuits or individual quantum operations. Encapsulates known quantum ops, the calibration information for them, QPU components and their
topology, and controller properties. op_table ( QuantumOpTable ) – definitions of known quantum ops calibration ( OpCalibrationDataTree ) – calibration data tree for the quantum ops chip_topology ( ChipTopology ) – Chip topology derived from the CHAD. channels ( dict [ str , ChannelProperties ] ) – mapping of controller names to the configurations of their channels component_channels ( dict [ str , dict [ str , str ] ] ) – Mapping from QPU component name to a mapping of ('drive', 'flux', 'readout') to the name of the control channel responsible for that function of the component. Module: iqm.pulse.builder Attributes composite_cache Cache for the CompositeGate TimeBoxes. Methods build_playlist Build a playlist from a number of instruction schedules. circuit_to_timebox Convert a quantum circuit to a TimeBox. get_calibration Calibration data for the given quantum operation, implementation and locus. get_control_channels Control channels that directly affect quantum operations at the given locus. get_drive_channel Drive channel for the given QPU component. get_flux_channel Flux channel for the given QPU component. get_implementation Provide an implementation for a quantum operation at a given locus. get_implementation_class Implementation class for the given operation. get_probe_channel Probe line channel for the probe line component belongs to. get_virtual_feedback_channel_for Get virtual feedback channel for feedback to a given AWG from a given probe line. get_virtual_feedback_channels All virtual feedback signal channels for the given QPU component. has_calibration Is there calibration data for the given quantum operation, implementation and locus? inject_calibration Inject new calibration data, changing self.calibration after the ScheduleBuilder initialisation. resolve_timebox Resolve a TimeBox. timebox_to_schedule Convert a TimeBox to a finished instruction schedule, ready for execution. timeboxes_to_front_padded_playlist Temporary helper function, for converting a sequence of TimeBoxes to a Playlist. timeboxes_to_playlist Convert a sequence of TimeBoxes to a Playlist. validate_calibration Check that the calibration data matches the known quantum operations. validate_quantum_circuit Validate a sequence of circuit operations constituting a quantum circuit. wait Utility method for applying Block instructions on every channel of the given locus. Cached GateImplementations. The tree has the same structure as OpCalibrationDataTree. Cache for the CompositeGate TimeBoxes. Flushed whenever ANY calibration data is injected into the builder. self.component_channels mapping inverted cached for scheduling algorithm performance. This mapping is
used in the scheduling to determine the components to block based on their associated channels. Only
blocking channels are included in this mapping, non-blocking channels (e.g. certain virtual channels) do not
block their components, just themselves. Cache the probe and non-probe channel names for the scheduling algorithm performance Whether to require scheduling of probe instructions in seconds instead of in samples. This can happen for two
reasons: 1) the probe channel has a different sampling rate to the other channels (e.g. with UHFQA) or
2) the probe channels have a different instruction granularity to some of the other channels (e.g. with
mixed stations that have the RO device from a different vendor than some of the AWGs). Cache representative channel properties for a probe and a non-probe channel for the scheduling algorithm
performance. Inject new calibration data, changing self.calibration after the ScheduleBuilder initialisation. Invalidates the gate_implementation cache for the affected operations/implementations/loci. Also invalidates
the cache for any factorizable gate implementation, if any of its locus components was affected. partial_calibration ( dict [ str , dict [ str , dict [ tuple [ str , ... ] | None , dict [ str , Any ] ] ] ] ) – data to be injected. Must have the same structure as self.calibration but does not
have to contain all operations/implementations/loci/values. Only the parts of the data that are
found will be merged into self.calibration (including any None values). self._cache will
be invalidated for the found operations/implementations/loci and only if the new calibration data
actually differs from the previous. None Check that the calibration data matches the known quantum operations. ValueError – there is something wrong with the calibration data None Drive channel for the given QPU component. component ( str ) – name of a QPU component Name of the drive channel for component , if it exists. KeyError – if component does not exist or does not have a drive channel str Flux channel for the given QPU component. See get_drive_channel() . component ( str ) – str Probe line channel for the probe line component belongs to. See get_drive_channel() . component ( str ) – str All virtual feedback signal channels for the given QPU component. A virtual feedback channel between a source and a destination exists if the station configuration allows it. component can be either the source or the destination of the signal. component ( str ) – name of a QPU component Names of the virtual channels. list [ str ] Get virtual feedback channel for feedback to a given AWG from a given probe line. awg_name ( str ) – name of the awg node that receives the feedback bit. feedback_qubit ( str ) – which qubit’s measurement resulted in the feedback bit The virtual feedback channel name. ValueError – if the given AWG does not support fast feedback from the given probe line. str Control channel name for the given QPU component and operation. name of the channel KeyError – if component does not exist or does not have the operation component ( str ) – operation ( str ) – str Is there calibration data for the given quantum operation, implementation and locus? op_name ( str ) – name of the quantum operation impl_name ( str ) – name of the implementation locus ( tuple [ str , ... ] ) – locus of the operation True iff requested calibration data was found bool Calibration data for the given quantum operation, implementation and locus. op_name ( str ) – name of the quantum operation impl_name ( str ) – name of the implementation locus ( tuple [ str , ... ] ) – locus of the operation requested calibration data ValueError – requested calibration data was not found dict [ str , Any ] Control channels that directly affect quantum operations at the given locus. Includes the probe, drive and flux channels of the locus QPU components.
Does not include e.g. any neighboring coupler channels, these will have to be added
separately in the TimeBox resolution phase. Will only return channels that are known to exist, i.e. are found in ScheduleBuilder.channels . locus ( Iterable [ str ] ) – locus on which the operation acts names of the control channels that directly affect the operation tuple [ str , …] Utility method for applying Block instructions on every channel of the given locus. The Block instructions guarantee the locus components to idle for the given duration,
and cannot e.g. be replaced with e.g. dynamical decoupling sequences.
They are treated the same as any other TimeBox contents: Blocks on different channels remain aligned in time during scheduling. The actual waiting time on a particular channel may thus be >= duration ,
if the other channels have less non-blocking space on either side. Note TODO For now, this method can round duration to the nearest value allowed by each
channel if requested. This is for the benefit of EXA sweeping over waiting durations.
In the future, EXA sweep generation should be responsible for doing the rounding. locus ( Iterable [ str ] ) – locus components that should experience the wait duration ( float ) – how long to wait (in seconds) rounding ( bool ) – Iff True, for each channel separately, duration will be rounded to the
nearest value allowed by the granularity of that channel. The Waits will start
simultaneously. box containing Block instructions on every control channel of locus TimeBox Provide an implementation for a quantum operation at a given locus. op_name ( str ) – name of the quantum operation locus ( Iterable [ str ] ) – locus of the operation impl_name ( str | None ) – name of the implementation ( None means the implementation is chosen automatically
using the logic described below) strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may
be changed if no calibration data is available for the requested locus order use_priority_order ( bool ) – Only has an effect if impl_name is None . Iff False , QuantumOp.get_default_implementation_for_locus() is used. Otherwise, the first implementation in
the priority order that has calibration data for locus is chosen. The priority order is as follows:
1. The locus-specific priority defined in QuantumOp.defaults_for_locus[locus] if any.
2. The global priority order defined in QuantumOp.implementations . priority_calibration ( dict [ str , Any ] | None ) – Calibration data from which to load the calibration instead of the common calibration
data in calibration . If no calibration is found for the given implementation or priority_calibration is None , the common calibration is used. Any non-empty
values found in priority_calibration will be merged to the common calibration. Note:
using priority_calibration will prevent saving/loading via the cache. requested implementation ValueError – requested implementation could not be provided GateImplementation Find an implementation and locus for the given quantum operation instance compatible
with the calibration data. op ( QuantumOp ) – quantum operation impl_name ( str | None ) – Name of the implementation. None means use the highest-priority implementation for
which we have calibration data. locus ( tuple [ str , ... ] ) – locus of the operation strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may
be changed to an equivalent one if no calibration data is available for the requested locus order chosen implementation name, locus ValueError – requested implementation could not be found ValueError – requested implementation had no calibration data for this locus ValueError – no specific implementation was requested, but no known implementation had
    calibration data for this locus tuple [ str , tuple [ str , …]] Build a factory class for the given quantum operation, implementation and locus. The GateImplementations are built when they are first requested, and cached for later use. op ( QuantumOp ) – quantum operation impl_name ( str | None ) – Name of the implementation. None means use the highest-priority implementation for
which we have calibration data. locus ( tuple [ str , ... ] ) – locus of the operation strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may
be changed if no calibration data is available for the requested locus order priority_calibration ( dict [ str , Any ] | None ) – Calibration data from which to load the calibration instead of the common
calibration data. Priority calibration should be either a dict of the type OILCalibrationData ,
i.e. containing the operation name, implementation name, and locus, or just a dict containing
the calibration data for the locus implied by the args op , impl_name and locus . requested implementation ValueError – requested implementation could not be provided or had no calibration data for this locus GateImplementation Implementation class for the given operation. op_name ( str ) – name of the quantum operation impl_name ( str | None ) – name of the implementation ( None means use the default implementation) requested implementation class type [ GateImplementation ] Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) – quantum circuit to be validated require_measurements ( bool ) – iff True the circuit must include at least one measurement operation ValueError – operations do not constitute a valid quantum circuit None Convert a quantum circuit to a TimeBox. circuit ( Iterable [ CircuitOperation ] ) – quantum circuit name ( str ) – name of the circuit scheduling_algorithm ( SchedulingAlgorithm ) – scheduling algorithm to be used in resolving the TimeBoxes. locus_mapping ( dict [ str , str ] | None ) – optional mapping of placeholder component names to the physical component names used
while resolving the circuit into a TimeBox. unresolved TimeBox that implements circuit TimeBox Temporary helper function, for converting a sequence of TimeBoxes to a Playlist. Each individual TimeBox in boxes is resolved into a Schedule, and then
each schedules is front-padded with Wait instructions on each channel
such that the resulting Schedules have equal durations. This is required since
for now in Station Control the delay before the final measurement is the same for
all the Schedules in a Playlist, and we do not wish to lose coherence waiting for
the measurement after each Schedule is done. TODO Once Station Control can handle measurements better, this method should be removed,
and timeboxes_to_playlist() be used instead. boxes ( Iterable [ TimeBox ] ) – TimeBoxes to include in the playlist neighborhood ( int ) – During scheduling, block neighboring channels of the used components this far. By default,
blocks only the defined locus components and any other components which have occupied channels. playlist that implements boxes , padded schedule duration in seconds tuple [ Playlist , float ] Convert a sequence of TimeBoxes to a Playlist. Resolves the boxes, converts them to Schedules, removes unnecessary channels, and then packs
the Schedules into a Playlist. Assumes all the TimeBoxes refer to the same QPU and its control channels. boxes ( Iterable [ TimeBox ] ) – TimeBoxes to include in the playlist neighborhood ( int ) – During scheduling, block neighboring channels of the used components this far.
The default value ensures that quantum operations work as intended, assuming the station
is properly calibrated. Higher values may help defend against crosstalk, at the expense
of a longer instruction schedule and thus more decoherence. playlist that implements boxes Playlist Convert a TimeBox to a finished instruction schedule, ready for execution. Resolves the box, then converts the durations of the instructions in the schedule to samples
at the channel sample_rate. box ( TimeBox ) – TimeBox to resolve neighborhood ( int ) – During scheduling, block neighboring channels of the used components this far.
The default value ensures that quantum operations work as intended, assuming the station
is properly calibrated. Higher values may help defend against crosstalk, at the expense
of a longer instruction schedule and thus more decoherence. finished schedule that implements box Schedule Finishes the instruction schedule. filters out zero-duration Blocks and Waits converts all spacer instructions used during scheduling to Waits merges consequent Waits removes channels that only have Waits in them This should be the final step of the schedule building process, after this the
resulting Schedule can no longer be consistently extended with another (since
all the spacer instructions are gone). schedule ( Schedule ) – schedule to finish finished copy of schedule Schedule Resolve a TimeBox. Resolves recursively each of the children of the box, and then concatenates the resulting
Schedules into a new one using a specific scheduling strategy and algorithm. The supported algorithms are HARD_BOUNDARY , which treats each composite TimeBox as a solid rectangle (the
longest channel within defines the duration) and TETRIS , which packs the schedule as tightly as possible
(solid instructions still cannot overlap) regardless of the TimeBox boundaries. Modifies box so that it becomes atomic, if it isn’t already. box ( TimeBox ) – TimeBox to resolve neighborhood ( int ) – During scheduling, block control channels of neighboring QPU components this far
from the locus. Values higher than 0 may help defend against crosstalk, at the expense
of a longer instruction schedule and thus more decoherence. compute_neighborhood_hard_boundary ( bool ) – Whether to precompute the neighborhood components while resolving
a composite TimeBox in the HARD_BOUNDARY algorithm. Typically one does not want to do this on
the top layer composite TimeBox , since it would be unused. The algorithm sets this True on
lower layers, where it improves the performance as the neighborhood components are needed in scheduling. instruction schedule that implements box Schedule Resolves a TimeBox using the HARD_BOUNDARY algorithm, which treats each composite TimeBox as a solid
rectangle (the longest channel within defines the duration). box ( TimeBox ) – neighborhood ( int ) – compute_neighborhood ( bool ) – Schedule Computes and caches the blocking neighborhoods for HARD_BOUNDARY algorithm. box ( TimeBox ) – Atomic TimeBox whose neighborhood to compute. neighborhood ( int ) – Return QPU components this far from the locus. QPU components (plus maybe channels?) belonging the the given neighborhood of box . set [ str ] Resolves a TimeBox using the TETRIS algorithm, which packs the schedule as tightly as possible
(solid instructions still cannot overlap) regardless of the TimeBox boundaries. box ( TimeBox ) – neighborhood ( int ) – Schedule Add additional blocked channels to the schedule, preventing their use during the schedule. In the idealized computational model we assume that in a (correctly calibrated) quantum computer
there is no effective interaction between QPU components (in the computational frame and subspace) while
a Wait instruction is acting on the flux channel of the coupler connecting those components
(i.e., the coupler is idling).
Hence a QPU component experiences no effective evolution if Wait instructions are
acting on its drive, flux and probe channels, and the flux channels of all its couplers. Of course, in reality the QPU will experience at least some decoherence during a Wait, and
possibly some crosstalk.
In some applications, e.g. decoherence experiments, it is essential to Wait for a specific time,
since it’s precisely the decoherence that we are interested in. However, if we are only interested in applying well-defined local quantum operations on specific
loci, it is essential to shut down all unwanted dynamics by adding Block instructions on
control channels of the unused and neighboring channels.
They act like Waits (and are converted into Waits at the end of the scheduling), but are allowed
to overlap in time, since we are only interested in blocking those channels for the duration of the
quantum operation. schedule ( Schedule ) – instruction schedule to modify locus ( set [ str ] ) – information-carrying QPU components schedule is meant to operate on (does not include couplers) neighborhood ( int ) – How far should we block neighboring QPU components?
Zero means just the locus qubits, one means neighboring couplers, two means their neighboring
qubits etc. schedule , with added Block instructions on all the neighbor channels,
for the duration of the schedule None Build a playlist from a number of instruction schedules. This involves compressing the schedules so that no duplicate information
needs to be transferred to Station Control. All virtual channels are dropped at this point. schedules ( Iterable [ Schedule ] ) – finished instruction schedules to include in the playlist finish_schedules ( bool ) – whether to finalise the schedules before building the playlist. Should be set True unless some process has already finalised them before calling this function. playlist containing the schedules ValueError – if the schedules contain channels with non-uniform sampling rates Playlist Create shortcut for self.get_implementation(<op_name>, …) as self.<op_name>(…) . If there is a name collision with another attribute in self , the shortcut method won’t be added and
a warning is raised. op_name ( str ) – None previous CircuitOperation next circuit_operations © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"ProbePulse_CustomWaveforms",url:"/iqm-pulse/api/iqm.pulse.gates.measure.ProbePulse_CustomWaveforms.html",description:"Bases: CustomIQWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. With given Waveform waveform definitions Something and SomethingElse ...",content:`Bases: CustomIQWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. With given Waveform waveform definitions Something and SomethingElse ,
you may define a measurement implementation that uses them as follows: class MyGate(ProbePulse_CustomWaveforms, i_wave=Something, q_wave=SomethingElse) . Contrary to the Measure_CustomWaveforms class, this implementation acts on proble lines directly (i.e. its locus is a single probe line). The measurement IQPulse instruction will not be automatically modulated
by any frequency, so any modulations should be included in the I and Q waveforms themselves. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common
to all such implementations. Builds a probe pulse and acquisition methods using the calibration data. Subclasses may override this method if needed. waveform_params ( dict [ str , Any ] ) – root_params ( dict [ str , Any ] ) – tuple [ IQPulse , tuple [ AcquisitionMethod , AcquisitionMethod ]] Returns a TimeBox containing the probe pulse measurement. In scheduling, the returned TimeBox blocks only the probe line ( self.locus[0] ). key ( str ) – The time trace results generated on this trigger will be used to assigned to f"{probe_line}__{key}" , where probe_line is the one that handles self.locus[0] . If empty,
the key “readout.time_trace” is used. TimeBox containing the ReadoutTrigger instruction. TimeBox If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is "<operation_name>.<implementation_name>" . Inheriting classes may
override this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous Measure_CustomWaveforms next move © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"reset",url:"/iqm-pulse/api/iqm.pulse.gates.reset.html",description:"Resetting qubits to the zero state. The reset operation is a non-unitary quantum channel that sets the state of a qubit to \\(|0\\rangle\\) . Full path: iqm.pulse.gates.reset Module Attributes RESET_MEAS...",content:"Resetting qubits to the zero state. The reset operation is a non-unitary quantum channel that sets the state of a qubit to \\(|0\\rangle\\) . Full path: iqm.pulse.gates.reset Module Attributes RESET_MEASUREMENT_KEY Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore emphasizes the fact that this label should not be manually used in fast feedback). RESET_FEEDBACK_KEY The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should not be manually used in fast feedback). Classes Reset_Conditional Conditional reset operation. Reset_Wait Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Inheritance previous PRX_SinglePulse_GateImplementation next iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"circuit_operations",url:"/iqm-pulse/api/iqm.pulse.circuit_operations.html",description:"Methods for operating on lists of CircuitOperation objects. Full path: iqm.pulse.circuit_operations Functions get_unitary_from_circuit (circuit[, table, ...]) Calculate the overall unitary implemented...",content:"Methods for operating on lists of CircuitOperation objects. Full path: iqm.pulse.circuit_operations Functions get_unitary_from_circuit (circuit[, table, ...]) Calculate the overall unitary implemented by a sequence of CircuitOperations. get_unitary_from_op (op, table, qubits) Unitary matrix representing an operation within the context of the circuit. reorder (mat, perm) Reorders the qubits in the n-qubit operator A according to the permutation vector perm. reshape_unitary (unitary, indices, n_qubits) Extend a unitary propagator to act on a larger system. Classes CircuitOperationList A list of iqm.pulse.builder.CircuitOperation objects with methods to add, remove and transform them. Inheritance previous ScheduleBuilder next iqm.pulse.circuit_operations.get_unitary_from_circuit © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"measure",url:"/iqm-pulse/api/iqm.pulse.gates.measure.html",description:"Projective measurement in the Z basis. Full path: iqm.pulse.gates.measure Classes Measure_Constant Implementation of a single-qubit projective, dispersive measurement in the Z basis. Measure_CustomWav...",content:"Projective measurement in the Z basis. Full path: iqm.pulse.gates.measure Classes Measure_Constant Implementation of a single-qubit projective, dispersive measurement in the Z basis. Measure_CustomWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. ProbePulse_CustomWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. Inheritance previous XYGate next Measure_Constant © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"enums",url:"/iqm-pulse/api/iqm.pulse.gates.enums.html",description:"Enumerations for representing a set of important one- and two-qubit gates. Full path: iqm.pulse.gates.enums Module Attributes XYGATE_UNITARIES Mapping of XYGates to the corresponding SU(2) matrices TW...",content:"Enumerations for representing a set of important one- and two-qubit gates. Full path: iqm.pulse.gates.enums Module Attributes XYGATE_UNITARIES Mapping of XYGates to the corresponding SU(2) matrices TWO_QUBIT_UNITARIES Mapping of TwoQubitGates to the corresponding U(4) matrices Classes TwoQubitGate Enumerates a subset of two-qubit gates. XYGate Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Inheritance previous FluxPulseGate_TGSS_CRF next iqm.pulse.gates.enums.XYGATE_UNITARIES © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"Nothing",url:"/iqm-pulse/api/iqm.pulse.playlist.schedule.Nothing.html",description:`Bases: Instruction Used to extend a control channel in time, without blocking it, during scheduling. Can overlap with any other Instruction.
Converted to a Wait instruction at the end of scheduling. M...`,content:`Bases: Instruction Used to extend a control channel in time, without blocking it, during scheduling. Can overlap with any other Instruction.
Converted to a Wait instruction at the end of scheduling. Module: iqm.pulse.playlist.schedule Attributes duration Time duration of the instruction. Methods duration ( int ) – previous iqm.pulse.playlist.schedule.TOLERANCE next Schedule © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"waveforms",url:"/iqm-pulse/api/iqm.pulse.playlist.waveforms.html",description:`Waveform definitions. This module defines some waveforms that don’t have special serialization, and reimports
waveforms that do from iqm.models.playlist.waveforms .
See the link for documentation of w...`,content:`Waveform definitions. This module defines some waveforms that don’t have special serialization, and reimports
waveforms that do from iqm.models.playlist.waveforms .
See the link for documentation of waveforms that don’t appear here. Full path: iqm.pulse.playlist.waveforms Classes Chirp Linear chirp, defined as ChirpImag Imaginary part of the linear chirp, which sets the phase to $-pi/2$. Cosine Periodic sinusoidal waveform which defaults to cosine. CosineRiseFallDerivative Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. ModulatedCosineRiseFall Modulated Cosine Rise Fall waveform. Slepian Slepian waveform, which minimizes non-adiabatic errors during a gate. Inheritance previous iqm.pulse.playlist.visualisation.base.inspect_playlist next Chirp © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.circuit_operations.get_unitary_from_circuit",url:"/iqm-pulse/api/iqm.pulse.circuit_operations.get_unitary_from_circuit.html",description:`Calculate the overall unitary implemented by a sequence of CircuitOperations. Iterate through the list of operations, skipping over barrier operations, and calculate the unitary
for each operation, an...`,content:`Calculate the overall unitary implemented by a sequence of CircuitOperations. Iterate through the list of operations, skipping over barrier operations, and calculate the unitary
for each operation, and then calculate the matrix product of all of them. The unitary definition must be present
in the QuantumOpTable given as the second argument. circuit ( list [ CircuitOperation ] ) – list of CircuitOperations in order table ( dict [ str , QuantumOp ] | None ) – Table of all registered quantum ops. qubit_names ( list [ str ] | None ) – Optionally, the ordering of the qubits. Array describing the action of the circuit in big endian convention. ndarray previous circuit_operations next iqm.pulse.circuit_operations.get_unitary_from_op © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CCPRX_Composite",url:"/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite.html",description:`Bases: CompositeGate Classically controlled PRX gate. Applies a PRX gate conditioned on a discriminated readout result obtained in the same segment (active feedback).
Applies a PRX gate if the result ...`,content:`Bases: CompositeGate Classically controlled PRX gate. Applies a PRX gate conditioned on a discriminated readout result obtained in the same segment (active feedback).
Applies a PRX gate if the result is 1, and a Wait of equal duration if the result is 0.
Uses the default implementation of PRX underneath, so no extra calibration is needed. Not usable in the “legacy” readout programming mode. Module: iqm.pulse.gates.conditional Attributes parameters control_delays contains the times it takes for the classical control signal from each probe line (readout instrument) to become usable for the drive AWG implementing the PRX gate. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – control_delays contains the times it takes for the classical control signal from each
probe line (readout instrument) to become usable for the drive AWG implementing the PRX gate.
The delays must be in the same order as the probe lines are listed in
the {drive_controller}.awg.feedback_sources station setting. Two TimeBoxes that together implement the classically controlled PRX gate. The first Timebox is for the control signal delay, and the second has a ConditionalInstruction.
The delay TimeBox operates only on a virtual channel and is used to block the pulse TimeBox
until there has been enough time for the control signal to arrive.
The delay is specified by the control_delays gate parameter. In normal operation, the boxes can be placed sequentially without causing unnecessary delays.
To care of the timing yourself, simply ignore the first TimeBox. angle ( float ) – The PRX rotation angle (rad). phase ( float ) – The PRX rotation phase (rad). feedback_qubit ( str ) – The qubit that was measured to create the feedback bit. feedback_key ( str ) – Identifies the feedback signal if feedback_qubit was measured multiple times.
The feedback label is then f"{feedback_qubit}__{feedback_key}" .
TODO: currently the HW does not support multiple feedback keys per drive channel, so this argument has
no effect. The conditional prx will always listen feedback from the label f"{feedback_qubit}__{FEEDBACK_KEY}" . When the HW is improved, the actual key the user inputs
should be used. A TimeBox for the signal delay, and a TimeBox with a ConditionalInstruction inside. list [ TimeBox ] previous conditional next CCPRX_Composite_DRAGCosineRiseFall © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"gate_implementation",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.html",description:"Factories for implementing quantum operations in terms of instruction schedules. Note Note the conceptual difference between quantum operations (ops) and instruction schedules . Ops represent abstract...",content:`Factories for implementing quantum operations in terms of instruction schedules. Note Note the conceptual difference between quantum operations (ops) and instruction schedules . Ops represent abstract, ideal computational
operations, whereas instruction schedules represent concrete control signal sequences for the
quantum computer. One can (approximately) implement an op using a number of different
instruction schedules. Full path: iqm.pulse.gate_implementation Module Attributes Locus Sequence of QPU component physical names a quantum operation is acting on. OILCalibrationData Calibration data for a particular implementation of a particular quantum operation at a particular locus. OICalibrationData For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. OCalibrationData For a particular quantum operation, maps implementation names to their calibration data. OpCalibrationDataTree Maps quantum operation names to their calibration data. NestedParams Nested dict defining the parameters required by GateImplementation classes. SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING Locus mapping name for mapping all components that have the drive operation defined. SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING Locus mapping name for mapping all components that have the readout operation defined. SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING Locus mapping name for mapping all components that have the flux operation defined and the flux controller has an AWG. PROBE_LINES_LOCUS_MAPPING Locus mapping name for mapping all probe lines. Functions get_waveform_parameters (wave[, label_prefix]) Parameters that are required to initialize the given Waveform class. Classes CompositeCache Cache for CompositeGate TimeBoxes. CompositeGate Utility base class for creating gate implementations that are defined in terms of other gate implementations. CustomIQWaveforms Base class for GateImplementations using custom waveform definition with IQPulses. GateImplementation ABC for implementing quantum gates and other quantum operations using instruction schedules. SinglePulseGate Base class for GateImplementations that play a single pulse on a single channel. Inheritance previous CircuitOperationList next iqm.pulse.gate_implementation.Locus © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"prx",url:"/iqm-pulse/api/iqm.pulse.gates.prx.html",description:"Single-qubit PRX gate. The phased x rotation (PRX) gate is defined as where the rotation angle \\(\\theta\\) and the phase angle \\(\\phi\\) are in radians. It rotates the qubit state around an axis that li...",content:"Single-qubit PRX gate. The phased x rotation (PRX) gate is defined as where the rotation angle \\(\\theta\\) and the phase angle \\(\\phi\\) are in radians. It rotates the qubit state around an axis that lies in the XY plane of the Bloch sphere. Full path: iqm.pulse.gates.prx Functions get_unitary_prx (angle, phase) Unitary for a PRX gate. Classes PRX_CustomWaveforms ABC for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. PRX_CustomWaveformsSX ABC for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. PRX_DRAGCosineRiseFall PRX gate, DRAG / CosineRiseFall IQ pulse implementation. PRX_DRAGCosineRiseFallSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. PRX_DRAGGaussian PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. PRX_DRAGGaussianSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. PRX_GateImplementation ABC for different implementations of the PRX gate. PRX_SinglePulse_GateImplementation ABC for PRX gates implemented using a single IQ pulse. Inheritance previous MoveMarker next iqm.pulse.gates.prx.get_unitary_prx © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"barrier",url:"/iqm-pulse/api/iqm.pulse.gates.barrier.html",description:`Barrier metaoperation. The barrier is an n-qubit metaoperation that forces a specific temporal ordering on the quantum
operations on different sides of it (the ones preceding the barrier are always ex...`,content:`Barrier metaoperation. The barrier is an n-qubit metaoperation that forces a specific temporal ordering on the quantum
operations on different sides of it (the ones preceding the barrier are always executed first). Full path: iqm.pulse.gates.barrier Classes Barrier GateImplementation for the n-qudit barrier metaoperation. Inheritance previous iqm.pulse.gates.register_implementation next Barrier © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CompositeCache",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.CompositeCache.html",description:"Bases: object Cache for CompositeGate TimeBoxes. Result from CompositeGate.__call__`() (or other methods returning a TimeBox) cannot be stored in the normal\ncache GateImplementation._timebox_cache as ...",content:`Bases: object Cache for CompositeGate TimeBoxes. Result from CompositeGate.__call__\`() (or other methods returning a TimeBox) cannot be stored in the normal
cache GateImplementation._timebox_cache as composites can include any gates in their calls, and we cannot trust
that the cache is flushed correctly just based on if the composite itself has its own calibration data changed
(we would have to flush also when any of the composite’s members get new calibration, and this cannot consistently
be deduced). For this reason, CompositeCache will be flushed whenever ANY gate implementation gets new calibration
data. Module: iqm.pulse.gate_implementation Methods flush Flush the CompositeCache. get Get a TimeBox from the cache. set Set a TimeBox into the cache. Set a TimeBox into the cache. gate_implementation ( GateImplementation ) – gate implementation that created the TimeBox. cache_key ( tuple [ Any , ... ] ) – hashable key identifying the TimeBox (usually the CompositeGate.__call__() arguments cast
into a tuple). timebox ( TimeBox ) – TimeBox that will be added to the cache. extra_id ( str ) – extra string id for further identifying the result if needed (for example if the TimeBox did not
come from the call method, but some other method, this could be the method’s name). None Get a TimeBox from the cache. gate_implementation ( GateImplementation ) – gate implementation that created the TimeBox. cache_key ( tuple [ Any , ... ] ) – hashable key identifying the TimeBox (usually the CompositeGate.__call__() arguments cast
into a tuple). extra_id ( str ) – extra string id for further identifying the result (for example if the TimeBox did not come
from the call method, but some other method, this could be the method’s name). The cached TimeBox or None if not fund for this gate_implementation , cache_key , and extra_id . TimeBox | None Flush the CompositeCache. None previous iqm.pulse.gate_implementation.get_waveform_parameters next CompositeGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"QuantumOp",url:"/iqm-pulse/api/iqm.pulse.quantum_ops.QuantumOp.html",description:`Bases: object Describes a native quantum operation type. Quantum operations (or “ops” in short), are simple, abstract, self-contained actions one can
execute on a station as parts of a quantum circuit...`,content:`Bases: object Describes a native quantum operation type. Quantum operations (or “ops” in short), are simple, abstract, self-contained actions one can
execute on a station as parts of a quantum circuit. They include quantum gates, measurements,
and resets. They must have an unambiguous definition in terms of their intended effect on the
computational subspace of the quantum subsystems (qubits, qudits, qumodes…) they act on.
They are implemented on the hardware using instruction schedules . A QuantumOp can also be a metaoperation , which (in an idealized picture) has no effect on the
quantum state, but affects the scheduling of the other ops. Execution barriers are an example of a metaoperation. The ops can have any number of named parameters. For example, PRX is a two-parameter
quantum gate family, whereas CZ is a single gate with no parameters. A locus (plural: loci) is a tuple[str, ...] (an ordered sequence) of CHAD component names
an instance of a quantum operation acts on. The locus consists of those QPU components that store the
quantum information the operation acts on. For example, a CZ gate implemented using a flux
pulse on the coupler connecting the qubits does not include the coupler in its locus, since the
coupler is simply an implementation detail. In a quantum circuit each operation type normally has several different loci. For example, you
could have a PRX gate being used on qubits {('QB1',), ('QB2',), ('QB5',)} , or a CZ gate used on qubit pairs {('QB1', 'QB3'), ('QB3', 'QB5',), ('QB1', 'QB5',)} . Each quantum operation can have any number of named implementations , each represented by a GateImplementation subclass. For example, we may have two implementations of the CZ gate,
one with just a single flux pulse applied to the coupler, and another one with additional flux
pulses applied to the qubits as well. operation defines the abstract intention (what) implementation defines the concrete method (how) locus defines the target of the operation (where) The quantum operations are typically calibrated using specific calibration experiments that
output the required calibration data. Each implementation of each operation can require
its own, independent set of calibration data for each locus. Module: iqm.pulse.quantum_ops Attributes default_implementation Name of the default implementation (the global default). factorizable True iff the operation is always factorizable to independent single-subsystem operations, which is also how it is implemented, for example parallel single-qubit measurements. params Names of required operation parameters, if any. symmetric True iff the effect of operation is symmetric in the quantum subsystems it acts on. unitary Unitary matrix that represents the effect of this quantum operation in the computational basis, or None if the quantum operation is not unitary or the exact unitary is not known. name Unique name of the operation. arity Number of locus components the operation acts on. implementations Maps implementation names to GateImplementation classes that provide them. defaults_for_locus Optionally define the implementation default individually per each locus. Methods copy Make a copy of self with the given changes applied to the contents. get_default_implementation_for_locus Get the default (highest priority) implementation for the given locus. set_default_implementation Sets the given implementation as the default. set_default_implementation_for_locus Set the locus-specific default implementation. name ( str ) – arity ( int ) – params ( tuple [ str , ... ] ) – implementations ( dict [ str , type [ GateImplementation ] ] ) – symmetric ( bool ) – factorizable ( bool ) – defaults_for_locus ( dict [ tuple [ str , ... ] , str ] ) – unitary ( Callable [ ... , np.ndarray ] | None ) – Unique name of the operation. Number of locus components the operation acts on.
Each locus component corresponds to a quantum subsystem in the definition of the operation.
The computational subspace always consists of the lowest two levels of the subsystem.
Zero means the operation can be applied on any number of locus components. Names of required operation parameters, if any. Maps implementation names to GateImplementation classes that provide them.
Each such class should describe the implementation in detail in its docstring.
The implementations are in the dict in priority order, highest-priority (default) first. This global priority
order can be overridden per locus by the attribute defaults_for_locus . True iff the effect of operation is symmetric in the quantum subsystems it acts on.
Only meaningful if self.arity != 1 . True iff the operation is always factorizable to independent single-subsystem operations, which
is also how it is implemented, for example parallel single-qubit measurements.
In this case the operation calibration data is for individual subsystems as well. Optionally define the implementation default individually per each locus. Maps the locus to the default
gate implementation name. If a locus is not found in this dict (by default, the dict is empty), falls back to the
global order defined in implementations . The implementations must be first registered in implementations . Unitary matrix that represents the effect of this quantum operation in the computational basis, or None if the quantum operation is not unitary or the exact unitary is not known.
The Callable needs to take exactly the arguments given in params , for example if params=('angle','phase') , the function must have signature f(angle:float, phase: float) -> np.ndarray .
For operations acting on more than 1 qubit, unitary should be given in the big-endian order, i.e. in the basis np.kron(first_qubit_basis_ket, second_qubit_basis_ket) . Make a copy of self with the given changes applied to the contents. QuantumOp Name of the default implementation (the global default). Sets the given implementation as the default. default ( str ) – name of the new default implementation ValueError – default is unknown or is a special implementation. None Get the default (highest priority) implementation for the given locus. If no locus-specific priority is defined, returns the global default. locus ( Iterable [ str ] ) – tuple of component names defining the locus. The default implementation name. str Set the locus-specific default implementation. default ( str ) – name of the new default implementation for locus . locus ( Iterable [ str ] ) – tuple of component names defining the locus. ValueError – if there is no implementation defined with the name default or default is a special
    implementation. None previous iqm.pulse.quantum_ops.validate_op_calibration next scheduler © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.utils.merge_dicts",url:"/iqm-pulse/api/iqm.pulse.utils.merge_dicts.html",description:"Merge two dictionaries recursively, leaving the originals unchanged. A ( dict ) – dictionary B ( dict ) – another dictionary merge_nones ( bool ) – whether to also merge None and empty Sized values fr...",content:"Merge two dictionaries recursively, leaving the originals unchanged. A ( dict ) – dictionary B ( dict ) – another dictionary merge_nones ( bool ) – whether to also merge None and empty Sized values from B to A. copy of A, with the contents of B merged in (and taking precedence) recursively dict previous iqm.pulse.utils.map_waveform_param_types next iqm.pulse.utils.normalize_angle © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.scheduler.NONSOLID",url:"/iqm-pulse/api/iqm.pulse.scheduler.NONSOLID.html",description:"Instructions that can be converted to Wait after scheduling. previous scheduler next iqm.pulse.scheduler.BLOCKING © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04....",content:"Instructions that can be converted to Wait after scheduling. previous scheduler next iqm.pulse.scheduler.BLOCKING © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"CZ_Slepian_CRF",url:"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian_CRF.html",description:"Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be ...",content:`Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of Slepian Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian_ACStarkCRF next CZ_TruncatedGaussianSmoothedSquare © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.validation.InvalidInstructionError",url:"/iqm-pulse/api/iqm.pulse.validation.InvalidInstructionError.html",description:"Error raised when encountering an invalid instruction. previous iqm.pulse.validation.AWGScheduleValidationError next iqm.pulse.validation.PlaylistValidationError © Copyright 2019-2025, IQM Finland Oy....",content:"Error raised when encountering an invalid instruction. previous iqm.pulse.validation.AWGScheduleValidationError next iqm.pulse.validation.PlaylistValidationError © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"PRX_DRAGGaussianSX",url:"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGGaussianSX.html",description:"Bases: PRX_CustomWaveformsSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel w...",content:`Bases: PRX_CustomWaveformsSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform
so that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,
will be initialised as True . Required calibration data, may be nested alias of TruncatedGaussian alias of TruncatedGaussianDerivative previous PRX_DRAGGaussian next PRX_GateImplementation © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"iqm.pulse.gates.u.get_unitary_u",url:"/iqm-pulse/api/iqm.pulse.gates.u.get_unitary_u.html",description:"Unitary for an SU(2) gate. See iqm.pulse.gates.u for the definition of the gate parameters. theta ( float ) – y rotation angle phi ( float ) – z rotation angle lam ( float ) – another z rotation angle...",content:"Unitary for an SU(2) gate. See iqm.pulse.gates.u for the definition of the gate parameters. theta ( float ) – y rotation angle phi ( float ) – z rotation angle lam ( float ) – another z rotation angle 2x2 unitary representing u(theta, phi, lam) . ndarray previous u next UGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.builder.load_config",url:"/iqm-pulse/api/iqm.pulse.builder.load_config.html",description:"Load quantum operation definitions and calibration data from a YAML config file. path ( str ) – path to a YAML config file quantum operation definitions, calibration data tree tuple [ dict [ str , Qua...",content:"Load quantum operation definitions and calibration data from a YAML config file. path ( str ) – path to a YAML config file quantum operation definitions, calibration data tree tuple [ dict [ str , QuantumOp ], dict [ str , dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]]]] previous iqm.pulse.builder.build_quantum_ops next iqm.pulse.builder.validate_quantum_circuit © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.gates.reset.RESET_FEEDBACK_KEY",url:"/iqm-pulse/api/iqm.pulse.gates.reset.RESET_FEEDBACK_KEY.html",description:`The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should
not be manually used in fast feedback). previous iqm.pulse.gates.reset.RESET_MEASURE...`,content:`The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should
not be manually used in fast feedback). previous iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY next Reset_Conditional © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Slepian",url:"/iqm-pulse/api/iqm.pulse.playlist.waveforms.Slepian.html",description:`Bases: Waveform Slepian waveform, which minimizes non-adiabatic errors during a gate. It is assumed that the user has done the minimization in a prior step, such that the optimal \\(\\lambda_n\\) for
a s...`,content:`Bases: Waveform Slepian waveform, which minimizes non-adiabatic errors during a gate. It is assumed that the user has done the minimization in a prior step, such that the optimal \\(\\lambda_n\\) for
a specific length \\(\\tau_\\text{pulse}\\) (in the accelerated frame) is known. This class then reconstructs the
waveform with the following steps: Calculate \\(\\theta(\\tau)\\) (Slepian in the accelerated frame and in \\(\\theta\\) space) Calculate \\(t(\\tau)\\) (mapping time in the accelerated frame to time in the lab frame) Interpolate \\(\\theta(t)\\) (Slepian in the lab frame and in \\(\\theta\\) space) Calculate \\(f(t)\\) (Slepian in the lab frame and in frequency space) Calculate \\(V(t)\\) (Slepian in the lab frame and in voltage space) Since the waveform is normalized, any voltage pre-factor should go into the pulse amplitude. The user is advised to look up [ 1 ] for further details, since the derivation is mathematically
heavy. full_width ( float ) – Duration of the support of the waveform. lambda_1 ( float ) – First coefficient of Slepian waveform. lambda_2 ( float ) – Second coefficient of Slepian waveform. frequency_initial_normalized ( float ) – Initial frequency of the pulsed component (usually coupler),
normalized by the maximum frequency of the pulsed component. frequency_to_minimize_normalized ( float ) – Frequency of the static component (usually qubit) which to
minimize the leakage from/to, normalized by the maximum frequency of the pulsed component. coupling_strength_normalized ( float ) – Coupling strength between pulsed component and static component,
normalized by the maximum frequency of the pulsed component. center_offset ( float ) – The waveform is centered at this offset from the midpoint of the sampling window. squid_asymmetry ( float ) – Squid asymmetry. n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes center_offset  squid_asymmetry  full_width  lambda_1  lambda_2  frequency_initial_normalized  frequency_to_minimize_normalized  coupling_strength_normalized  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.
By default all the waveform attributes are “timelike” (the unit for their calibration data is s).
However, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of
consisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).
If a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the
sampling window duration, and all frequency-like calibration data into units of inverse sampling
window duration. dict [ str , str ] Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Calculate the samples of the actual Slepian waveform. coords ( ndarray ) – normalized sample coordinates, in \\([0, 1]\\) samples of the Slepian waveform ndarray Convert time in the accelerated frame to the lab frame (real time). Since the conversion is defined via an integral, finding an analytical solution was not possible. Therefore, we
integrate the expression numerically with scipy.integrate.romb() . tau ( float | ndarray ) – Time in the accelerated frame. num_samples ( int ) – Number of samples for the numerical integration. Must be of the form 2 ** k + 1. tau converted to the lab frame ndarray Parametrization of the Slepian waveform in the accelerated frame. The Slepian waveform is parametrized using Fourier base functions, where we only take the cosine terms into
account ( [ 1 ] has shown that this is a reasonable assumption).
Here, \\(\\lambda_n\\) is the amplitude of the \\(n\\) -th term of the Fourier base function.
It is usually sufficient to take only up to second order terms into account, i.e. only \\(\\lambda_1\\) and \\(\\lambda_2\\) are non-zero. tau ( ndarray ) – Time in the accelerated frame, normalized to [0, 1] with tau_pulse. Slepian waveform in the theta space and accelerated frame. ndarray previous ModulatedCosineRiseFall next quantum_ops © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"CCPRX_Composite_DRAGCosineRiseFall",url:"/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite_DRAGCosineRiseFall.html",description:"Bases: CCPRX_Composite Conditional drag_crf pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that ...",content:`Bases: CCPRX_Composite Conditional drag_crf pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Mapping from operation names to the designated default implementation of that operation. Filling this attribute
allows one to define a different default implementation from the common default in self.builder.op_table to
be used in he context of this composite gate. If an operation is not found in this dict as a key, this
CompositeGate will use the common default as the default implementation for it. previous CCPRX_Composite next CCPRX_Composite_DRAGGaussian © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"RZ_ACStarkShift",url:"/iqm-pulse/api/iqm.pulse.gates.rz.RZ_ACStarkShift.html",description:`Bases: GateImplementation Implementation of the RZ gate using an AC Stark pulse. An AC Stark pulse is a strong off-resonant drive on a qubit. This pulse leads to a frequency shift of the qubit due
to ...`,content:`Bases: GateImplementation Implementation of the RZ gate using an AC Stark pulse. An AC Stark pulse is a strong off-resonant drive on a qubit. This pulse leads to a frequency shift of the qubit due
to the AC Stark effect. The qubit frequency shift depends on the AC Stark pulse amplitude and frequency. ac_stark_pulse – AC Stark pulse. channel – Name of the drive channel on which the AC Stark pulse is played. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes ac_stark_waveform  Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float Returns an AC Stark pulse which consists of a modulated I and modulated Q waveform, where the Q quadrature
has an additional phase of -pi/2. n_samples ( int ) – amplitude ( float ) – phase_increment ( float ) – phase ( float ) – IQPulse previous iqm.pulse.gates.rz.get_unitary_rz next RZ_ACStarkShift_CosineRiseFall © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"schedule",url:"/iqm-pulse/api/iqm.pulse.playlist.schedule.html",description:"Instruction schedules for controlling the instruments. Full path: iqm.pulse.playlist.schedule Module Attributes TOLERANCE remove when COMP-1281 is done. Classes Nothing Used to extend a control channe...",content:"Instruction schedules for controlling the instruments. Full path: iqm.pulse.playlist.schedule Module Attributes TOLERANCE remove when COMP-1281 is done. Classes Nothing Used to extend a control channel in time, without blocking it, during scheduling. Schedule Set of synchronously executed AWG/readout programs that start on a single trigger. Segment Sequence of instructions, for a single channel. Inheritance previous playlist next iqm.pulse.playlist.schedule.TOLERANCE © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"iqm.pulse.gate_implementation.OILCalibrationData",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.OILCalibrationData.html",description:"Calibration data for a particular implementation of a particular quantum operation at a particular locus. alias of dict [ str , Any ] previous iqm.pulse.gate_implementation.Locus next iqm.pulse.gate_i...",content:"Calibration data for a particular implementation of a particular quantum operation at a particular locus. alias of dict [ str , Any ] previous iqm.pulse.gate_implementation.Locus next iqm.pulse.gate_implementation.OICalibrationData © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04."},{package:"iqm-pulse",title:"GateImplementation",url:"/iqm-pulse/api/iqm.pulse.gate_implementation.GateImplementation.html",description:"Bases: ABC ABC for implementing quantum gates and other quantum operations using instruction schedules. There is a separate GateImplementation subclass for every implementation of every operation type...",content:`Bases: ABC ABC for implementing quantum gates and other quantum operations using instruction schedules. There is a separate GateImplementation subclass for every implementation of every operation type.
Each GateImplementation instance represents a particular locus for that implementation, and encapsulates
the calibration data it requires. All GateImplementation subclasses __init__ must have exactly the below arguments in order to be
usable via ScheduleBuilder.get_implementation() . GateImplementations also have the __call__() method, which takes the operation parameters
(e.g. rotation angles) as input, and returns a TimeBox instance which implements
an instance of the operation at that locus. parent ( QuantumOp ) – Quantum operation this instance implements. name ( str ) – Name of the implementation provided by this instance. locus ( Locus ) – Locus the operation acts on. calibration_data ( OILCalibrationData ) – (Raw) calibration data for the (operation, implementation, locus) represented by this instance builder ( ScheduleBuilder ) – Schedule builder. Module: iqm.pulse.gate_implementation Attributes parameters Required calibration data, may be nested qualified_name Qualified name of the implementation. special_implementation Set to True if  the implementation is a special purpose implementation that should never get called in ScheduleBuilder.get_implementation unless explicitly requested via the impl_name argument. symmetric True iff the implementation is symmetric in its locus components. Methods build Utility method for constructing a GateImplementation with self.builder . convert_calibration_data Convert time-like items in the calibration data to fractions of the time duration of the gate. duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_custom_locus_mapping Get custom locus mapping for this GateImplementation. get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. get_parameters Calibration data tree the GateImplementation subclass expects for each locus. needs_calibration Whether the implementation needs calibration data to_timebox Wraps the given instruction schedule into an atomic/resolved timebox. True iff the implementation is symmetric in its locus components.
Only meaningful if arity != 1 , and the locus components are of the same type. Required calibration data, may be nested Set to True if  the implementation is a special purpose implementation that should never get called in ScheduleBuilder.get_implementation unless explicitly requested via the impl_name argument. Qualified name of the implementation. Whether the implementation needs calibration data Returns True if the calibration dict must contain a node with keyed with
<operation name>: <implementation name>: <appropriate locus> in order to use this implementation. bool The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs
in the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox | list [ TimeBox ] Utility method for constructing a GateImplementation with self.builder . Inheriting classes may override this in order to add additional logic. op_name ( str ) – operation name locus ( tuple [ str , ... ] ) – locus the operation acts on impl_name ( str | None ) – implementation name. Uses the assigned default implementation if not specified. strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may
be changed if no calibration data is available for the requested locus order Calibrated gate implementation. GateImplementation Wraps the given instruction schedule into an atomic/resolved timebox. schedule ( Schedule ) – TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.
Subclasses can reimplement this method in case it makes sense in their context. float Convert time-like items in the calibration data to fractions of the time duration of the gate. This is a convenience method for converting calibration data items involving time
durations measured in seconds into fractions of the duration of the gate. Values of items that are not measured in seconds or Hz are returned as is. Additionally, converts duration to channel samples and adds it in the converted
calibration data under the key "n_samples" , while the original "duration" key is removed. calibration_data ( OILCalibrationData ) – (subset of) calibration data for the gate/implementation/locus params ( NestedParams ) – (subset of) cls.parameters specifying the calibration_data items
to convert and return channel_props ( ChannelProperties ) – used to convert "duration" from seconds into channel samples duration ( float | None ) – Time duration of the gate, in seconds. If None, calibration_data must have
an item named "duration" , measured in seconds, which will be used instead. converted calibration_data items OILCalibrationData Calibration data tree the GateImplementation subclass expects for each locus. Helper method for EXA use. locus ( Iterable [ str ] ) – Locus component names to replace the wildcard character "*" in the calibration
parameter names. One Setting will be generated for each component name in locus .
If there are no wildcard characters in cls.parameters , this argument has no effect. path ( Iterable [ str ] ) – parts of the dotted name for the root node, if any. EXA setting node describing the required calibration data for each locus.
All the Setting values are None . SettingNode Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is "<operation_name>.<implementation_name>" . Inheriting classes may
override this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str Get custom locus mapping for this GateImplementation. This method can be used to return the locus mapping (wrt. to the given ChipTopology ) for this GateImplementation . Overriding this method allows a GateImplementation to be “self-sufficient” in the
sense that it knows its own locus mapping. chip_topology ( ChipTopology ) – ChipTopology instance in which context to create the custom locus mapping. component_to_channels ( dict [ str , Iterable [ str ] ] ) – dict mapping QPU component names to an Iterable of channel operation names
available for this component (i.e. “readout”, “drive”, “flux”). This info is often needed
in building a locus mapping. Custom locus mapping for this GateImplementation or None if the gate implementation has no need for a custom locus mapping, otherwise the returned mapping should be like in ChipTopology.set_locus_mapping() custom locus mapping, otherwise the returned mapping should be like in ChipTopology.set_locus_mapping() dict [ tuple [ str , …] | frozenset [ str ], tuple [ str , …]] | None previous CustomIQWaveforms next SinglePulseGate © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`},{package:"iqm-pulse",title:"Block",url:"/iqm-pulse/api/iqm.pulse.playlist.instructions.Block.html",description:`Bases: Instruction Behave strictly as if outputting zero-valued samples for the duration of the instruction. Used to block a control channel during compilation.
A more strict version of Wait , cannot ...`,content:`Bases: Instruction Behave strictly as if outputting zero-valued samples for the duration of the instruction. Used to block a control channel during compilation.
A more strict version of Wait , cannot be replaced with DD sequences during compilation.
Converted to a Wait instruction at the end of compilation process. In “Tetris” scheduling, several Block instructions can overlap in time, whereas Waits cannot. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods duration ( int ) – previous AcquisitionMethod next ComplexIntegration © Copyright 2019-2025, IQM Finland Oy. Last updated on 2025-02-04.`}];function am(){const[e,t]=ve.useState(!1),[n,i]=ve.useState(""),[a,o]=ve.useState(ao),s=new bn(ao,{keys:["title","description","package"],threshold:.4});ve.useEffect(()=>{const m=p=>{(p.metaKey||p.ctrlKey)&&p.key==="k"&&(p.preventDefault(),t(!0)),p.key==="Escape"&&t(!1)};return window.addEventListener("keydown",m),()=>window.removeEventListener("keydown",m)},[]),ve.useEffect(()=>{if(n){const m=s.search(n);o(m.map(p=>p.item))}else o(ao)},[n]);const r=()=>{t(!0)},[l,u]=ve.useState(!0),f=[{href:"/docs/iqm-pulse",title:"IQM Pulse",description:"Interface and implementations for control pulses."},{href:"/docs/iqm-pulla",title:"IQM Pulla",description:"Pulse-level access library for compiling quantum circuits."},{href:"https://iqm-finland.github.io/qiskit-on-iqm/",title:"Qiskit on IQM",description:"Qiskit adapter for IQM’s quantum computers."},{href:"https://iqm-finland.github.io/cirq-on-iqm/",title:"Cirq on IQM",description:"Cirq adapter for IQM’s quantum computers."},{href:"https://iqm-finland.github.io/iqm-benchmarks/",title:"IQM Benchmarks",description:"Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing."},{href:"https://iqm-finland.github.io/iqm-client/",title:"IQM Client",description:"Python client for remote access to quantum computers for circuit-level access."},{href:"/docs/iqm-station-control-client",title:"IQM Station Control Client",description:"Python client for remote access to quantum computers for pulse-level access."},{href:"/docs/iqm-exa-common",title:"IQM EXA Common",description:"Abstract interfaces, helpers, utility classes, etc."}];return k.jsx("div",{className:"min-h-screen p-8",children:k.jsxs("div",{className:"max-w-4xl mx-auto",children:[k.jsxs("div",{className:"flex flex-col sm:flex-row mb-4",children:[k.jsx(im,{}),k.jsx("div",{className:"flex gap-4",children:k.jsxs("button",{className:"relative px-4 py-2 text-gray-500",onClick:()=>u(!0),children:["Documentation",k.jsx("span",{className:`block h-1 ml-4 mr-4 ${l?"bg-green-500":"bg-transparent"} absolute bottom-0 left-0 right-0`})]})})]}),k.jsxs("div",{onClick:r,className:"mt-6 mb-6 flex items-center gap-2 p-3 bg-white border border-gray-200 rounded-lg cursor-pointer hover:border-gray-300 transition-colors",children:[k.jsx(hl,{className:"w-5 h-5 text-gray-400"}),k.jsx("span",{className:"text-gray-500",children:"Search all documentation... (Press ⌘K)"})]}),l?k.jsxs(k.Fragment,{children:[k.jsxs("p",{children:["Find below the documentation for IQM client-side libraries that can be used to connect to "," ",k.jsx("a",{href:"https://resonance.meetiqm.com",target:"_blank",children:"IQM Resonance"})," and any IQM on-premise quantum computer."]}),k.jsx("div",{className:"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mt-8",children:f.map((m,p)=>k.jsxs("a",{href:m.href,target:"_blank",className:"p-6 bg-white border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow",children:[k.jsx("h2",{className:"text-lg font-semibold text-gray-900",children:m.title}),k.jsx("p",{className:"mt-2 text-sm text-gray-600",children:m.description})]},p))})]}):k.jsx("h1",{children:"Feature List"}),e&&k.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50 flex items-start justify-center pt-[15vh] z-50",children:k.jsxs("div",{className:"bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[70vh] overflow-hidden",children:[k.jsxs("div",{className:"p-4 border-b border-gray-100 flex items-center gap-3",children:[k.jsx(hl,{className:"w-5 h-5 text-gray-400"}),k.jsx("input",{type:"text",autoFocus:!0,placeholder:"Search documentation...",className:"flex-1 outline-none text-gray-900",value:n,onChange:m=>i(m.target.value)}),k.jsx("button",{onClick:()=>t(!1),className:"p-1 hover:bg-gray-100 rounded-md transition-colors",children:k.jsx(Yh,{className:"w-5 h-5 text-gray-500"})})]}),k.jsx("div",{className:"overflow-y-auto max-h-[calc(70vh-4rem)]",children:a.map((m,p)=>k.jsxs("a",{href:m.url,target:"_blank",className:"block p-4 hover:bg-gray-50 transition-colors",children:[k.jsx("h3",{className:"font-medium text-gray-900",children:m.title}),k.jsx("span",{className:"text-sm text-gray-500 block mt-1",children:m.package}),k.jsx("p",{className:"text-sm text-gray-600 mt-1",children:m.description})]},p))})]})}),k.jsxs("footer",{className:"mt-8 text-center text-sm text-gray-500 border-gray-300 border-t pt-4",children:[k.jsx("span",{children:"Copyright IQM Quantum Computers 2021-2025."}),k.jsx("br",{}),k.jsxs("span",{children:["Need assistance? Contact us ",k.jsx("a",{href:"mailto:support@meetiqm.com",children:"support@meetiqm.com"})]})]})]})})}Ic(document.getElementById("root")).render(k.jsx(ve.StrictMode,{children:k.jsx(am,{})}));
